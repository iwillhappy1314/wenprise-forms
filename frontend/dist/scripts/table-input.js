/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./assets/scripts/modules/table-input.js":
/*!***********************************************!*\
  !*** ./assets/scripts/modules/table-input.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n!function (e, t) {\n  \"object\" == ( false ? 0 : _typeof(exports)) && \"object\" == ( false ? 0 : _typeof(module)) ? module.exports = t() :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n}(window, function () {\n  return function (e) {\n    var t = {};\n    function n(o) {\n      if (t[o]) return t[o].exports;\n      var r = t[o] = {\n        i: o,\n        l: !1,\n        exports: {}\n      };\n      return e[o].call(r.exports, r, r.exports, n), r.l = !0, r.exports;\n    }\n    return n.m = e, n.c = t, n.d = function (e, t, o) {\n      n.o(e, t) || Object.defineProperty(e, t, {\n        enumerable: !0,\n        get: o\n      });\n    }, n.r = function (e) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, n.t = function (e, t) {\n      if (1 & t && (e = n(e)), 8 & t) return e;\n      if (4 & t && \"object\" == _typeof(e) && e && e.__esModule) return e;\n      var o = Object.create(null);\n      if (n.r(o), Object.defineProperty(o, \"default\", {\n        enumerable: !0,\n        value: e\n      }), 2 & t && \"string\" != typeof e) for (var r in e) n.d(o, r, function (t) {\n        return e[t];\n      }.bind(null, r));\n      return o;\n    }, n.n = function (e) {\n      var t = e && e.__esModule ? function () {\n        return e[\"default\"];\n      } : function () {\n        return e;\n      };\n      return n.d(t, \"a\", t), t;\n    }, n.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, n.p = \"/\", n(n.s = 0);\n  }([function (e, t, n) {\n    \"use strict\";\n\n    function o(e, t) {\n      if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n    function r(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var o = t[n];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n      }\n    }\n    n.r(t);\n    var i = function () {\n      function e(t) {\n        var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n        o(this, e), this.name = t, this.icons = {\n          append: null,\n          removeLast: null,\n          insert: null,\n          remove: null,\n          moveUp: null,\n          moveDown: null\n        }, this.isTextBased = n;\n      }\n      var t, n, i;\n      return t = e, (n = [{\n        key: \"generateIcon\",\n        value: function value(e, t) {\n          throw \"*generateIcon* is not overrided for *\".concat(this.name, \"*.\");\n        }\n      }]) && r(t.prototype, n), i && r(t, i), e;\n    }();\n    function u(e) {\n      return (u = \"function\" == typeof Symbol && \"symbol\" == _typeof(Symbol.iterator) ? function (e) {\n        return _typeof(e);\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : _typeof(e);\n      })(e);\n    }\n    function l(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var o = t[n];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n      }\n    }\n    function a(e, t) {\n      return (a = Object.setPrototypeOf || function (e, t) {\n        return e.__proto__ = t, e;\n      })(e, t);\n    }\n    function c(e) {\n      var t = function () {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n        if (Reflect.construct.sham) return !1;\n        if (\"function\" == typeof Proxy) return !0;\n        try {\n          return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n        } catch (e) {\n          return !1;\n        }\n      }();\n      return function () {\n        var n,\n          o = f(e);\n        if (t) {\n          var r = f(this).constructor;\n          n = Reflect.construct(o, arguments, r);\n        } else n = o.apply(this, arguments);\n        return s(this, n);\n      };\n    }\n    function s(e, t) {\n      return !t || \"object\" !== u(t) && \"function\" != typeof t ? function (e) {\n        if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e;\n      }(e) : t;\n    }\n    function f(e) {\n      return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n        return e.__proto__ || Object.getPrototypeOf(e);\n      })(e);\n    }\n    var p = function (e) {\n      !function (e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && a(e, t);\n      }(i, e);\n      var t,\n        n,\n        o,\n        r = c(i);\n      function i(e) {\n        var t;\n        return function (e, t) {\n          if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, i), t = r.call(this, \"icon-default\", !0), Object.assign(t.icons, {\n          append: \"＋\",\n          removeLast: \"－\",\n          insert: \"↜\",\n          remove: \"✕\",\n          moveUp: \"▲\",\n          moveDown: \"▼\"\n        }), e && Object.assign(t.icons, e), t;\n      }\n      return t = i, (n = [{\n        key: \"generateIcon\",\n        value: function value(e, t) {\n          var n = document.createTextNode(this.icons[t] || \"\");\n          return e.appendChild(n), n;\n        }\n      }]) && l(t.prototype, n), o && l(t, o), i;\n    }(i);\n    function d(e) {\n      for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++) n[o - 1] = arguments[o];\n      n && n.length && n.forEach(function (t) {\n        if (t) {\n          var n = t.split(/\\s+/gi);\n          n && n.length && n.forEach(function (t) {\n            t && e.classList.add(t);\n          });\n        }\n      });\n    }\n    function m(e) {\n      return null == e;\n    }\n    function y(e) {\n      return !isNaN(parseFloat(e)) && isFinite(e);\n    }\n    function h(e) {\n      return \"[object Object]\" === Object.prototype.toString.call(e);\n    }\n    function v(e) {\n      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,\n        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,\n        o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,\n        r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null,\n        i = document.createElement(e);\n      return t && (i.id = t), n && (i.name = n), o && d(i, o), r && (i.type = r), i;\n    }\n    function b(e) {\n      return (b = \"function\" == typeof Symbol && \"symbol\" == _typeof(Symbol.iterator) ? function (e) {\n        return _typeof(e);\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : _typeof(e);\n      })(e);\n    }\n    function w(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var o = t[n];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n      }\n    }\n    function g(e, t) {\n      return (g = Object.setPrototypeOf || function (e, t) {\n        return e.__proto__ = t, e;\n      })(e, t);\n    }\n    function O(e) {\n      var t = function () {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n        if (Reflect.construct.sham) return !1;\n        if (\"function\" == typeof Proxy) return !0;\n        try {\n          return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n        } catch (e) {\n          return !1;\n        }\n      }();\n      return function () {\n        var n,\n          o = R(e);\n        if (t) {\n          var r = R(this).constructor;\n          n = Reflect.construct(o, arguments, r);\n        } else n = o.apply(this, arguments);\n        return C(this, n);\n      };\n    }\n    function C(e, t) {\n      return !t || \"object\" !== b(t) && \"function\" != typeof t ? function (e) {\n        if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e;\n      }(e) : t;\n    }\n    function R(e) {\n      return (R = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n        return e.__proto__ || Object.getPrototypeOf(e);\n      })(e);\n    }\n    var k = function (e) {\n      !function (e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && g(e, t);\n      }(i, e);\n      var t,\n        n,\n        o,\n        r = O(i);\n      function i(e) {\n        var t;\n        !function (e, t) {\n          if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, i), t = r.call(this, \"icon-bootstrapicons\");\n        var n = {\n          baseUrl: \"\",\n          icons: null\n        };\n        Object.assign(n, e);\n        var o = {\n          append: \"plus\",\n          removeLast: \"dash\",\n          insert: \"arrow-90deg-left\",\n          remove: \"trash\",\n          moveUp: \"chevron-up\",\n          moveDown: \"chevron-down\"\n        };\n        return n.icons && Object.assign(o, n.icons), t.icons = o, t.baseUrl = n.baseUrl, t;\n      }\n      return t = i, (n = [{\n        key: \"generateIcon\",\n        value: function value(e, t) {\n          var n = document.createElement(\"img\");\n          return n.src = this.baseUrl + this.icons[t] + \".svg\", d(n, this.icons[t]), e.appendChild(n), n;\n        }\n      }]) && w(t.prototype, n), o && w(t, o), i;\n    }(i);\n    function P(e) {\n      return (P = \"function\" == typeof Symbol && \"symbol\" == _typeof(Symbol.iterator) ? function (e) {\n        return _typeof(e);\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : _typeof(e);\n      })(e);\n    }\n    function _(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var o = t[n];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n      }\n    }\n    function S(e, t) {\n      return (S = Object.setPrototypeOf || function (e, t) {\n        return e.__proto__ = t, e;\n      })(e, t);\n    }\n    function j(e) {\n      var t = function () {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n        if (Reflect.construct.sham) return !1;\n        if (\"function\" == typeof Proxy) return !0;\n        try {\n          return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n        } catch (e) {\n          return !1;\n        }\n      }();\n      return function () {\n        var n,\n          o = E(e);\n        if (t) {\n          var r = E(this).constructor;\n          n = Reflect.construct(o, arguments, r);\n        } else n = o.apply(this, arguments);\n        return x(this, n);\n      };\n    }\n    function x(e, t) {\n      return !t || \"object\" !== P(t) && \"function\" != typeof t ? function (e) {\n        if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e;\n      }(e) : t;\n    }\n    function E(e) {\n      return (E = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n        return e.__proto__ || Object.getPrototypeOf(e);\n      })(e);\n    }\n    var B = function (e) {\n      !function (e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && S(e, t);\n      }(i, e);\n      var t,\n        n,\n        o,\n        r = j(i);\n      function i(e) {\n        var t;\n        !function (e, t) {\n          if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, i), t = r.call(this, \"icon-fontawesome5\");\n        var n = {\n          icons: null\n        };\n        Object.assign(n, e);\n        var o = {\n          append: \"fas fa-plus\",\n          removeLast: \"fas fa-minus\",\n          insert: \"fas fa-reply\",\n          remove: \"fas fa-times\",\n          moveUp: \"fas fa-angle-up\",\n          moveDown: \"fas fa-angle-down\"\n        };\n        return n.icons && Object.assign(o, n.icons), t.icons = o, t;\n      }\n      return t = i, (n = [{\n        key: \"generateIcon\",\n        value: function value(e, t) {\n          var n = document.createElement(\"i\");\n          return d(n, this.icons[t]), e.appendChild(n), n;\n        }\n      }]) && _(t.prototype, n), o && _(t, o), i;\n    }(i);\n    function I(e) {\n      return (I = \"function\" == typeof Symbol && \"symbol\" == _typeof(Symbol.iterator) ? function (e) {\n        return _typeof(e);\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : _typeof(e);\n      })(e);\n    }\n    function D(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var o = t[n];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n      }\n    }\n    function F(e, t) {\n      return (F = Object.setPrototypeOf || function (e, t) {\n        return e.__proto__ = t, e;\n      })(e, t);\n    }\n    function T(e) {\n      var t = function () {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n        if (Reflect.construct.sham) return !1;\n        if (\"function\" == typeof Proxy) return !0;\n        try {\n          return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n        } catch (e) {\n          return !1;\n        }\n      }();\n      return function () {\n        var n,\n          o = U(e);\n        if (t) {\n          var r = U(this).constructor;\n          n = Reflect.construct(o, arguments, r);\n        } else n = o.apply(this, arguments);\n        return L(this, n);\n      };\n    }\n    function L(e, t) {\n      return !t || \"object\" !== I(t) && \"function\" != typeof t ? function (e) {\n        if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e;\n      }(e) : t;\n    }\n    function U(e) {\n      return (U = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n        return e.__proto__ || Object.getPrototypeOf(e);\n      })(e);\n    }\n    var A = function (e) {\n      !function (e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && F(e, t);\n      }(i, e);\n      var t,\n        n,\n        o,\n        r = T(i);\n      function i(e) {\n        var t;\n        !function (e, t) {\n          if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, i), t = r.call(this, \"icon-materialdesignicons3\");\n        var n = {\n          icons: null\n        };\n        Object.assign(n, e);\n        var o = {\n          append: \"mdi mdi-plus\",\n          removeLast: \"mdi mdi-minus\",\n          insert: \"mdi mdi-reply\",\n          remove: \"mdi mdi-close\",\n          moveUp: \"mdi mdi-chevron-up\",\n          moveDown: \"mdi mdi-chevron-down\"\n        };\n        return n.icons && Object.assign(o, n.icons), t.icons = o, t;\n      }\n      return t = i, (n = [{\n        key: \"generateIcon\",\n        value: function value(e, t) {\n          var n = document.createElement(\"span\");\n          return d(n, this.icons[t]), e.appendChild(n), n;\n        }\n      }]) && D(t.prototype, n), o && D(t, o), i;\n    }(i);\n    function N(e) {\n      return (N = \"function\" == typeof Symbol && \"symbol\" == _typeof(Symbol.iterator) ? function (e) {\n        return _typeof(e);\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : _typeof(e);\n      })(e);\n    }\n    function G(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var o = t[n];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n      }\n    }\n    function M(e, t) {\n      return (M = Object.setPrototypeOf || function (e, t) {\n        return e.__proto__ = t, e;\n      })(e, t);\n    }\n    function q(e) {\n      var t = function () {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n        if (Reflect.construct.sham) return !1;\n        if (\"function\" == typeof Proxy) return !0;\n        try {\n          return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n        } catch (e) {\n          return !1;\n        }\n      }();\n      return function () {\n        var n,\n          o = $(e);\n        if (t) {\n          var r = $(this).constructor;\n          n = Reflect.construct(o, arguments, r);\n        } else n = o.apply(this, arguments);\n        return V(this, n);\n      };\n    }\n    function V(e, t) {\n      return !t || \"object\" !== N(t) && \"function\" != typeof t ? function (e) {\n        if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e;\n      }(e) : t;\n    }\n    function $(e) {\n      return ($ = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n        return e.__proto__ || Object.getPrototypeOf(e);\n      })(e);\n    }\n    var W = function (e) {\n      !function (e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && M(e, t);\n      }(i, e);\n      var t,\n        n,\n        o,\n        r = q(i);\n      function i(e) {\n        var t;\n        !function (e, t) {\n          if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, i), t = r.call(this, \"icon-ionicon4\");\n        var n = {\n          icons: null\n        };\n        Object.assign(n, e);\n        var o = {\n          append: \"icon ion-md-add\",\n          removeLast: \"icon ion-md-remove\",\n          insert: \"icon ion-md-undo\",\n          remove: \"icon ion-md-close\",\n          moveUp: \"icon ion-md-arrow-dropup\",\n          moveDown: \"icon ion-md-arrow-dropdown\"\n        };\n        return n.icons && Object.assign(o, n.icons), t.icons = o, t;\n      }\n      return t = i, (n = [{\n        key: \"generateIcon\",\n        value: function value(e, t) {\n          var n = document.createElement(\"i\");\n          return d(n, this.icons[t]), e.appendChild(n), n;\n        }\n      }]) && G(t.prototype, n), o && G(t, o), i;\n    }(i);\n    function H(e) {\n      return (H = \"function\" == typeof Symbol && \"symbol\" == _typeof(Symbol.iterator) ? function (e) {\n        return _typeof(e);\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : _typeof(e);\n      })(e);\n    }\n    function z(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var o = t[n];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n      }\n    }\n    function J(e, t) {\n      return (J = Object.setPrototypeOf || function (e, t) {\n        return e.__proto__ = t, e;\n      })(e, t);\n    }\n    function K(e) {\n      var t = function () {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n        if (Reflect.construct.sham) return !1;\n        if (\"function\" == typeof Proxy) return !0;\n        try {\n          return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n        } catch (e) {\n          return !1;\n        }\n      }();\n      return function () {\n        var n,\n          o = X(e);\n        if (t) {\n          var r = X(this).constructor;\n          n = Reflect.construct(o, arguments, r);\n        } else n = o.apply(this, arguments);\n        return Q(this, n);\n      };\n    }\n    function Q(e, t) {\n      return !t || \"object\" !== H(t) && \"function\" != typeof t ? function (e) {\n        if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e;\n      }(e) : t;\n    }\n    function X(e) {\n      return (X = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n        return e.__proto__ || Object.getPrototypeOf(e);\n      })(e);\n    }\n    var Y = function (e) {\n      !function (e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && J(e, t);\n      }(i, e);\n      var t,\n        n,\n        o,\n        r = K(i);\n      function i(e) {\n        var t;\n        !function (e, t) {\n          if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, i), t = r.call(this, \"icon-typicons2\");\n        var n = {\n          icons: null\n        };\n        Object.assign(n, e);\n        var o = {\n          append: \"typcn typcn-plus\",\n          removeLast: \"typcn typcn-minus\",\n          insert: \"typcn typcn-arrow-back\",\n          remove: \"typcn typcn-times\",\n          moveUp: \"typcn typcn-arrow-sorted-up\",\n          moveDown: \"typcn typcn-arrow-sorted-down\"\n        };\n        return n.icons && Object.assign(o, n.icons), t.icons = o, t;\n      }\n      return t = i, (n = [{\n        key: \"generateIcon\",\n        value: function value(e, t) {\n          var n = document.createElement(\"span\");\n          return d(n, this.icons[t]), e.appendChild(n), n;\n        }\n      }]) && z(t.prototype, n), o && z(t, o), i;\n    }(i);\n    function Z(e) {\n      return (Z = \"function\" == typeof Symbol && \"symbol\" == _typeof(Symbol.iterator) ? function (e) {\n        return _typeof(e);\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : _typeof(e);\n      })(e);\n    }\n    function ee(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var o = t[n];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n      }\n    }\n    function te(e, t) {\n      return (te = Object.setPrototypeOf || function (e, t) {\n        return e.__proto__ = t, e;\n      })(e, t);\n    }\n    function ne(e) {\n      var t = function () {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n        if (Reflect.construct.sham) return !1;\n        if (\"function\" == typeof Proxy) return !0;\n        try {\n          return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n        } catch (e) {\n          return !1;\n        }\n      }();\n      return function () {\n        var n,\n          o = re(e);\n        if (t) {\n          var r = re(this).constructor;\n          n = Reflect.construct(o, arguments, r);\n        } else n = o.apply(this, arguments);\n        return oe(this, n);\n      };\n    }\n    function oe(e, t) {\n      return !t || \"object\" !== Z(t) && \"function\" != typeof t ? function (e) {\n        if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e;\n      }(e) : t;\n    }\n    function re(e) {\n      return (re = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n        return e.__proto__ || Object.getPrototypeOf(e);\n      })(e);\n    }\n    var ie = function (e) {\n      !function (e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && te(e, t);\n      }(i, e);\n      var t,\n        n,\n        o,\n        r = ne(i);\n      function i(e) {\n        var t;\n        !function (e, t) {\n          if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, i), t = r.call(this, \"icon-openiconic\");\n        var n = {\n          icons: null\n        };\n        Object.assign(n, e);\n        var o = {\n          append: \"plus\",\n          removeLast: \"minus\",\n          insert: \"share\",\n          remove: \"x\",\n          moveUp: \"chevron-top\",\n          moveDown: \"chevron-bottom\"\n        };\n        return n.icons && Object.assign(o, n.icons), t.icons = o, t;\n      }\n      return t = i, (n = [{\n        key: \"generateIcon\",\n        value: function value(e, t) {\n          var n = document.createElement(\"span\");\n          return n.className = \"oi\", n.dataset.glyph = this.icons[t], n.setAttribute(\"aria-hidden\", \"true\"), e.appendChild(n), n;\n        }\n      }]) && ee(t.prototype, n), o && ee(t, o), i;\n    }(i);\n    function ue(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var o = t[n];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n      }\n    }\n    var le = function () {\n      function e(t, n) {\n        !function (e, t) {\n          if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, e), this.i18n = t, this.iconFramework = n, this.sectionClasses = {\n          table: null,\n          thead: null,\n          theadRow: null,\n          theadCell: null,\n          tbody: null,\n          tbodyRow: null,\n          tbodyCell: null,\n          tfoot: null,\n          tfootRow: null,\n          tfootCell: null,\n          first: null,\n          last: null,\n          control: null,\n          button: null,\n          buttonGroup: null,\n          append: null,\n          removeLast: null,\n          insert: null,\n          remove: null,\n          moveUp: null,\n          moveDown: null,\n          empty: null\n        };\n      }\n      var t, n, o;\n      return t = e, (n = [{\n        key: \"applySectionClasses\",\n        value: function value(e) {\n          for (var t in this.sectionClasses) e[t] && (this.sectionClasses[t] ? this.sectionClasses[t] += \" \" + e[t] : this.sectionClasses[t] = e[t]);\n        }\n      }, {\n        key: \"getSectionClasses\",\n        value: function value(e) {\n          return this.sectionClasses[e];\n        }\n      }, {\n        key: \"createButtonGroup\",\n        value: function value() {\n          return null;\n        }\n      }, {\n        key: \"generateButton\",\n        value: function value(e, t, n) {\n          var o = v(\"button\", n, null, null, \"button\");\n          return o.title = this.i18n[t], d(o, this.getSectionClasses(\"button\"), this.getSectionClasses(t)), e.appendChild(o), this.iconFramework.generateIcon(o, t), o;\n        }\n      }, {\n        key: \"generateControl\",\n        value: function value(e, t, n, o) {\n          var r = null;\n          if (\"select\" === t.type) {\n            if (r = v(\"select\", n, o), Array.isArray(t.ctrlOptions)) {\n              if (t.ctrlOptions.length > 0) if (h(t.ctrlOptions[0])) for (var i = null, u = null, l = 0; l < t.ctrlOptions.length; l++) {\n                m(t.ctrlOptions[l].group) ? u = null : i !== t.ctrlOptions[l].group && (i = t.ctrlOptions[l].group, (u = v(\"optgroup\")).label = i, r.appendChild(u));\n                var a = v(\"option\");\n                a.value = t.ctrlOptions[l].value, a.innerText = t.ctrlOptions[l].label, m(t.ctrlOptions[l].title) || a.setAttribute(\"title\", t.ctrlOptions[l].title), null === u ? a.appendTo(r) : a.appendTo(u);\n              } else for (var c = 0; c < t.ctrlOptions.length; c++) {\n                var s = t.ctrlOptions[c];\n                r.options[r.options.length] = new Option(s, s);\n              }\n            } else if (h(t.ctrlOptions)) for (var f in t.ctrlOptions) r.options[r.options.length] = new Option(t.ctrlOptions[f], f);else if (\"string\" == typeof t.ctrlOptions) for (var p = t.ctrlOptions.split(\";\"), y = 0; y < p.length; y++) {\n              var b = p[y].indexOf(\":\");\n              r.options[r.options.length] = -1 === b ? new Option(p[y], p[y]) : new Option(p[y].substring(b + 1, p[y].length), p[y].substring(0, b));\n            } else \"function\" == typeof t.ctrlOptions && t.ctrlOptions(r);\n          } else if (\"checkbox\" === t.type) (r = v(\"input\", n, o, null, \"checkbox\")).value = 1;else if (\"textarea\" === t.type) r = v(\"textarea\", n, o);else if (-1 != t.type.search(/^(color|date|datetime|datetime\\-local|email|month|number|range|search|tel|time|url|week)$/)) {\n            r = v(\"input\", n, o);\n            try {\n              r.type = t.type;\n            } catch (e) {}\n          } else (r = v(\"input\", n, o)).type = \"text\";\n          return d(r, this.getSectionClasses(\"control\"), t.ctrlClass), e && e.appendChild(r), r;\n        }\n      }]) && ue(t.prototype, n), o && ue(t, o), e;\n    }();\n    function ae(e) {\n      return (ae = \"function\" == typeof Symbol && \"symbol\" == _typeof(Symbol.iterator) ? function (e) {\n        return _typeof(e);\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : _typeof(e);\n      })(e);\n    }\n    function ce(e, t) {\n      return (ce = Object.setPrototypeOf || function (e, t) {\n        return e.__proto__ = t, e;\n      })(e, t);\n    }\n    function se(e) {\n      var t = function () {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n        if (Reflect.construct.sham) return !1;\n        if (\"function\" == typeof Proxy) return !0;\n        try {\n          return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n        } catch (e) {\n          return !1;\n        }\n      }();\n      return function () {\n        var n,\n          o = pe(e);\n        if (t) {\n          var r = pe(this).constructor;\n          n = Reflect.construct(o, arguments, r);\n        } else n = o.apply(this, arguments);\n        return fe(this, n);\n      };\n    }\n    function fe(e, t) {\n      return !t || \"object\" !== ae(t) && \"function\" != typeof t ? function (e) {\n        if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e;\n      }(e) : t;\n    }\n    function pe(e) {\n      return (pe = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n        return e.__proto__ || Object.getPrototypeOf(e);\n      })(e);\n    }\n    var de = function (e) {\n      !function (e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && ce(e, t);\n      }(n, e);\n      var t = se(n);\n      function n(e, o, r) {\n        var i;\n        return function (e, t) {\n          if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, n), (i = t.call(this, o, r)).name = \"ui-default\", i;\n      }\n      return n;\n    }(le);\n    function me(e) {\n      return (me = \"function\" == typeof Symbol && \"symbol\" == _typeof(Symbol.iterator) ? function (e) {\n        return _typeof(e);\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : _typeof(e);\n      })(e);\n    }\n    function ye(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var o = t[n];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n      }\n    }\n    function he(e, t, n) {\n      return (he = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get : function (e, t, n) {\n        var o = function (e, t) {\n          for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = ge(e)););\n          return e;\n        }(e, t);\n        if (o) {\n          var r = Object.getOwnPropertyDescriptor(o, t);\n          return r.get ? r.get.call(n) : r.value;\n        }\n      })(e, t, n || e);\n    }\n    function ve(e, t) {\n      return (ve = Object.setPrototypeOf || function (e, t) {\n        return e.__proto__ = t, e;\n      })(e, t);\n    }\n    function be(e) {\n      var t = function () {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n        if (Reflect.construct.sham) return !1;\n        if (\"function\" == typeof Proxy) return !0;\n        try {\n          return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n        } catch (e) {\n          return !1;\n        }\n      }();\n      return function () {\n        var n,\n          o = ge(e);\n        if (t) {\n          var r = ge(this).constructor;\n          n = Reflect.construct(o, arguments, r);\n        } else n = o.apply(this, arguments);\n        return we(this, n);\n      };\n    }\n    function we(e, t) {\n      return !t || \"object\" !== me(t) && \"function\" != typeof t ? function (e) {\n        if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e;\n      }(e) : t;\n    }\n    function ge(e) {\n      return (ge = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n        return e.__proto__ || Object.getPrototypeOf(e);\n      })(e);\n    }\n    var Oe = function (e) {\n      !function (e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && ve(e, t);\n      }(i, e);\n      var t,\n        n,\n        o,\n        r = be(i);\n      function i(e, t, n) {\n        var o;\n        !function (e, t) {\n          if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, i), (o = r.call(this, t, n)).name = \"ui-bootstrap4\";\n        var u = {\n          useButtonGroup: !0,\n          sectionClasses: null,\n          sizing: \"normal\"\n        };\n        Object.assign(u, e);\n        var l = {\n          table: \"table\",\n          thead: \"thead-light\",\n          control: \"form-control\",\n          button: \"btn\",\n          buttonGroup: \"btn-group\",\n          append: \"btn-outline-secondary\",\n          removeLast: \"btn-outline-secondary\",\n          insert: \"btn-outline-secondary\",\n          remove: \"btn-outline-secondary\",\n          moveUp: \"btn-outline-secondary\",\n          moveDown: \"btn-outline-secondary\",\n          empty: \"text-center\"\n        };\n        return \"small\" === u.sizing ? (l.table += \" table-sm\", l.buttonGroup += \" btn-group-sm\", l.control += \" form-control-sm\") : \"large\" === u.sizing && (l.buttonGroup += \" btn-group-lg\", l.control += \" form-control-lg\"), u.sectionClasses && Object.assign(l, u.sectionClasses), o.applySectionClasses(l), o.uiParams = u, o;\n      }\n      return t = i, (n = [{\n        key: \"createButtonGroup\",\n        value: function value() {\n          if (this.uiParams.useButtonGroup) {\n            var e = document.createElement(\"div\");\n            return d(e, this.getSectionClasses(\"buttonGroup\")), e;\n          }\n          return he(ge(i.prototype), \"createButtonGroup\", this).call(this);\n        }\n      }, {\n        key: \"generateControl\",\n        value: function value(e, t, n, o) {\n          var r = null;\n          if (\"checkbox\" === t.type) {\n            var u = v(\"div\", null, null, \"form-check\");\n            e.appendChild(u), (r = v(\"input\", n, o, \"form-check-input position-static\")).type = \"checkbox\", r.value = 1, d(r, t.ctrlClass), u.appendChild(r);\n          } else \"readonly\" === t.type ? (d(r = v(\"input\", n, o, null, \"text\"), this.getSectionClasses(\"control\"), t.ctrlClass), r.classList.remove(\"form-control\"), r.classList.add(\"form-control-plaintext\"), r.readOnly = !0, e.appendChild(r)) : r = he(ge(i.prototype), \"generateControl\", this).call(this, e, t, n, o);\n          return r;\n        }\n      }]) && ye(t.prototype, n), o && ye(t, o), i;\n    }(le);\n    function Ce(e) {\n      return (Ce = \"function\" == typeof Symbol && \"symbol\" == _typeof(Symbol.iterator) ? function (e) {\n        return _typeof(e);\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : _typeof(e);\n      })(e);\n    }\n    function Re(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var o = t[n];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n      }\n    }\n    function ke(e, t, n) {\n      return (ke = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get : function (e, t, n) {\n        var o = function (e, t) {\n          for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = je(e)););\n          return e;\n        }(e, t);\n        if (o) {\n          var r = Object.getOwnPropertyDescriptor(o, t);\n          return r.get ? r.get.call(n) : r.value;\n        }\n      })(e, t, n || e);\n    }\n    function Pe(e, t) {\n      return (Pe = Object.setPrototypeOf || function (e, t) {\n        return e.__proto__ = t, e;\n      })(e, t);\n    }\n    function _e(e) {\n      var t = function () {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n        if (Reflect.construct.sham) return !1;\n        if (\"function\" == typeof Proxy) return !0;\n        try {\n          return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n        } catch (e) {\n          return !1;\n        }\n      }();\n      return function () {\n        var n,\n          o = je(e);\n        if (t) {\n          var r = je(this).constructor;\n          n = Reflect.construct(o, arguments, r);\n        } else n = o.apply(this, arguments);\n        return Se(this, n);\n      };\n    }\n    function Se(e, t) {\n      return !t || \"object\" !== Ce(t) && \"function\" != typeof t ? function (e) {\n        if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e;\n      }(e) : t;\n    }\n    function je(e) {\n      return (je = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n        return e.__proto__ || Object.getPrototypeOf(e);\n      })(e);\n    }\n    var xe = function (e) {\n      !function (e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && Pe(e, t);\n      }(i, e);\n      var t,\n        n,\n        o,\n        r = _e(i);\n      function i(e, t, n) {\n        var o;\n        !function (e, t) {\n          if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, i), (o = r.call(this, t, n)).name = \"ui-bulma\";\n        var u = {\n          useButtonGroup: !0,\n          sectionClasses: null,\n          sizing: \"normal\"\n        };\n        Object.assign(u, e);\n        var l = {\n          table: \"table\",\n          control: \"input\",\n          button: \"button\",\n          buttonGroup: \"field has-addons\",\n          append: \"is-outlined\",\n          removeLast: \"is-outlined\",\n          insert: \"is-outlined\",\n          remove: \"is-outlined\",\n          moveUp: \"is-outlined\",\n          moveDown: \"is-outlined\",\n          empty: \"has-text-centered\"\n        };\n        return \"small\" === u.sizing ? (l.table += \" is-narrow\", l.control += \" is-small\", l.button += \" is-small\") : \"medium\" === u.sizing ? (l.control += \" is-medium\", l.button += \" is-medium\") : \"large\" === u.sizing && (l.control += \" is-large\", l.button += \" is-large\"), u.sectionClasses && Object.assign(l, u.sectionClasses), o.applySectionClasses(l), o.uiParams = u, o;\n      }\n      return t = i, (n = [{\n        key: \"generateButton\",\n        value: function value(e, t, n) {\n          var o = v(\"button\", n, null, null, \"button\");\n          o.title = this.i18n[t], d(o, this.getSectionClasses(\"button\"), this.getSectionClasses(t));\n          var r = null;\n          if (this.iconFramework.isTextBased ? r = o : ((r = document.createElement(\"span\")).classList.add(\"icon\"), o.appendChild(r)), this.iconFramework.generateIcon(r, t), this.uiParams.useButtonGroup) {\n            var i = document.createElement(\"p\");\n            i.classList.add(\"control\"), i.appendChild(o), e.appendChild(i);\n          } else e.appendChild(o);\n          return o;\n        }\n      }, {\n        key: \"createButtonGroup\",\n        value: function value() {\n          if (this.uiParams.useButtonGroup) {\n            var e = document.createElement(\"div\");\n            return d(e, this.getSectionClasses(\"buttonGroup\")), e;\n          }\n          return ke(je(i.prototype), \"createButtonGroup\", this).call(this);\n        }\n      }, {\n        key: \"generateControl\",\n        value: function value(e, t, n, o) {\n          var r = null;\n          if (\"select\" === t.type) {\n            var u = v(\"div\", null, null, \"select\");\n            \"small\" === this.uiParams.sizing ? u.classList.add(\"is-small\") : \"medium\" === this.uiParams.sizing ? u.classList.add(\"is-medium\") : \"large\" === this.uiParams.sizing && u.classList.add(\"is-large\"), e.appendChild(u), d(r = ke(je(i.prototype), \"generateControl\", this).call(this, null, t, n, o), t.ctrlClass), u.appendChild(r);\n          } else if (\"checkbox\" === t.type) {\n            var l = v(\"label\", null, null, \"checkbox\");\n            e.appendChild(l), (r = v(\"input\", n, o, null, \"checkbox\")).value = 1, d(r, t.ctrlClass), l.appendChild(r);\n          } else \"readonly\" === t.type ? (d(r = v(\"input\", n, o, null, \"text\"), this.getSectionClasses(\"control\"), t.ctrlClass), r.classList.add(\"is-static\"), r.readOnly = !0, e.appendChild(r)) : r = ke(je(i.prototype), \"generateControl\", this).call(this, e, t, n, o);\n          return r;\n        }\n      }]) && Re(t.prototype, n), o && Re(t, o), i;\n    }(le);\n    function Ee(e) {\n      return (Ee = \"function\" == typeof Symbol && \"symbol\" == _typeof(Symbol.iterator) ? function (e) {\n        return _typeof(e);\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : _typeof(e);\n      })(e);\n    }\n    function Be(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var o = t[n];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n      }\n    }\n    function Ie(e, t, n) {\n      return (Ie = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get : function (e, t, n) {\n        var o = function (e, t) {\n          for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = Le(e)););\n          return e;\n        }(e, t);\n        if (o) {\n          var r = Object.getOwnPropertyDescriptor(o, t);\n          return r.get ? r.get.call(n) : r.value;\n        }\n      })(e, t, n || e);\n    }\n    function De(e, t) {\n      return (De = Object.setPrototypeOf || function (e, t) {\n        return e.__proto__ = t, e;\n      })(e, t);\n    }\n    function Fe(e) {\n      var t = function () {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n        if (Reflect.construct.sham) return !1;\n        if (\"function\" == typeof Proxy) return !0;\n        try {\n          return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n        } catch (e) {\n          return !1;\n        }\n      }();\n      return function () {\n        var n,\n          o = Le(e);\n        if (t) {\n          var r = Le(this).constructor;\n          n = Reflect.construct(o, arguments, r);\n        } else n = o.apply(this, arguments);\n        return Te(this, n);\n      };\n    }\n    function Te(e, t) {\n      return !t || \"object\" !== Ee(t) && \"function\" != typeof t ? function (e) {\n        if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e;\n      }(e) : t;\n    }\n    function Le(e) {\n      return (Le = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n        return e.__proto__ || Object.getPrototypeOf(e);\n      })(e);\n    }\n    var Ue = function (e) {\n      !function (e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && De(e, t);\n      }(i, e);\n      var t,\n        n,\n        o,\n        r = Fe(i);\n      function i(e, t, n) {\n        var o;\n        !function (e, t) {\n          if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, i), (o = r.call(this, t, n)).name = \"ui-foundation6\";\n        var u = {\n          useButtonGroup: !0,\n          sectionClasses: null\n        };\n        Object.assign(u, e);\n        var l = {\n          button: \"button\",\n          buttonGroup: \"button-group\"\n        };\n        return u.sectionClasses && Object.assign(l, u.sectionClasses), o.applySectionClasses(l), o.uiParams = u, o;\n      }\n      return t = i, (n = [{\n        key: \"createButtonGroup\",\n        value: function value() {\n          if (this.uiParams.useButtonGroup) {\n            var e = document.createElement(\"div\");\n            return d(e, this.getSectionClasses(\"buttonGroup\")), e;\n          }\n          return Ie(Le(i.prototype), \"createButtonGroup\", this).call(this);\n        }\n      }]) && Be(t.prototype, n), o && Be(t, o), i;\n    }(le);\n    function Ae(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var o = t[n];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n      }\n    }\n    var Ne = function () {\n      function e(t) {\n        !function (e, t) {\n          if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, e);\n        var n = this;\n        Object.assign(n, {\n          uniqueIndex: 0,\n          rowOrder: [],\n          isDataLoaded: !1,\n          visibleCount: 0,\n          finalColSpan: 0,\n          hideLastColumn: !1,\n          settings: null,\n          tbWhole: null,\n          tbBody: null,\n          iconFramework: null,\n          uiFramework: null\n        });\n        var o = Object.assign({}, t);\n        n.settings = o;\n        var r = null;\n        if (!(r = \"string\" == typeof o.element ? document.getElementById(o.element) : o.element) || !r.tagName || \"TABLE\" !== r.tagName) throw \"*element* is not defined or is not a table DOM element.\";\n        if (n.tbWhole = r, r.innerHTML = \"\", \"bootstrapicons\" === o.iconFramework) n.iconFramework = new k(o.iconParams);else if (\"fontawesome5\" === o.iconFramework) n.iconFramework = new B(o.iconParams);else if (\"ionicon4\" === o.iconFramework) n.iconFramework = new W(o.iconParams);else if (\"materialdesignicons3\" === o.iconFramework) n.iconFramework = new A(o.iconParams);else if (\"openiconic\" === o.iconFramework) n.iconFramework = new ie(o.iconParams);else if (\"typicons2\" === o.iconFramework) n.iconFramework = new Y(o.iconParams);else {\n          if (o.iconFramework && \"default\" !== o.iconFramework) throw \"Unknown Icon framework *\".concat(o.iconFramework, \"*.\");\n          n.iconFramework = new p(o.iconParams);\n        }\n        if (\"bootstrap4\" === o.uiFramework) n.uiFramework = new Oe(o.uiParams, o.i18n, n.iconFramework);else if (\"bulma\" === o.uiFramework) n.uiFramework = new xe(o.uiParams, o.i18n, n.iconFramework);else if (\"foundation6\" === o.uiFramework) n.uiFramework = new Ue(o.uiParams, o.i18n, n.iconFramework);else {\n          if (o.uiFramework && \"default\" !== o.uiFramework) throw \"Unknown UI framework *\".concat(o.uiFramework, \"*.\");\n          n.uiFramework = new de(o.uiParams, o.i18n, n.iconFramework);\n        }\n        m(o.idPrefix) && (r.id ? o.idPrefix = r.id : o.idPrefix = \"ag\" + new Date().getTime()), o.sectionClasses && n.uiFramework.applySectionClasses(o.sectionClasses), d(r, n.uiFramework.getSectionClasses(\"table\"));\n        var i = n.createElement(\"thead\");\n        r.appendChild(i);\n        var u,\n          l = n.createElement(\"tr\", \"theadRow\");\n        i.appendChild(l);\n        var a = 0;\n        o.hideRowNumColumn || (u = n.createElement(\"th\", \"theadCell\"), l.appendChild(u), a++);\n        for (var c = 0, s = 0; s < o.columns.length; s++) if (\"hidden\" !== o.columns[s].type) {\n          if (0 === c) {\n            if (u = n.createElement(\"th\", \"theadCell\"), l.appendChild(u), d(u, o.columns[s].displayClass), !m(o.columns[s].displayCss)) for (var f in o.columns[s].displayCss) u.style[f] = o.columns[s].displayCss[f];\n            o.columns[s].headerSpan > 1 && (u.setAttribute(\"colSpan\", o.columns[s].headerSpan), c = o.columns[s].headerSpan - 1), \"function\" == typeof o.columns[s].display ? o.columns[s].display(u) : o.columns[s].display && (u.innerText = o.columns[s].display);\n          } else c--;\n          a++;\n        }\n        u = n.createElement(\"th\", \"theadCell\"), o.hideButtons.insert && o.hideButtons.remove && o.hideButtons.moveUp && o.hideButtons.moveDown ? (n.hideLastColumn = !0, u.style.display = \"none\") : a++, !n.hideLastColumn && o.rowButtonsInFront ? o.hideRowNumColumn ? l.insertBefore(u, l.firstChild) : l.insertBefore(u, l.childNodes[1]) : l.appendChild(u), n.finalColSpan = a;\n        var y = n.createElement(\"tbody\");\n        r.appendChild(y), n.tbBody = y;\n        var h = n.createElement(\"tfoot\");\n        r.appendChild(h), l = n.createElement(\"tr\", \"tfootRow\"), h.appendChild(l), (u = n.createElement(\"td\", \"tfootCell\")).colSpan = n.finalColSpan, l.appendChild(u);\n        var b = o.idPrefix + \"_rowOrder\",\n          w = v(\"input\", b, b, null, \"hidden\");\n        if (u.appendChild(w), o.hideButtons.append && o.hideButtons.removeLast) l.style.display = \"none\";else {\n          var g = n.uiFramework.createButtonGroup();\n          if (g ? u.appendChild(g) : g = u, !o.hideButtons.append) n.uiFramework.generateButton(g, \"append\").addEventListener(\"click\", function (e) {\n            n.insertRow(1);\n          });\n          if (!o.hideButtons.removeLast) n.uiFramework.generateButton(g, \"removeLast\").addEventListener(\"click\", function (e) {\n            n.removeRow();\n          });\n        }\n        this.showEmptyMessage(), n.settings = o;\n      }\n      var t, n, o;\n      return t = e, (n = [{\n        key: \"createElement\",\n        value: function value(e, t, n) {\n          return v(e, n, null, this.uiFramework.getSectionClasses(t || e));\n        }\n      }, {\n        key: \"loadData\",\n        value: function value(e) {\n          var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n          if (!Array.isArray(e) || !e.length) throw \"*records* should be in array format!\";\n          var n = this,\n            o = n.settings;\n          n.tbBody.innerHTML = \"\", n.rowOrder.length = 0, n.uniqueIndex = 0;\n          for (var r = n.insertRow(e.length), i = 0; i < r.addedRows.length; i++) {\n            for (var u = 0; u < o.columns.length; u++) n.setCtrlValue(u, n.rowOrder[i], e[i][o.columns[u].name]);\n            \"function\" == typeof o.rowDataLoaded && o.rowDataLoaded(n.tbWhole, e[i], i, n.rowOrder[i]);\n          }\n          n.isDataLoaded = !0, t && (n.settings.initData = null), \"function\" == typeof o.dataLoaded && o.dataLoaded(n.tbWhole, e);\n        }\n      }, {\n        key: \"insertRow\",\n        value: function value(e, t, n) {\n          var o,\n            r,\n            i = this,\n            u = i.settings,\n            l = i.uiFramework,\n            a = i.tbBody,\n            c = [],\n            s = null,\n            f = !1,\n            p = e,\n            h = !1;\n          if (Array.isArray(e) && (p = e.length, h = !0), y(n)) {\n            for (var b = 0; b < i.rowOrder.length; b++) if (i.rowOrder[b] === n) {\n              t = b, 0 !== b && (s = b - 1);\n              break;\n            }\n          } else y(t) ? t >= i.rowOrder.length ? t = null : s = t - 1 : 0 !== i.rowOrder.length && (t = null, s = i.rowOrder.length - 1);\n          0 === i.rowOrder.length && (a.innerHTML = \"\");\n          for (var w = function w(n) {\n              if (0 < u.maxRowsAllowed && i.rowOrder.length >= u.maxRowsAllowed) return f = !0, \"break\";\n              var s = ++i.uniqueIndex,\n                p = [];\n              if ((o = i.createElement(\"tr\", \"tbodyRow\", u.idPrefix + \"_$row_\" + s)).dataset.uniqueIndex = s, y(t)) {\n                var b = t + n;\n                i.rowOrder.splice(b, 0, s), a.insertBefore(o, a.childNodes[b]);\n              } else i.rowOrder.push(s), a.appendChild(o);\n              c.push(s), u.hideRowNumColumn || ((r = i.createElement(\"td\", \"tbodyCell\", u.idPrefix + \"_$rowNum_\" + s)).innerText = \"\" + i.rowOrder.length, d(r, l.getSectionClasses(\"first\")), o.appendChild(r));\n              for (var w = 0; w < u.columns.length; w++) if (\"hidden\" !== u.columns[w].type) {\n                if (r = i.createElement(\"td\", \"tbodyCell\"), o.appendChild(r), d(r, u.columns[w].cellClass), !m(u.columns[w].cellCss)) for (var g in u.columns[w].cellCss) r.style[g] = u.columns[w].cellCss[g];\n                var O = u.idPrefix + \"_\" + u.columns[w].name + \"_\" + s,\n                  C = void 0;\n                C = \"function\" == typeof u.nameFormatter ? u.nameFormatter(u.idPrefix, u.columns[w].name, s) : O;\n                var R = null,\n                  k = \"custom\" === u.columns[w].type;\n                if (k) \"function\" == typeof u.columns[w].customBuilder && (R = u.columns[w].customBuilder(r, u.idPrefix, u.columns[w].name, s));else {\n                  if (R = i.uiFramework.generateControl(r, u.columns[w], O, C), !m(u.columns[w].ctrlAttr)) for (var P in u.columns[w].ctrlAttr) R.setAttribute(P, u.columns[w].ctrlAttr[P]);\n                  if (!m(u.columns[w].ctrlCss)) for (var _ in u.columns[w].ctrlCss) R.style[_] = u.columns[w].ctrlCss[_];\n                  if (u.columns[w].events) {\n                    R.dataset.columnName = u.columns[w].name, R.dataset.uniqueIndex = s;\n                    var S = function S(e) {\n                      var t = u.columns[w].events[e];\n                      R.addEventListener(e, function (e) {\n                        e.columnName = e.currentTarget.dataset.columnName, e.uniqueIndex = parseInt(e.currentTarget.dataset.uniqueIndex), t(e);\n                      });\n                    };\n                    for (var j in u.columns[w].events) S(j);\n                  }\n                }\n                h ? i.setCtrlValue(w, s, e[n][u.columns[w].name]) : m(u.columns[w].value) || i.setCtrlValue(w, s, u.columns[w].value), k || \"function\" != typeof u.columns[w].ctrlAdded || u.columns[w].ctrlAdded(R, r, s);\n              } else p.push(w);\n              if (r = i.createElement(\"td\", \"tbodyCell\", u.idPrefix + \"_$rowButton_\" + s), i.hideLastColumn || !u.rowButtonsInFront ? o.appendChild(r) : u.hideRowNumColumn ? o.insertBefore(r, o.firstChild) : o.insertBefore(r, o.childNodes[1]), p.forEach(function (t) {\n                var o,\n                  l = u.columns[t].name,\n                  a = u.idPrefix + \"_\" + l + \"_\" + s;\n                o = \"function\" == typeof u.nameFormatter ? u.nameFormatter(u.idPrefix, l, s) : a, r.appendChild(v(\"input\", a, o, null, \"hidden\")), h ? i.setCtrlValue(t, s, e[n][l]) : m(u.columns[t].value) || i.setCtrlValue(t, s, u.columns[t].value);\n              }), i.hideLastColumn) r.style.display = \"none\";else if (u.columns.length > i.visibleCount) {\n                d(r, l.getSectionClasses(\"last\"));\n                var x = l.createButtonGroup();\n                x ? r.appendChild(x) : x = r, [\"insert\", \"remove\", \"moveUp\", \"moveDown\"].forEach(function (e) {\n                  if (!u.hideButtons[e]) {\n                    var t = u.idPrefix + \"_$\" + e + \"_\" + s,\n                      n = l.generateButton(x, e, t);\n                    n.dataset.uniqueIndex = s, n.addEventListener(\"click\", function (t) {\n                      var n = parseInt(t.currentTarget.dataset.uniqueIndex);\n                      i.rowButtonActions(e, n);\n                    });\n                  }\n                });\n              }\n            }, g = 0; g < p && \"break\" !== w(g); g++);\n          return i.saveSetting(), u.hideRowNumColumn || m(t) || i.sortSequence(t), y(t) ? \"function\" == typeof u.afterRowInserted && u.afterRowInserted(i.tbWhole, s, c) : \"function\" == typeof u.afterRowAppended && u.afterRowAppended(i.tbWhole, s, c), f && \"function\" == typeof u.maxNumRowsReached && u.maxNumRowsReached(i.tbWhole), {\n            addedRows: c,\n            parentIndex: s,\n            rowIndex: t\n          };\n        }\n      }, {\n        key: \"removeRow\",\n        value: function value(e, t, n) {\n          var o = this.settings,\n            r = this.tbBody;\n          if (y(t)) for (var i = 0; i < this.rowOrder.length; i++) if (this.rowOrder[i] === t) {\n            e = i;\n            break;\n          }\n          y(e) ? (n || \"function\" != typeof o.beforeRowRemove || o.beforeRowRemove(this.tbWhole, e)) && (this.rowOrder.splice(e, 1), r.removeChild(r.childNodes[e]), this.saveSetting(), o.hideRowNumColumn || this.sortSequence(e), \"function\" == typeof o.afterRowRemoved && o.afterRowRemoved(this.tbWhole, e)) : (n || \"function\" != typeof o.beforeRowRemove || o.beforeRowRemove(this.tbWhole, this.rowOrder.length - 1)) && (t = this.rowOrder.pop(), r.removeChild(r.lastChild), this.saveSetting(), \"function\" == typeof o.afterRowRemoved && o.afterRowRemoved(this.tbWhole, null)), 0 === this.rowOrder.length && this.showEmptyMessage();\n        }\n      }, {\n        key: \"moveUpRow\",\n        value: function value(e, t) {\n          var n = this.settings,\n            o = this.tbBody,\n            r = null;\n          if (y(e) && e > 0 && e < this.rowOrder.length ? (r = e, t = this.rowOrder[e]) : y(t) && (r = this.findRowIndex(t)), !m(r) && r > 0) {\n            var i = this.rowOrder[r - 1],\n              u = document.getElementById(n.idPrefix + \"_$row_\" + t),\n              l = document.getElementById(n.idPrefix + \"_$row_\" + i);\n            if (o.removeChild(u), o.insertBefore(u, l), this.rowOrder[r] = i, this.rowOrder[r - 1] = t, !n.hideRowNumColumn) {\n              var a = document.getElementById(n.idPrefix + \"_$rowNum_\" + t),\n                c = document.getElementById(n.idPrefix + \"_$rowNum_\" + i),\n                s = c.innerHTML;\n              c.innerHTML = a.innerHTML, a.innerHTML = s;\n            }\n            this.saveSetting(), document.getElementById(n.idPrefix + \"_$moveUp_\" + t).blur(), document.getElementById(n.idPrefix + \"_$moveUp_\" + i).focus(), \"function\" == typeof n.afterRowSwapped && n.afterRowSwapped(this.tbWhole, r, r - 1);\n          }\n        }\n      }, {\n        key: \"moveDownRow\",\n        value: function value(e, t) {\n          var n = this.settings,\n            o = this.tbBody,\n            r = null;\n          if (y(e) && e >= 0 && e < this.rowOrder.length - 1 ? (r = e, t = this.rowOrder[e]) : y(t) && (r = this.findRowIndex(t)), !m(r) && r !== this.rowOrder.length - 1) {\n            var i = this.rowOrder[r + 1],\n              u = document.getElementById(n.idPrefix + \"_$row_\" + t),\n              l = document.getElementById(n.idPrefix + \"_$row_\" + i);\n            if (o.removeChild(l), o.insertBefore(l, u), this.rowOrder[r] = i, this.rowOrder[r + 1] = t, !n.hideRowNumColumn) {\n              var a = document.getElementById(n.idPrefix + \"_$rowNum_\" + t),\n                c = document.getElementById(n.idPrefix + \"_$rowNum_\" + i),\n                s = c.innerHTML;\n              c.innerHTML = a.innerHTML, a.innerHTML = s;\n            }\n            this.saveSetting(), document.getElementById(n.idPrefix + \"_$moveDown_\" + t).blur(), document.getElementById(n.idPrefix + \"_$moveDown_\" + i).focus(), \"function\" == typeof n.afterRowSwapped && n.afterRowSwapped(this.tbWhole, r, r + 1);\n          }\n        }\n      }, {\n        key: \"setCtrlValue\",\n        value: function value(e, t, n) {\n          var o = this.settings,\n            r = o.columns[e].type,\n            i = o.columns[e].name;\n          if (\"custom\" === r) \"function\" == typeof o.columns[e].customSetter && o.columns[e].customSetter(o.idPrefix, i, t, n);else {\n            var u = this.getCellCtrl(o.idPrefix, i, t);\n            \"checkbox\" === r ? \"boolean\" == typeof n ? u.checked = n : y(n) ? u.checked = 0 !== n : u.checked = !m(n) : u.value = m(n) ? \"\" : n;\n          }\n        }\n      }, {\n        key: \"getCellCtrl\",\n        value: function value(e, t, n) {\n          return document.getElementById(e + \"_\" + t + \"_\" + n);\n        }\n      }, {\n        key: \"getCtrlValue\",\n        value: function value(e, t) {\n          var n = this.settings,\n            o = n.columns[e];\n          if (\"custom\" === o.type) {\n            if (\"function\" == typeof o.customGetter) return o.customGetter(n.idPrefix, o.name, t);\n            throw \"*customGetter* of column *\".concat(o.name, \"* is not defined.\");\n          }\n          var r = this.getCellCtrl(n.idPrefix, o.name, t);\n          return null === r ? null : \"checkbox\" === o.type ? r.checked ? 1 : 0 : r.value;\n        }\n      }, {\n        key: \"getRowValue\",\n        value: function value(e, t) {\n          var n = this,\n            o = {},\n            r = m(t) ? \"\" : \"_\" + t;\n          return n.settings.columns.forEach(function (t, i) {\n            var u = t.name + r;\n            o[u] = n.getCtrlValue(i, e);\n          }), o;\n        }\n      }, {\n        key: \"getColumnIndex\",\n        value: function value(e) {\n          for (var t = this.settings.columns, n = 0; n < t.length; n++) if (t[n].name === e) return n;\n          return null;\n        }\n      }, {\n        key: \"isRowEmpty\",\n        value: function value(e) {\n          for (var t = this.settings.columns, n = 0; n < t.length; n++) {\n            var o = t[n].emptyCriteria,\n              r = this.getCtrlValue(n, e);\n            if (\"function\" == typeof o) {\n              if (!o(r)) return !1;\n            } else {\n              var i = null;\n              if (m(o)) {\n                var u = t[n].type;\n                if (\"checkbox\" === u) i = 0;else if (\"select\" === u) {\n                  var l = this.getCellCtrl(this.settings.idPrefix, t[n].name, e).options;\n                  i = l.length > 0 ? l[0].value : \"\";\n                } else i = \"\";\n              } else i = o;\n              if (r !== i) return !1;\n            }\n          }\n          return !0;\n        }\n      }, {\n        key: \"findRowIndex\",\n        value: function value(e) {\n          for (var t = 0; t < this.rowOrder.length; t++) if (this.rowOrder[t] === e) return t;\n          return null;\n        }\n      }, {\n        key: \"saveSetting\",\n        value: function value() {\n          document.getElementById(this.settings.idPrefix + \"_rowOrder\").value = this.rowOrder.join();\n        }\n      }, {\n        key: \"showEmptyMessage\",\n        value: function value() {\n          this.tbBody.innerHTML = \"\";\n          var e = this.createElement(\"tr\", \"tbodyRow\");\n          this.tbBody.appendChild(e);\n          var t = this.createElement(\"td\", \"tbodyCell\");\n          t.setAttribute(\"colspan\", this.finalColSpan), d(t, this.uiFramework.getSectionClasses(\"empty\")), t.innerText = this.settings.i18n.rowEmpty, e.appendChild(t);\n        }\n      }, {\n        key: \"sortSequence\",\n        value: function value(e) {\n          for (var t = e || 0; t < this.rowOrder.length; t++) document.getElementById(this.settings.idPrefix + \"_$rowNum_\" + this.rowOrder[t]).innerText = \"\" + (t + 1);\n        }\n      }, {\n        key: \"rowButtonActions\",\n        value: function value(e, t) {\n          \"insert\" === e ? this.insertRow(1, null, t) : \"remove\" === e ? this.removeRow(null, t) : \"moveUp\" === e ? this.moveUpRow(null, t) : \"moveDown\" === e && this.moveDownRow(null, t);\n        }\n      }]) && Ae(t.prototype, n), o && Ae(t, o), e;\n    }();\n    function Ge(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var o = t[n];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n      }\n    }\n    var Me = new WeakMap(),\n      qe = {\n        element: null,\n        uiFramework: null,\n        uiParams: null,\n        iconFramework: null,\n        iconParams: null,\n        initRows: 3,\n        idPrefix: null,\n        initData: null,\n        columns: [],\n        i18n: null,\n        hideButtons: null,\n        hideRowNumColumn: !1,\n        rowButtonsInFront: !1,\n        rowCountName: \"_RowCount\",\n        sectionClasses: null,\n        maxRowsAllowed: 0\n      },\n      Ve = {\n        nameFormatter: null,\n        dataLoaded: null,\n        rowDataLoaded: null,\n        afterRowAppended: null,\n        afterRowInserted: null,\n        afterRowSwapped: null,\n        beforeRowRemove: null,\n        afterRowRemoved: null,\n        maxNumRowsReached: null\n      },\n      $e = {\n        type: \"text\",\n        name: null,\n        value: null,\n        display: null,\n        displayCss: null,\n        displayClass: null,\n        displayTooltip: null,\n        headerSpan: 1,\n        cellCss: null,\n        cellClass: null,\n        ctrlAttr: null,\n        ctrlProp: null,\n        ctrlCss: null,\n        ctrlClass: null,\n        ctrlOptions: null,\n        invisible: !1,\n        emptyCriteria: null,\n        customBuilder: null,\n        customGetter: null,\n        customSetter: null,\n        events: null,\n        ctrlAdded: null\n      },\n      We = function () {\n        function e(t) {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, e);\n          var n = Object.assign({}, qe, Ve, t),\n            o = {\n              append: \"Append Row\",\n              removeLast: \"Remove Last Row\",\n              insert: \"Insert Row Above\",\n              remove: \"Remove Current Row\",\n              moveUp: \"Move Up\",\n              moveDown: \"Move Down\",\n              rowEmpty: \"This Grid Is Empty\"\n            };\n          n.i18n && Object.assign(o, n.i18n), n.i18n = o;\n          var r = {\n            append: !1,\n            removeLast: !1,\n            insert: !1,\n            remove: !1,\n            moveUp: !1,\n            moveDown: !1\n          };\n          n.hideButtons && Object.assign(r, n.hideButtons), n.hideButtons = r;\n          for (var i = 0; i < n.columns.length; i++) {\n            var u = Object.assign({}, $e, n.columns[i]);\n            n.columns[i] = u;\n          }\n          var l = new Ne(n);\n          Me.set(this, l), Array.isArray(n.initData) ? l.loadData(n.initData, !0) : n.initRows > 0 && l.insertRow(n.initRows);\n        }\n        var t, n, o;\n        return t = e, (n = [{\n          key: \"appendRow\",\n          value: function value(e) {\n            return Me.get(this).insertRow(e || 1).addedRows;\n          }\n        }, {\n          key: \"insertRow\",\n          value: function value(e, t) {\n            return Me.get(this).insertRow(e, t).addedRows;\n          }\n        }, {\n          key: \"removeRow\",\n          value: function value(e) {\n            Me.get(this).removeRow(e);\n          }\n        }, {\n          key: \"moveUpRow\",\n          value: function value(e) {\n            Me.get(this).moveUpRow(e);\n          }\n        }, {\n          key: \"moveDownRow\",\n          value: function value(e) {\n            Me.get(this).moveDownRow(e);\n          }\n        }, {\n          key: \"load\",\n          value: function value(e) {\n            Me.get(this).loadData(e);\n          }\n        }, {\n          key: \"getAllValue\",\n          value: function value(e) {\n            var t = Me.get(this),\n              n = e ? {} : [];\n            return t.rowOrder.forEach(function (o, r) {\n              e ? Object.assign(n, t.getRowValue(o, r)) : n.push(t.getRowValue(o));\n            }), e && (n[t.settings.rowCountName] = t.rowOrder.length), n;\n          }\n        }, {\n          key: \"getUniqueIndex\",\n          value: function value(e) {\n            var t = Me.get(this).rowOrder;\n            return e >= 0 && e < t.length ? t[e] : null;\n          }\n        }, {\n          key: \"getRowIndex\",\n          value: function value(e) {\n            for (var t = Me.get(this).rowOrder, n = 0; n < t.length; n++) if (t[n] === e) return n;\n            return null;\n          }\n        }, {\n          key: \"getRowCount\",\n          value: function value() {\n            return Me.get(this).rowOrder.length;\n          }\n        }, {\n          key: \"getRowOrder\",\n          value: function value() {\n            return Me.get(this).rowOrder.slice();\n          }\n        }, {\n          key: \"getRowValue\",\n          value: function value(e) {\n            var t = this.getUniqueIndex(e);\n            return null !== t ? Me.get(this).getRowValue(t) : null;\n          }\n        }, {\n          key: \"getCtrlValue\",\n          value: function value(e, t) {\n            var n = Me.get(this).getColumnIndex(e),\n              o = this.getUniqueIndex(t);\n            return null !== n && null !== o ? Me.get(this).getCtrlValue(n, o) : null;\n          }\n        }, {\n          key: \"setCtrlValue\",\n          value: function value(e, t, n) {\n            var o = Me.get(this).getColumnIndex(e),\n              r = this.getUniqueIndex(t);\n            if (null !== o && null !== r) return Me.get(this).setCtrlValue(o, r, n);\n          }\n        }, {\n          key: \"getColumns\",\n          value: function value() {\n            return Me.get(this).settings.columns.slice();\n          }\n        }, {\n          key: \"getCellCtrl\",\n          value: function value(e, t) {\n            var n = this.getUniqueIndex(t);\n            return this.getCellCtrlByUniqueIndex(e, n);\n          }\n        }, {\n          key: \"getCellCtrlByUniqueIndex\",\n          value: function value(e, t) {\n            var n = Me.get(this);\n            return null !== n.getColumnIndex(e) && y(t) ? n.getCellCtrl(n.settings.idPrefix, e, t) : null;\n          }\n        }, {\n          key: \"isRowEmpty\",\n          value: function value(e) {\n            var t = this.getUniqueIndex(e);\n            return null === t || Me.get(this).isRowEmpty(t);\n          }\n        }, {\n          key: \"removeEmptyRows\",\n          value: function value() {\n            for (var e = Me.get(this), t = this.getRowOrder(), n = 0; n < t.length; n++) e.isRowEmpty(t[n]) && e.removeRow(null, t[n], !0);\n          }\n        }]) && Ge(t.prototype, n), o && Ge(t, o), e;\n      }();\n    t[\"default\"] = We;\n  }])[\"default\"];\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvc2NyaXB0cy9tb2R1bGVzL3RhYmxlLWlucHV0LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW5wcmlzZS1mcm9udGVuZC10b29sLy4vYXNzZXRzL3NjcmlwdHMvbW9kdWxlcy90YWJsZS1pbnB1dC5qcz82NzNiIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cbiFmdW5jdGlvbiAoZSwgdCkge1xuICBcIm9iamVjdFwiID09ICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGV4cG9ydHMpKSAmJiBcIm9iamVjdFwiID09ICh0eXBlb2YgbW9kdWxlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YobW9kdWxlKSkgPyBtb2R1bGUuZXhwb3J0cyA9IHQoKSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoW10sIHQpIDogXCJvYmplY3RcIiA9PSAodHlwZW9mIGV4cG9ydHMgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihleHBvcnRzKSkgPyBleHBvcnRzLkFwcGVuZEdyaWQgPSB0KCkgOiBlLkFwcGVuZEdyaWQgPSB0KCk7XG59KHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZ1bmN0aW9uIG4obykge1xuICAgICAgaWYgKHRbb10pIHJldHVybiB0W29dLmV4cG9ydHM7XG4gICAgICB2YXIgciA9IHRbb10gPSB7XG4gICAgICAgIGk6IG8sXG4gICAgICAgIGw6ICExLFxuICAgICAgICBleHBvcnRzOiB7fVxuICAgICAgfTtcbiAgICAgIHJldHVybiBlW29dLmNhbGwoci5leHBvcnRzLCByLCByLmV4cG9ydHMsIG4pLCByLmwgPSAhMCwgci5leHBvcnRzO1xuICAgIH1cbiAgICByZXR1cm4gbi5tID0gZSwgbi5jID0gdCwgbi5kID0gZnVuY3Rpb24gKGUsIHQsIG8pIHtcbiAgICAgIG4ubyhlLCB0KSB8fCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdCwge1xuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgZ2V0OiBvXG4gICAgICB9KTtcbiAgICB9LCBuLnIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIFN5bWJvbC50b1N0cmluZ1RhZyAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgIHZhbHVlOiBcIk1vZHVsZVwiXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgIHZhbHVlOiAhMFxuICAgICAgfSk7XG4gICAgfSwgbi50ID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgIGlmICgxICYgdCAmJiAoZSA9IG4oZSkpLCA4ICYgdCkgcmV0dXJuIGU7XG4gICAgICBpZiAoNCAmIHQgJiYgXCJvYmplY3RcIiA9PSBfdHlwZW9mKGUpICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgICAgIHZhciBvID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIGlmIChuLnIobyksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGVcbiAgICAgIH0pLCAyICYgdCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBlKSBmb3IgKHZhciByIGluIGUpIG4uZChvLCByLCBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gZVt0XTtcbiAgICAgIH0uYmluZChudWxsLCByKSk7XG4gICAgICByZXR1cm4gbztcbiAgICB9LCBuLm4gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHQgPSBlICYmIGUuX19lc01vZHVsZSA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVbXCJkZWZhdWx0XCJdO1xuICAgICAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIG4uZCh0LCBcImFcIiwgdCksIHQ7XG4gICAgfSwgbi5vID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgdCk7XG4gICAgfSwgbi5wID0gXCIvXCIsIG4obi5zID0gMCk7XG4gIH0oW2Z1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiBvKGUsIHQpIHtcbiAgICAgIGlmICghKGUgaW5zdGFuY2VvZiB0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcihlLCB0KSB7XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgdmFyIG8gPSB0W25dO1xuICAgICAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgby5rZXksIG8pO1xuICAgICAgfVxuICAgIH1cbiAgICBuLnIodCk7XG4gICAgdmFyIGkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBlKHQpIHtcbiAgICAgICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSAmJiBhcmd1bWVudHNbMV07XG4gICAgICAgIG8odGhpcywgZSksIHRoaXMubmFtZSA9IHQsIHRoaXMuaWNvbnMgPSB7XG4gICAgICAgICAgYXBwZW5kOiBudWxsLFxuICAgICAgICAgIHJlbW92ZUxhc3Q6IG51bGwsXG4gICAgICAgICAgaW5zZXJ0OiBudWxsLFxuICAgICAgICAgIHJlbW92ZTogbnVsbCxcbiAgICAgICAgICBtb3ZlVXA6IG51bGwsXG4gICAgICAgICAgbW92ZURvd246IG51bGxcbiAgICAgICAgfSwgdGhpcy5pc1RleHRCYXNlZCA9IG47XG4gICAgICB9XG4gICAgICB2YXIgdCwgbiwgaTtcbiAgICAgIHJldHVybiB0ID0gZSwgKG4gPSBbe1xuICAgICAgICBrZXk6IFwiZ2VuZXJhdGVJY29uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlLCB0KSB7XG4gICAgICAgICAgdGhyb3cgXCIqZ2VuZXJhdGVJY29uKiBpcyBub3Qgb3ZlcnJpZGVkIGZvciAqXCIuY29uY2F0KHRoaXMubmFtZSwgXCIqLlwiKTtcbiAgICAgICAgfVxuICAgICAgfV0pICYmIHIodC5wcm90b3R5cGUsIG4pLCBpICYmIHIodCwgaSksIGU7XG4gICAgfSgpO1xuICAgIGZ1bmN0aW9uIHUoZSkge1xuICAgICAgcmV0dXJuICh1ID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSBfdHlwZW9mKFN5bWJvbC5pdGVyYXRvcikgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gX3R5cGVvZihlKTtcbiAgICAgIH0gOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBlLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgZSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBfdHlwZW9mKGUpO1xuICAgICAgfSkoZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGwoZSwgdCkge1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgICAgIHZhciBvID0gdFtuXTtcbiAgICAgICAgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIG8ua2V5LCBvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYShlLCB0KSB7XG4gICAgICByZXR1cm4gKGEgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgcmV0dXJuIGUuX19wcm90b19fID0gdCwgZTtcbiAgICAgIH0pKGUsIHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjKGUpIHtcbiAgICAgIHZhciB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgUmVmbGVjdCB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiAhMTtcbiAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiAhMTtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgUHJveHkpIHJldHVybiAhMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKSwgITA7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH1cbiAgICAgIH0oKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuLFxuICAgICAgICAgIG8gPSBmKGUpO1xuICAgICAgICBpZiAodCkge1xuICAgICAgICAgIHZhciByID0gZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICBuID0gUmVmbGVjdC5jb25zdHJ1Y3QobywgYXJndW1lbnRzLCByKTtcbiAgICAgICAgfSBlbHNlIG4gPSBvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBzKHRoaXMsIG4pO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcyhlLCB0KSB7XG4gICAgICByZXR1cm4gIXQgfHwgXCJvYmplY3RcIiAhPT0gdSh0KSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfShlKSA6IHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGYoZSkge1xuICAgICAgcmV0dXJuIChmID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihlKTtcbiAgICAgIH0pKGUpO1xuICAgIH1cbiAgICB2YXIgcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAhZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCAmJiBudWxsICE9PSB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlLCB7XG4gICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBlLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgIH1cbiAgICAgICAgfSksIHQgJiYgYShlLCB0KTtcbiAgICAgIH0oaSwgZSk7XG4gICAgICB2YXIgdCxcbiAgICAgICAgbixcbiAgICAgICAgbyxcbiAgICAgICAgciA9IGMoaSk7XG4gICAgICBmdW5jdGlvbiBpKGUpIHtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiB0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSh0aGlzLCBpKSwgdCA9IHIuY2FsbCh0aGlzLCBcImljb24tZGVmYXVsdFwiLCAhMCksIE9iamVjdC5hc3NpZ24odC5pY29ucywge1xuICAgICAgICAgIGFwcGVuZDogXCLvvItcIixcbiAgICAgICAgICByZW1vdmVMYXN0OiBcIu+8jVwiLFxuICAgICAgICAgIGluc2VydDogXCLihpxcIixcbiAgICAgICAgICByZW1vdmU6IFwi4pyVXCIsXG4gICAgICAgICAgbW92ZVVwOiBcIuKWslwiLFxuICAgICAgICAgIG1vdmVEb3duOiBcIuKWvFwiXG4gICAgICAgIH0pLCBlICYmIE9iamVjdC5hc3NpZ24odC5pY29ucywgZSksIHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdCA9IGksIChuID0gW3tcbiAgICAgICAga2V5OiBcImdlbmVyYXRlSWNvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSwgdCkge1xuICAgICAgICAgIHZhciBuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5pY29uc1t0XSB8fCBcIlwiKTtcbiAgICAgICAgICByZXR1cm4gZS5hcHBlbmRDaGlsZChuKSwgbjtcbiAgICAgICAgfVxuICAgICAgfV0pICYmIGwodC5wcm90b3R5cGUsIG4pLCBvICYmIGwodCwgbyksIGk7XG4gICAgfShpKTtcbiAgICBmdW5jdGlvbiBkKGUpIHtcbiAgICAgIGZvciAodmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoLCBuID0gbmV3IEFycmF5KHQgPiAxID8gdCAtIDEgOiAwKSwgbyA9IDE7IG8gPCB0OyBvKyspIG5bbyAtIDFdID0gYXJndW1lbnRzW29dO1xuICAgICAgbiAmJiBuLmxlbmd0aCAmJiBuLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICB2YXIgbiA9IHQuc3BsaXQoL1xccysvZ2kpO1xuICAgICAgICAgIG4gJiYgbi5sZW5ndGggJiYgbi5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB0ICYmIGUuY2xhc3NMaXN0LmFkZCh0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG0oZSkge1xuICAgICAgcmV0dXJuIG51bGwgPT0gZTtcbiAgICB9XG4gICAgZnVuY3Rpb24geShlKSB7XG4gICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQoZSkpICYmIGlzRmluaXRlKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoKGUpIHtcbiAgICAgIHJldHVybiBcIltvYmplY3QgT2JqZWN0XVwiID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHYoZSkge1xuICAgICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IG51bGwsXG4gICAgICAgIG4gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IG51bGwsXG4gICAgICAgIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1szXSA/IGFyZ3VtZW50c1szXSA6IG51bGwsXG4gICAgICAgIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1s0XSA/IGFyZ3VtZW50c1s0XSA6IG51bGwsXG4gICAgICAgIGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGUpO1xuICAgICAgcmV0dXJuIHQgJiYgKGkuaWQgPSB0KSwgbiAmJiAoaS5uYW1lID0gbiksIG8gJiYgZChpLCBvKSwgciAmJiAoaS50eXBlID0gciksIGk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGIoZSkge1xuICAgICAgcmV0dXJuIChiID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSBfdHlwZW9mKFN5bWJvbC5pdGVyYXRvcikgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gX3R5cGVvZihlKTtcbiAgICAgIH0gOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBlLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgZSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBfdHlwZW9mKGUpO1xuICAgICAgfSkoZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHcoZSwgdCkge1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgICAgIHZhciBvID0gdFtuXTtcbiAgICAgICAgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIG8ua2V5LCBvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZyhlLCB0KSB7XG4gICAgICByZXR1cm4gKGcgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgcmV0dXJuIGUuX19wcm90b19fID0gdCwgZTtcbiAgICAgIH0pKGUsIHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPKGUpIHtcbiAgICAgIHZhciB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgUmVmbGVjdCB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiAhMTtcbiAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiAhMTtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgUHJveHkpIHJldHVybiAhMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKSwgITA7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH1cbiAgICAgIH0oKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuLFxuICAgICAgICAgIG8gPSBSKGUpO1xuICAgICAgICBpZiAodCkge1xuICAgICAgICAgIHZhciByID0gUih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICBuID0gUmVmbGVjdC5jb25zdHJ1Y3QobywgYXJndW1lbnRzLCByKTtcbiAgICAgICAgfSBlbHNlIG4gPSBvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBDKHRoaXMsIG4pO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQyhlLCB0KSB7XG4gICAgICByZXR1cm4gIXQgfHwgXCJvYmplY3RcIiAhPT0gYih0KSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfShlKSA6IHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFIoZSkge1xuICAgICAgcmV0dXJuIChSID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihlKTtcbiAgICAgIH0pKGUpO1xuICAgIH1cbiAgICB2YXIgayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAhZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCAmJiBudWxsICE9PSB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlLCB7XG4gICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBlLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgIH1cbiAgICAgICAgfSksIHQgJiYgZyhlLCB0KTtcbiAgICAgIH0oaSwgZSk7XG4gICAgICB2YXIgdCxcbiAgICAgICAgbixcbiAgICAgICAgbyxcbiAgICAgICAgciA9IE8oaSk7XG4gICAgICBmdW5jdGlvbiBpKGUpIHtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgICFmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiB0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSh0aGlzLCBpKSwgdCA9IHIuY2FsbCh0aGlzLCBcImljb24tYm9vdHN0cmFwaWNvbnNcIik7XG4gICAgICAgIHZhciBuID0ge1xuICAgICAgICAgIGJhc2VVcmw6IFwiXCIsXG4gICAgICAgICAgaWNvbnM6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihuLCBlKTtcbiAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgYXBwZW5kOiBcInBsdXNcIixcbiAgICAgICAgICByZW1vdmVMYXN0OiBcImRhc2hcIixcbiAgICAgICAgICBpbnNlcnQ6IFwiYXJyb3ctOTBkZWctbGVmdFwiLFxuICAgICAgICAgIHJlbW92ZTogXCJ0cmFzaFwiLFxuICAgICAgICAgIG1vdmVVcDogXCJjaGV2cm9uLXVwXCIsXG4gICAgICAgICAgbW92ZURvd246IFwiY2hldnJvbi1kb3duXCJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG4uaWNvbnMgJiYgT2JqZWN0LmFzc2lnbihvLCBuLmljb25zKSwgdC5pY29ucyA9IG8sIHQuYmFzZVVybCA9IG4uYmFzZVVybCwgdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ID0gaSwgKG4gPSBbe1xuICAgICAgICBrZXk6IFwiZ2VuZXJhdGVJY29uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlLCB0KSB7XG4gICAgICAgICAgdmFyIG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICAgIHJldHVybiBuLnNyYyA9IHRoaXMuYmFzZVVybCArIHRoaXMuaWNvbnNbdF0gKyBcIi5zdmdcIiwgZChuLCB0aGlzLmljb25zW3RdKSwgZS5hcHBlbmRDaGlsZChuKSwgbjtcbiAgICAgICAgfVxuICAgICAgfV0pICYmIHcodC5wcm90b3R5cGUsIG4pLCBvICYmIHcodCwgbyksIGk7XG4gICAgfShpKTtcbiAgICBmdW5jdGlvbiBQKGUpIHtcbiAgICAgIHJldHVybiAoUCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gX3R5cGVvZihTeW1ib2wuaXRlcmF0b3IpID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIF90eXBlb2YoZSk7XG4gICAgICB9IDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgZS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGUgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogX3R5cGVvZihlKTtcbiAgICAgIH0pKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfKGUsIHQpIHtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgbyA9IHRbbl07XG4gICAgICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBvLmtleSwgbyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFMoZSwgdCkge1xuICAgICAgcmV0dXJuIChTID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHJldHVybiBlLl9fcHJvdG9fXyA9IHQsIGU7XG4gICAgICB9KShlLCB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaihlKSB7XG4gICAgICB2YXIgdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFJlZmxlY3QgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gITE7XG4gICAgICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gITE7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFByb3h5KSByZXR1cm4gITA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSksICEwO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICB9KCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbixcbiAgICAgICAgICBvID0gRShlKTtcbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICB2YXIgciA9IEUodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgbiA9IFJlZmxlY3QuY29uc3RydWN0KG8sIGFyZ3VtZW50cywgcik7XG4gICAgICAgIH0gZWxzZSBuID0gby5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4geCh0aGlzLCBuKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHgoZSwgdCkge1xuICAgICAgcmV0dXJuICF0IHx8IFwib2JqZWN0XCIgIT09IFAodCkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0ID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0oZSkgOiB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBFKGUpIHtcbiAgICAgIHJldHVybiAoRSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSk7XG4gICAgICB9KShlKTtcbiAgICB9XG4gICAgdmFyIEIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgIWZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgJiYgbnVsbCAhPT0gdCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSwge1xuICAgICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCB0ICYmIFMoZSwgdCk7XG4gICAgICB9KGksIGUpO1xuICAgICAgdmFyIHQsXG4gICAgICAgIG4sXG4gICAgICAgIG8sXG4gICAgICAgIHIgPSBqKGkpO1xuICAgICAgZnVuY3Rpb24gaShlKSB7XG4gICAgICAgIHZhciB0O1xuICAgICAgICAhZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH0odGhpcywgaSksIHQgPSByLmNhbGwodGhpcywgXCJpY29uLWZvbnRhd2Vzb21lNVwiKTtcbiAgICAgICAgdmFyIG4gPSB7XG4gICAgICAgICAgaWNvbnM6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihuLCBlKTtcbiAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgYXBwZW5kOiBcImZhcyBmYS1wbHVzXCIsXG4gICAgICAgICAgcmVtb3ZlTGFzdDogXCJmYXMgZmEtbWludXNcIixcbiAgICAgICAgICBpbnNlcnQ6IFwiZmFzIGZhLXJlcGx5XCIsXG4gICAgICAgICAgcmVtb3ZlOiBcImZhcyBmYS10aW1lc1wiLFxuICAgICAgICAgIG1vdmVVcDogXCJmYXMgZmEtYW5nbGUtdXBcIixcbiAgICAgICAgICBtb3ZlRG93bjogXCJmYXMgZmEtYW5nbGUtZG93blwiXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuLmljb25zICYmIE9iamVjdC5hc3NpZ24obywgbi5pY29ucyksIHQuaWNvbnMgPSBvLCB0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQgPSBpLCAobiA9IFt7XG4gICAgICAgIGtleTogXCJnZW5lcmF0ZUljb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUsIHQpIHtcbiAgICAgICAgICB2YXIgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpXCIpO1xuICAgICAgICAgIHJldHVybiBkKG4sIHRoaXMuaWNvbnNbdF0pLCBlLmFwcGVuZENoaWxkKG4pLCBuO1xuICAgICAgICB9XG4gICAgICB9XSkgJiYgXyh0LnByb3RvdHlwZSwgbiksIG8gJiYgXyh0LCBvKSwgaTtcbiAgICB9KGkpO1xuICAgIGZ1bmN0aW9uIEkoZSkge1xuICAgICAgcmV0dXJuIChJID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSBfdHlwZW9mKFN5bWJvbC5pdGVyYXRvcikgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gX3R5cGVvZihlKTtcbiAgICAgIH0gOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBlLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgZSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBfdHlwZW9mKGUpO1xuICAgICAgfSkoZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEQoZSwgdCkge1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgICAgIHZhciBvID0gdFtuXTtcbiAgICAgICAgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIG8ua2V5LCBvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gRihlLCB0KSB7XG4gICAgICByZXR1cm4gKEYgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgcmV0dXJuIGUuX19wcm90b19fID0gdCwgZTtcbiAgICAgIH0pKGUsIHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUKGUpIHtcbiAgICAgIHZhciB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgUmVmbGVjdCB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiAhMTtcbiAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiAhMTtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgUHJveHkpIHJldHVybiAhMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKSwgITA7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH1cbiAgICAgIH0oKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuLFxuICAgICAgICAgIG8gPSBVKGUpO1xuICAgICAgICBpZiAodCkge1xuICAgICAgICAgIHZhciByID0gVSh0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICBuID0gUmVmbGVjdC5jb25zdHJ1Y3QobywgYXJndW1lbnRzLCByKTtcbiAgICAgICAgfSBlbHNlIG4gPSBvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBMKHRoaXMsIG4pO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTChlLCB0KSB7XG4gICAgICByZXR1cm4gIXQgfHwgXCJvYmplY3RcIiAhPT0gSSh0KSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfShlKSA6IHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFUoZSkge1xuICAgICAgcmV0dXJuIChVID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihlKTtcbiAgICAgIH0pKGUpO1xuICAgIH1cbiAgICB2YXIgQSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAhZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCAmJiBudWxsICE9PSB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlLCB7XG4gICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBlLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgIH1cbiAgICAgICAgfSksIHQgJiYgRihlLCB0KTtcbiAgICAgIH0oaSwgZSk7XG4gICAgICB2YXIgdCxcbiAgICAgICAgbixcbiAgICAgICAgbyxcbiAgICAgICAgciA9IFQoaSk7XG4gICAgICBmdW5jdGlvbiBpKGUpIHtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgICFmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiB0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSh0aGlzLCBpKSwgdCA9IHIuY2FsbCh0aGlzLCBcImljb24tbWF0ZXJpYWxkZXNpZ25pY29uczNcIik7XG4gICAgICAgIHZhciBuID0ge1xuICAgICAgICAgIGljb25zOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24obiwgZSk7XG4gICAgICAgIHZhciBvID0ge1xuICAgICAgICAgIGFwcGVuZDogXCJtZGkgbWRpLXBsdXNcIixcbiAgICAgICAgICByZW1vdmVMYXN0OiBcIm1kaSBtZGktbWludXNcIixcbiAgICAgICAgICBpbnNlcnQ6IFwibWRpIG1kaS1yZXBseVwiLFxuICAgICAgICAgIHJlbW92ZTogXCJtZGkgbWRpLWNsb3NlXCIsXG4gICAgICAgICAgbW92ZVVwOiBcIm1kaSBtZGktY2hldnJvbi11cFwiLFxuICAgICAgICAgIG1vdmVEb3duOiBcIm1kaSBtZGktY2hldnJvbi1kb3duXCJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG4uaWNvbnMgJiYgT2JqZWN0LmFzc2lnbihvLCBuLmljb25zKSwgdC5pY29ucyA9IG8sIHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdCA9IGksIChuID0gW3tcbiAgICAgICAga2V5OiBcImdlbmVyYXRlSWNvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSwgdCkge1xuICAgICAgICAgIHZhciBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgcmV0dXJuIGQobiwgdGhpcy5pY29uc1t0XSksIGUuYXBwZW5kQ2hpbGQobiksIG47XG4gICAgICAgIH1cbiAgICAgIH1dKSAmJiBEKHQucHJvdG90eXBlLCBuKSwgbyAmJiBEKHQsIG8pLCBpO1xuICAgIH0oaSk7XG4gICAgZnVuY3Rpb24gTihlKSB7XG4gICAgICByZXR1cm4gKE4gPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IF90eXBlb2YoU3ltYm9sLml0ZXJhdG9yKSA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBfdHlwZW9mKGUpO1xuICAgICAgfSA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIGUuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBlICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IF90eXBlb2YoZSk7XG4gICAgICB9KShlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRyhlLCB0KSB7XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgdmFyIG8gPSB0W25dO1xuICAgICAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgby5rZXksIG8pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBNKGUsIHQpIHtcbiAgICAgIHJldHVybiAoTSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICByZXR1cm4gZS5fX3Byb3RvX18gPSB0LCBlO1xuICAgICAgfSkoZSwgdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHEoZSkge1xuICAgICAgdmFyIHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChcInVuZGVmaW5lZFwiID09IHR5cGVvZiBSZWZsZWN0IHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuICExO1xuICAgICAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuICExO1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBQcm94eSkgcmV0dXJuICEwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpLCAhMDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG4sXG4gICAgICAgICAgbyA9ICQoZSk7XG4gICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgdmFyIHIgPSAkKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgIG4gPSBSZWZsZWN0LmNvbnN0cnVjdChvLCBhcmd1bWVudHMsIHIpO1xuICAgICAgICB9IGVsc2UgbiA9IG8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIFYodGhpcywgbik7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBWKGUsIHQpIHtcbiAgICAgIHJldHVybiAhdCB8fCBcIm9iamVjdFwiICE9PSBOKHQpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9KGUpIDogdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gJChlKSB7XG4gICAgICByZXR1cm4gKCQgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpO1xuICAgICAgfSkoZSk7XG4gICAgfVxuICAgIHZhciBXID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICFmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0ICYmIG51bGwgIT09IHQpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUsIHtcbiAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IGUsXG4gICAgICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgICAgfVxuICAgICAgICB9KSwgdCAmJiBNKGUsIHQpO1xuICAgICAgfShpLCBlKTtcbiAgICAgIHZhciB0LFxuICAgICAgICBuLFxuICAgICAgICBvLFxuICAgICAgICByID0gcShpKTtcbiAgICAgIGZ1bmN0aW9uIGkoZSkge1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgIWZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9KHRoaXMsIGkpLCB0ID0gci5jYWxsKHRoaXMsIFwiaWNvbi1pb25pY29uNFwiKTtcbiAgICAgICAgdmFyIG4gPSB7XG4gICAgICAgICAgaWNvbnM6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihuLCBlKTtcbiAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgYXBwZW5kOiBcImljb24gaW9uLW1kLWFkZFwiLFxuICAgICAgICAgIHJlbW92ZUxhc3Q6IFwiaWNvbiBpb24tbWQtcmVtb3ZlXCIsXG4gICAgICAgICAgaW5zZXJ0OiBcImljb24gaW9uLW1kLXVuZG9cIixcbiAgICAgICAgICByZW1vdmU6IFwiaWNvbiBpb24tbWQtY2xvc2VcIixcbiAgICAgICAgICBtb3ZlVXA6IFwiaWNvbiBpb24tbWQtYXJyb3ctZHJvcHVwXCIsXG4gICAgICAgICAgbW92ZURvd246IFwiaWNvbiBpb24tbWQtYXJyb3ctZHJvcGRvd25cIlxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbi5pY29ucyAmJiBPYmplY3QuYXNzaWduKG8sIG4uaWNvbnMpLCB0Lmljb25zID0gbywgdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ID0gaSwgKG4gPSBbe1xuICAgICAgICBrZXk6IFwiZ2VuZXJhdGVJY29uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlLCB0KSB7XG4gICAgICAgICAgdmFyIG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcbiAgICAgICAgICByZXR1cm4gZChuLCB0aGlzLmljb25zW3RdKSwgZS5hcHBlbmRDaGlsZChuKSwgbjtcbiAgICAgICAgfVxuICAgICAgfV0pICYmIEcodC5wcm90b3R5cGUsIG4pLCBvICYmIEcodCwgbyksIGk7XG4gICAgfShpKTtcbiAgICBmdW5jdGlvbiBIKGUpIHtcbiAgICAgIHJldHVybiAoSCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gX3R5cGVvZihTeW1ib2wuaXRlcmF0b3IpID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIF90eXBlb2YoZSk7XG4gICAgICB9IDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgZS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGUgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogX3R5cGVvZihlKTtcbiAgICAgIH0pKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB6KGUsIHQpIHtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgbyA9IHRbbl07XG4gICAgICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBvLmtleSwgbyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEooZSwgdCkge1xuICAgICAgcmV0dXJuIChKID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHJldHVybiBlLl9fcHJvdG9fXyA9IHQsIGU7XG4gICAgICB9KShlLCB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSyhlKSB7XG4gICAgICB2YXIgdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFJlZmxlY3QgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gITE7XG4gICAgICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gITE7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFByb3h5KSByZXR1cm4gITA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSksICEwO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICB9KCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbixcbiAgICAgICAgICBvID0gWChlKTtcbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICB2YXIgciA9IFgodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgbiA9IFJlZmxlY3QuY29uc3RydWN0KG8sIGFyZ3VtZW50cywgcik7XG4gICAgICAgIH0gZWxzZSBuID0gby5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gUSh0aGlzLCBuKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIFEoZSwgdCkge1xuICAgICAgcmV0dXJuICF0IHx8IFwib2JqZWN0XCIgIT09IEgodCkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0ID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0oZSkgOiB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBYKGUpIHtcbiAgICAgIHJldHVybiAoWCA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSk7XG4gICAgICB9KShlKTtcbiAgICB9XG4gICAgdmFyIFkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgIWZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgJiYgbnVsbCAhPT0gdCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSwge1xuICAgICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCB0ICYmIEooZSwgdCk7XG4gICAgICB9KGksIGUpO1xuICAgICAgdmFyIHQsXG4gICAgICAgIG4sXG4gICAgICAgIG8sXG4gICAgICAgIHIgPSBLKGkpO1xuICAgICAgZnVuY3Rpb24gaShlKSB7XG4gICAgICAgIHZhciB0O1xuICAgICAgICAhZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH0odGhpcywgaSksIHQgPSByLmNhbGwodGhpcywgXCJpY29uLXR5cGljb25zMlwiKTtcbiAgICAgICAgdmFyIG4gPSB7XG4gICAgICAgICAgaWNvbnM6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihuLCBlKTtcbiAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgYXBwZW5kOiBcInR5cGNuIHR5cGNuLXBsdXNcIixcbiAgICAgICAgICByZW1vdmVMYXN0OiBcInR5cGNuIHR5cGNuLW1pbnVzXCIsXG4gICAgICAgICAgaW5zZXJ0OiBcInR5cGNuIHR5cGNuLWFycm93LWJhY2tcIixcbiAgICAgICAgICByZW1vdmU6IFwidHlwY24gdHlwY24tdGltZXNcIixcbiAgICAgICAgICBtb3ZlVXA6IFwidHlwY24gdHlwY24tYXJyb3ctc29ydGVkLXVwXCIsXG4gICAgICAgICAgbW92ZURvd246IFwidHlwY24gdHlwY24tYXJyb3ctc29ydGVkLWRvd25cIlxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbi5pY29ucyAmJiBPYmplY3QuYXNzaWduKG8sIG4uaWNvbnMpLCB0Lmljb25zID0gbywgdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ID0gaSwgKG4gPSBbe1xuICAgICAgICBrZXk6IFwiZ2VuZXJhdGVJY29uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlLCB0KSB7XG4gICAgICAgICAgdmFyIG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICByZXR1cm4gZChuLCB0aGlzLmljb25zW3RdKSwgZS5hcHBlbmRDaGlsZChuKSwgbjtcbiAgICAgICAgfVxuICAgICAgfV0pICYmIHoodC5wcm90b3R5cGUsIG4pLCBvICYmIHoodCwgbyksIGk7XG4gICAgfShpKTtcbiAgICBmdW5jdGlvbiBaKGUpIHtcbiAgICAgIHJldHVybiAoWiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gX3R5cGVvZihTeW1ib2wuaXRlcmF0b3IpID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIF90eXBlb2YoZSk7XG4gICAgICB9IDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgZS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGUgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogX3R5cGVvZihlKTtcbiAgICAgIH0pKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlZShlLCB0KSB7XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgdmFyIG8gPSB0W25dO1xuICAgICAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgby5rZXksIG8pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0ZShlLCB0KSB7XG4gICAgICByZXR1cm4gKHRlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHJldHVybiBlLl9fcHJvdG9fXyA9IHQsIGU7XG4gICAgICB9KShlLCB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbmUoZSkge1xuICAgICAgdmFyIHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChcInVuZGVmaW5lZFwiID09IHR5cGVvZiBSZWZsZWN0IHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuICExO1xuICAgICAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuICExO1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBQcm94eSkgcmV0dXJuICEwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpLCAhMDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG4sXG4gICAgICAgICAgbyA9IHJlKGUpO1xuICAgICAgICBpZiAodCkge1xuICAgICAgICAgIHZhciByID0gcmUodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgbiA9IFJlZmxlY3QuY29uc3RydWN0KG8sIGFyZ3VtZW50cywgcik7XG4gICAgICAgIH0gZWxzZSBuID0gby5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gb2UodGhpcywgbik7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBvZShlLCB0KSB7XG4gICAgICByZXR1cm4gIXQgfHwgXCJvYmplY3RcIiAhPT0gWih0KSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfShlKSA6IHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlKGUpIHtcbiAgICAgIHJldHVybiAocmUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpO1xuICAgICAgfSkoZSk7XG4gICAgfVxuICAgIHZhciBpZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAhZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCAmJiBudWxsICE9PSB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlLCB7XG4gICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBlLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgIH1cbiAgICAgICAgfSksIHQgJiYgdGUoZSwgdCk7XG4gICAgICB9KGksIGUpO1xuICAgICAgdmFyIHQsXG4gICAgICAgIG4sXG4gICAgICAgIG8sXG4gICAgICAgIHIgPSBuZShpKTtcbiAgICAgIGZ1bmN0aW9uIGkoZSkge1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgIWZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9KHRoaXMsIGkpLCB0ID0gci5jYWxsKHRoaXMsIFwiaWNvbi1vcGVuaWNvbmljXCIpO1xuICAgICAgICB2YXIgbiA9IHtcbiAgICAgICAgICBpY29uczogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKG4sIGUpO1xuICAgICAgICB2YXIgbyA9IHtcbiAgICAgICAgICBhcHBlbmQ6IFwicGx1c1wiLFxuICAgICAgICAgIHJlbW92ZUxhc3Q6IFwibWludXNcIixcbiAgICAgICAgICBpbnNlcnQ6IFwic2hhcmVcIixcbiAgICAgICAgICByZW1vdmU6IFwieFwiLFxuICAgICAgICAgIG1vdmVVcDogXCJjaGV2cm9uLXRvcFwiLFxuICAgICAgICAgIG1vdmVEb3duOiBcImNoZXZyb24tYm90dG9tXCJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG4uaWNvbnMgJiYgT2JqZWN0LmFzc2lnbihvLCBuLmljb25zKSwgdC5pY29ucyA9IG8sIHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdCA9IGksIChuID0gW3tcbiAgICAgICAga2V5OiBcImdlbmVyYXRlSWNvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSwgdCkge1xuICAgICAgICAgIHZhciBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgcmV0dXJuIG4uY2xhc3NOYW1lID0gXCJvaVwiLCBuLmRhdGFzZXQuZ2x5cGggPSB0aGlzLmljb25zW3RdLCBuLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKSwgZS5hcHBlbmRDaGlsZChuKSwgbjtcbiAgICAgICAgfVxuICAgICAgfV0pICYmIGVlKHQucHJvdG90eXBlLCBuKSwgbyAmJiBlZSh0LCBvKSwgaTtcbiAgICB9KGkpO1xuICAgIGZ1bmN0aW9uIHVlKGUsIHQpIHtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgbyA9IHRbbl07XG4gICAgICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBvLmtleSwgbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIGUodCwgbikge1xuICAgICAgICAhZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH0odGhpcywgZSksIHRoaXMuaTE4biA9IHQsIHRoaXMuaWNvbkZyYW1ld29yayA9IG4sIHRoaXMuc2VjdGlvbkNsYXNzZXMgPSB7XG4gICAgICAgICAgdGFibGU6IG51bGwsXG4gICAgICAgICAgdGhlYWQ6IG51bGwsXG4gICAgICAgICAgdGhlYWRSb3c6IG51bGwsXG4gICAgICAgICAgdGhlYWRDZWxsOiBudWxsLFxuICAgICAgICAgIHRib2R5OiBudWxsLFxuICAgICAgICAgIHRib2R5Um93OiBudWxsLFxuICAgICAgICAgIHRib2R5Q2VsbDogbnVsbCxcbiAgICAgICAgICB0Zm9vdDogbnVsbCxcbiAgICAgICAgICB0Zm9vdFJvdzogbnVsbCxcbiAgICAgICAgICB0Zm9vdENlbGw6IG51bGwsXG4gICAgICAgICAgZmlyc3Q6IG51bGwsXG4gICAgICAgICAgbGFzdDogbnVsbCxcbiAgICAgICAgICBjb250cm9sOiBudWxsLFxuICAgICAgICAgIGJ1dHRvbjogbnVsbCxcbiAgICAgICAgICBidXR0b25Hcm91cDogbnVsbCxcbiAgICAgICAgICBhcHBlbmQ6IG51bGwsXG4gICAgICAgICAgcmVtb3ZlTGFzdDogbnVsbCxcbiAgICAgICAgICBpbnNlcnQ6IG51bGwsXG4gICAgICAgICAgcmVtb3ZlOiBudWxsLFxuICAgICAgICAgIG1vdmVVcDogbnVsbCxcbiAgICAgICAgICBtb3ZlRG93bjogbnVsbCxcbiAgICAgICAgICBlbXB0eTogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIHQsIG4sIG87XG4gICAgICByZXR1cm4gdCA9IGUsIChuID0gW3tcbiAgICAgICAga2V5OiBcImFwcGx5U2VjdGlvbkNsYXNzZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUpIHtcbiAgICAgICAgICBmb3IgKHZhciB0IGluIHRoaXMuc2VjdGlvbkNsYXNzZXMpIGVbdF0gJiYgKHRoaXMuc2VjdGlvbkNsYXNzZXNbdF0gPyB0aGlzLnNlY3Rpb25DbGFzc2VzW3RdICs9IFwiIFwiICsgZVt0XSA6IHRoaXMuc2VjdGlvbkNsYXNzZXNbdF0gPSBlW3RdKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0U2VjdGlvbkNsYXNzZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZWN0aW9uQ2xhc3Nlc1tlXTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiY3JlYXRlQnV0dG9uR3JvdXBcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZW5lcmF0ZUJ1dHRvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSwgdCwgbikge1xuICAgICAgICAgIHZhciBvID0gdihcImJ1dHRvblwiLCBuLCBudWxsLCBudWxsLCBcImJ1dHRvblwiKTtcbiAgICAgICAgICByZXR1cm4gby50aXRsZSA9IHRoaXMuaTE4blt0XSwgZChvLCB0aGlzLmdldFNlY3Rpb25DbGFzc2VzKFwiYnV0dG9uXCIpLCB0aGlzLmdldFNlY3Rpb25DbGFzc2VzKHQpKSwgZS5hcHBlbmRDaGlsZChvKSwgdGhpcy5pY29uRnJhbWV3b3JrLmdlbmVyYXRlSWNvbihvLCB0KSwgbztcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2VuZXJhdGVDb250cm9sXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlLCB0LCBuLCBvKSB7XG4gICAgICAgICAgdmFyIHIgPSBudWxsO1xuICAgICAgICAgIGlmIChcInNlbGVjdFwiID09PSB0LnR5cGUpIHtcbiAgICAgICAgICAgIGlmIChyID0gdihcInNlbGVjdFwiLCBuLCBvKSwgQXJyYXkuaXNBcnJheSh0LmN0cmxPcHRpb25zKSkge1xuICAgICAgICAgICAgICBpZiAodC5jdHJsT3B0aW9ucy5sZW5ndGggPiAwKSBpZiAoaCh0LmN0cmxPcHRpb25zWzBdKSkgZm9yICh2YXIgaSA9IG51bGwsIHUgPSBudWxsLCBsID0gMDsgbCA8IHQuY3RybE9wdGlvbnMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgICAgICBtKHQuY3RybE9wdGlvbnNbbF0uZ3JvdXApID8gdSA9IG51bGwgOiBpICE9PSB0LmN0cmxPcHRpb25zW2xdLmdyb3VwICYmIChpID0gdC5jdHJsT3B0aW9uc1tsXS5ncm91cCwgKHUgPSB2KFwib3B0Z3JvdXBcIikpLmxhYmVsID0gaSwgci5hcHBlbmRDaGlsZCh1KSk7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB2KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgICAgIGEudmFsdWUgPSB0LmN0cmxPcHRpb25zW2xdLnZhbHVlLCBhLmlubmVyVGV4dCA9IHQuY3RybE9wdGlvbnNbbF0ubGFiZWwsIG0odC5jdHJsT3B0aW9uc1tsXS50aXRsZSkgfHwgYS5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCB0LmN0cmxPcHRpb25zW2xdLnRpdGxlKSwgbnVsbCA9PT0gdSA/IGEuYXBwZW5kVG8ocikgOiBhLmFwcGVuZFRvKHUpO1xuICAgICAgICAgICAgICB9IGVsc2UgZm9yICh2YXIgYyA9IDA7IGMgPCB0LmN0cmxPcHRpb25zLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSB0LmN0cmxPcHRpb25zW2NdO1xuICAgICAgICAgICAgICAgIHIub3B0aW9uc1tyLm9wdGlvbnMubGVuZ3RoXSA9IG5ldyBPcHRpb24ocywgcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaCh0LmN0cmxPcHRpb25zKSkgZm9yICh2YXIgZiBpbiB0LmN0cmxPcHRpb25zKSByLm9wdGlvbnNbci5vcHRpb25zLmxlbmd0aF0gPSBuZXcgT3B0aW9uKHQuY3RybE9wdGlvbnNbZl0sIGYpO2Vsc2UgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQuY3RybE9wdGlvbnMpIGZvciAodmFyIHAgPSB0LmN0cmxPcHRpb25zLnNwbGl0KFwiO1wiKSwgeSA9IDA7IHkgPCBwLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICAgIHZhciBiID0gcFt5XS5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgICAgICAgci5vcHRpb25zW3Iub3B0aW9ucy5sZW5ndGhdID0gLTEgPT09IGIgPyBuZXcgT3B0aW9uKHBbeV0sIHBbeV0pIDogbmV3IE9wdGlvbihwW3ldLnN1YnN0cmluZyhiICsgMSwgcFt5XS5sZW5ndGgpLCBwW3ldLnN1YnN0cmluZygwLCBiKSk7XG4gICAgICAgICAgICB9IGVsc2UgXCJmdW5jdGlvblwiID09IHR5cGVvZiB0LmN0cmxPcHRpb25zICYmIHQuY3RybE9wdGlvbnMocik7XG4gICAgICAgICAgfSBlbHNlIGlmIChcImNoZWNrYm94XCIgPT09IHQudHlwZSkgKHIgPSB2KFwiaW5wdXRcIiwgbiwgbywgbnVsbCwgXCJjaGVja2JveFwiKSkudmFsdWUgPSAxO2Vsc2UgaWYgKFwidGV4dGFyZWFcIiA9PT0gdC50eXBlKSByID0gdihcInRleHRhcmVhXCIsIG4sIG8pO2Vsc2UgaWYgKC0xICE9IHQudHlwZS5zZWFyY2goL14oY29sb3J8ZGF0ZXxkYXRldGltZXxkYXRldGltZVxcLWxvY2FsfGVtYWlsfG1vbnRofG51bWJlcnxyYW5nZXxzZWFyY2h8dGVsfHRpbWV8dXJsfHdlZWspJC8pKSB7XG4gICAgICAgICAgICByID0gdihcImlucHV0XCIsIG4sIG8pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgci50eXBlID0gdC50eXBlO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICB9IGVsc2UgKHIgPSB2KFwiaW5wdXRcIiwgbiwgbykpLnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgICByZXR1cm4gZChyLCB0aGlzLmdldFNlY3Rpb25DbGFzc2VzKFwiY29udHJvbFwiKSwgdC5jdHJsQ2xhc3MpLCBlICYmIGUuYXBwZW5kQ2hpbGQociksIHI7XG4gICAgICAgIH1cbiAgICAgIH1dKSAmJiB1ZSh0LnByb3RvdHlwZSwgbiksIG8gJiYgdWUodCwgbyksIGU7XG4gICAgfSgpO1xuICAgIGZ1bmN0aW9uIGFlKGUpIHtcbiAgICAgIHJldHVybiAoYWUgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IF90eXBlb2YoU3ltYm9sLml0ZXJhdG9yKSA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBfdHlwZW9mKGUpO1xuICAgICAgfSA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIGUuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBlICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IF90eXBlb2YoZSk7XG4gICAgICB9KShlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2UoZSwgdCkge1xuICAgICAgcmV0dXJuIChjZSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICByZXR1cm4gZS5fX3Byb3RvX18gPSB0LCBlO1xuICAgICAgfSkoZSwgdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlKGUpIHtcbiAgICAgIHZhciB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgUmVmbGVjdCB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiAhMTtcbiAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiAhMTtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgUHJveHkpIHJldHVybiAhMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKSwgITA7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH1cbiAgICAgIH0oKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuLFxuICAgICAgICAgIG8gPSBwZShlKTtcbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICB2YXIgciA9IHBlKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgICAgIG4gPSBSZWZsZWN0LmNvbnN0cnVjdChvLCBhcmd1bWVudHMsIHIpO1xuICAgICAgICB9IGVsc2UgbiA9IG8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGZlKHRoaXMsIG4pO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmUoZSwgdCkge1xuICAgICAgcmV0dXJuICF0IHx8IFwib2JqZWN0XCIgIT09IGFlKHQpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9KGUpIDogdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGUoZSkge1xuICAgICAgcmV0dXJuIChwZSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSk7XG4gICAgICB9KShlKTtcbiAgICB9XG4gICAgdmFyIGRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICFmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0ICYmIG51bGwgIT09IHQpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUsIHtcbiAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IGUsXG4gICAgICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgICAgfVxuICAgICAgICB9KSwgdCAmJiBjZShlLCB0KTtcbiAgICAgIH0obiwgZSk7XG4gICAgICB2YXIgdCA9IHNlKG4pO1xuICAgICAgZnVuY3Rpb24gbihlLCBvLCByKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH0odGhpcywgbiksIChpID0gdC5jYWxsKHRoaXMsIG8sIHIpKS5uYW1lID0gXCJ1aS1kZWZhdWx0XCIsIGk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9KGxlKTtcbiAgICBmdW5jdGlvbiBtZShlKSB7XG4gICAgICByZXR1cm4gKG1lID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSBfdHlwZW9mKFN5bWJvbC5pdGVyYXRvcikgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gX3R5cGVvZihlKTtcbiAgICAgIH0gOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBlLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgZSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBfdHlwZW9mKGUpO1xuICAgICAgfSkoZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHllKGUsIHQpIHtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgbyA9IHRbbl07XG4gICAgICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBvLmtleSwgbyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhlKGUsIHQsIG4pIHtcbiAgICAgIHJldHVybiAoaGUgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBSZWZsZWN0ICYmIFJlZmxlY3QuZ2V0ID8gUmVmbGVjdC5nZXQgOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICB2YXIgbyA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgZm9yICg7ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgdCkgJiYgbnVsbCAhPT0gKGUgPSBnZShlKSk7KTtcbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfShlLCB0KTtcbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobywgdCk7XG4gICAgICAgICAgcmV0dXJuIHIuZ2V0ID8gci5nZXQuY2FsbChuKSA6IHIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pKGUsIHQsIG4gfHwgZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZlKGUsIHQpIHtcbiAgICAgIHJldHVybiAodmUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgcmV0dXJuIGUuX19wcm90b19fID0gdCwgZTtcbiAgICAgIH0pKGUsIHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiZShlKSB7XG4gICAgICB2YXIgdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFJlZmxlY3QgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gITE7XG4gICAgICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gITE7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFByb3h5KSByZXR1cm4gITA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSksICEwO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICB9KCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbixcbiAgICAgICAgICBvID0gZ2UoZSk7XG4gICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgdmFyIHIgPSBnZSh0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICBuID0gUmVmbGVjdC5jb25zdHJ1Y3QobywgYXJndW1lbnRzLCByKTtcbiAgICAgICAgfSBlbHNlIG4gPSBvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB3ZSh0aGlzLCBuKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdlKGUsIHQpIHtcbiAgICAgIHJldHVybiAhdCB8fCBcIm9iamVjdFwiICE9PSBtZSh0KSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfShlKSA6IHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdlKGUpIHtcbiAgICAgIHJldHVybiAoZ2UgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpO1xuICAgICAgfSkoZSk7XG4gICAgfVxuICAgIHZhciBPZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAhZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCAmJiBudWxsICE9PSB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlLCB7XG4gICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBlLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgIH1cbiAgICAgICAgfSksIHQgJiYgdmUoZSwgdCk7XG4gICAgICB9KGksIGUpO1xuICAgICAgdmFyIHQsXG4gICAgICAgIG4sXG4gICAgICAgIG8sXG4gICAgICAgIHIgPSBiZShpKTtcbiAgICAgIGZ1bmN0aW9uIGkoZSwgdCwgbikge1xuICAgICAgICB2YXIgbztcbiAgICAgICAgIWZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9KHRoaXMsIGkpLCAobyA9IHIuY2FsbCh0aGlzLCB0LCBuKSkubmFtZSA9IFwidWktYm9vdHN0cmFwNFwiO1xuICAgICAgICB2YXIgdSA9IHtcbiAgICAgICAgICB1c2VCdXR0b25Hcm91cDogITAsXG4gICAgICAgICAgc2VjdGlvbkNsYXNzZXM6IG51bGwsXG4gICAgICAgICAgc2l6aW5nOiBcIm5vcm1hbFwiXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24odSwgZSk7XG4gICAgICAgIHZhciBsID0ge1xuICAgICAgICAgIHRhYmxlOiBcInRhYmxlXCIsXG4gICAgICAgICAgdGhlYWQ6IFwidGhlYWQtbGlnaHRcIixcbiAgICAgICAgICBjb250cm9sOiBcImZvcm0tY29udHJvbFwiLFxuICAgICAgICAgIGJ1dHRvbjogXCJidG5cIixcbiAgICAgICAgICBidXR0b25Hcm91cDogXCJidG4tZ3JvdXBcIixcbiAgICAgICAgICBhcHBlbmQ6IFwiYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCIsXG4gICAgICAgICAgcmVtb3ZlTGFzdDogXCJidG4tb3V0bGluZS1zZWNvbmRhcnlcIixcbiAgICAgICAgICBpbnNlcnQ6IFwiYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCIsXG4gICAgICAgICAgcmVtb3ZlOiBcImJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiLFxuICAgICAgICAgIG1vdmVVcDogXCJidG4tb3V0bGluZS1zZWNvbmRhcnlcIixcbiAgICAgICAgICBtb3ZlRG93bjogXCJidG4tb3V0bGluZS1zZWNvbmRhcnlcIixcbiAgICAgICAgICBlbXB0eTogXCJ0ZXh0LWNlbnRlclwiXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBcInNtYWxsXCIgPT09IHUuc2l6aW5nID8gKGwudGFibGUgKz0gXCIgdGFibGUtc21cIiwgbC5idXR0b25Hcm91cCArPSBcIiBidG4tZ3JvdXAtc21cIiwgbC5jb250cm9sICs9IFwiIGZvcm0tY29udHJvbC1zbVwiKSA6IFwibGFyZ2VcIiA9PT0gdS5zaXppbmcgJiYgKGwuYnV0dG9uR3JvdXAgKz0gXCIgYnRuLWdyb3VwLWxnXCIsIGwuY29udHJvbCArPSBcIiBmb3JtLWNvbnRyb2wtbGdcIiksIHUuc2VjdGlvbkNsYXNzZXMgJiYgT2JqZWN0LmFzc2lnbihsLCB1LnNlY3Rpb25DbGFzc2VzKSwgby5hcHBseVNlY3Rpb25DbGFzc2VzKGwpLCBvLnVpUGFyYW1zID0gdSwgbztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ID0gaSwgKG4gPSBbe1xuICAgICAgICBrZXk6IFwiY3JlYXRlQnV0dG9uR3JvdXBcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgIGlmICh0aGlzLnVpUGFyYW1zLnVzZUJ1dHRvbkdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICByZXR1cm4gZChlLCB0aGlzLmdldFNlY3Rpb25DbGFzc2VzKFwiYnV0dG9uR3JvdXBcIikpLCBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaGUoZ2UoaS5wcm90b3R5cGUpLCBcImNyZWF0ZUJ1dHRvbkdyb3VwXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdlbmVyYXRlQ29udHJvbFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSwgdCwgbiwgbykge1xuICAgICAgICAgIHZhciByID0gbnVsbDtcbiAgICAgICAgICBpZiAoXCJjaGVja2JveFwiID09PSB0LnR5cGUpIHtcbiAgICAgICAgICAgIHZhciB1ID0gdihcImRpdlwiLCBudWxsLCBudWxsLCBcImZvcm0tY2hlY2tcIik7XG4gICAgICAgICAgICBlLmFwcGVuZENoaWxkKHUpLCAociA9IHYoXCJpbnB1dFwiLCBuLCBvLCBcImZvcm0tY2hlY2staW5wdXQgcG9zaXRpb24tc3RhdGljXCIpKS50eXBlID0gXCJjaGVja2JveFwiLCByLnZhbHVlID0gMSwgZChyLCB0LmN0cmxDbGFzcyksIHUuYXBwZW5kQ2hpbGQocik7XG4gICAgICAgICAgfSBlbHNlIFwicmVhZG9ubHlcIiA9PT0gdC50eXBlID8gKGQociA9IHYoXCJpbnB1dFwiLCBuLCBvLCBudWxsLCBcInRleHRcIiksIHRoaXMuZ2V0U2VjdGlvbkNsYXNzZXMoXCJjb250cm9sXCIpLCB0LmN0cmxDbGFzcyksIHIuY2xhc3NMaXN0LnJlbW92ZShcImZvcm0tY29udHJvbFwiKSwgci5jbGFzc0xpc3QuYWRkKFwiZm9ybS1jb250cm9sLXBsYWludGV4dFwiKSwgci5yZWFkT25seSA9ICEwLCBlLmFwcGVuZENoaWxkKHIpKSA6IHIgPSBoZShnZShpLnByb3RvdHlwZSksIFwiZ2VuZXJhdGVDb250cm9sXCIsIHRoaXMpLmNhbGwodGhpcywgZSwgdCwgbiwgbyk7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgIH1dKSAmJiB5ZSh0LnByb3RvdHlwZSwgbiksIG8gJiYgeWUodCwgbyksIGk7XG4gICAgfShsZSk7XG4gICAgZnVuY3Rpb24gQ2UoZSkge1xuICAgICAgcmV0dXJuIChDZSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gX3R5cGVvZihTeW1ib2wuaXRlcmF0b3IpID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIF90eXBlb2YoZSk7XG4gICAgICB9IDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgZS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGUgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogX3R5cGVvZihlKTtcbiAgICAgIH0pKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZShlLCB0KSB7XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgdmFyIG8gPSB0W25dO1xuICAgICAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgby5rZXksIG8pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBrZShlLCB0LCBuKSB7XG4gICAgICByZXR1cm4gKGtlID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmdldCA/IFJlZmxlY3QuZ2V0IDogZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgdmFyIG8gPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgIGZvciAoOyAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHQpICYmIG51bGwgIT09IChlID0gamUoZSkpOyk7XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0oZSwgdCk7XG4gICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG8sIHQpO1xuICAgICAgICAgIHJldHVybiByLmdldCA/IHIuZ2V0LmNhbGwobikgOiByLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KShlLCB0LCBuIHx8IGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBQZShlLCB0KSB7XG4gICAgICByZXR1cm4gKFBlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHJldHVybiBlLl9fcHJvdG9fXyA9IHQsIGU7XG4gICAgICB9KShlLCB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2UoZSkge1xuICAgICAgdmFyIHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChcInVuZGVmaW5lZFwiID09IHR5cGVvZiBSZWZsZWN0IHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuICExO1xuICAgICAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuICExO1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBQcm94eSkgcmV0dXJuICEwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpLCAhMDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG4sXG4gICAgICAgICAgbyA9IGplKGUpO1xuICAgICAgICBpZiAodCkge1xuICAgICAgICAgIHZhciByID0gamUodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgbiA9IFJlZmxlY3QuY29uc3RydWN0KG8sIGFyZ3VtZW50cywgcik7XG4gICAgICAgIH0gZWxzZSBuID0gby5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gU2UodGhpcywgbik7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBTZShlLCB0KSB7XG4gICAgICByZXR1cm4gIXQgfHwgXCJvYmplY3RcIiAhPT0gQ2UodCkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0ID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0oZSkgOiB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBqZShlKSB7XG4gICAgICByZXR1cm4gKGplID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihlKTtcbiAgICAgIH0pKGUpO1xuICAgIH1cbiAgICB2YXIgeGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgIWZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgJiYgbnVsbCAhPT0gdCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSwge1xuICAgICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCB0ICYmIFBlKGUsIHQpO1xuICAgICAgfShpLCBlKTtcbiAgICAgIHZhciB0LFxuICAgICAgICBuLFxuICAgICAgICBvLFxuICAgICAgICByID0gX2UoaSk7XG4gICAgICBmdW5jdGlvbiBpKGUsIHQsIG4pIHtcbiAgICAgICAgdmFyIG87XG4gICAgICAgICFmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiB0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSh0aGlzLCBpKSwgKG8gPSByLmNhbGwodGhpcywgdCwgbikpLm5hbWUgPSBcInVpLWJ1bG1hXCI7XG4gICAgICAgIHZhciB1ID0ge1xuICAgICAgICAgIHVzZUJ1dHRvbkdyb3VwOiAhMCxcbiAgICAgICAgICBzZWN0aW9uQ2xhc3NlczogbnVsbCxcbiAgICAgICAgICBzaXppbmc6IFwibm9ybWFsXCJcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih1LCBlKTtcbiAgICAgICAgdmFyIGwgPSB7XG4gICAgICAgICAgdGFibGU6IFwidGFibGVcIixcbiAgICAgICAgICBjb250cm9sOiBcImlucHV0XCIsXG4gICAgICAgICAgYnV0dG9uOiBcImJ1dHRvblwiLFxuICAgICAgICAgIGJ1dHRvbkdyb3VwOiBcImZpZWxkIGhhcy1hZGRvbnNcIixcbiAgICAgICAgICBhcHBlbmQ6IFwiaXMtb3V0bGluZWRcIixcbiAgICAgICAgICByZW1vdmVMYXN0OiBcImlzLW91dGxpbmVkXCIsXG4gICAgICAgICAgaW5zZXJ0OiBcImlzLW91dGxpbmVkXCIsXG4gICAgICAgICAgcmVtb3ZlOiBcImlzLW91dGxpbmVkXCIsXG4gICAgICAgICAgbW92ZVVwOiBcImlzLW91dGxpbmVkXCIsXG4gICAgICAgICAgbW92ZURvd246IFwiaXMtb3V0bGluZWRcIixcbiAgICAgICAgICBlbXB0eTogXCJoYXMtdGV4dC1jZW50ZXJlZFwiXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBcInNtYWxsXCIgPT09IHUuc2l6aW5nID8gKGwudGFibGUgKz0gXCIgaXMtbmFycm93XCIsIGwuY29udHJvbCArPSBcIiBpcy1zbWFsbFwiLCBsLmJ1dHRvbiArPSBcIiBpcy1zbWFsbFwiKSA6IFwibWVkaXVtXCIgPT09IHUuc2l6aW5nID8gKGwuY29udHJvbCArPSBcIiBpcy1tZWRpdW1cIiwgbC5idXR0b24gKz0gXCIgaXMtbWVkaXVtXCIpIDogXCJsYXJnZVwiID09PSB1LnNpemluZyAmJiAobC5jb250cm9sICs9IFwiIGlzLWxhcmdlXCIsIGwuYnV0dG9uICs9IFwiIGlzLWxhcmdlXCIpLCB1LnNlY3Rpb25DbGFzc2VzICYmIE9iamVjdC5hc3NpZ24obCwgdS5zZWN0aW9uQ2xhc3NlcyksIG8uYXBwbHlTZWN0aW9uQ2xhc3NlcyhsKSwgby51aVBhcmFtcyA9IHUsIG87XG4gICAgICB9XG4gICAgICByZXR1cm4gdCA9IGksIChuID0gW3tcbiAgICAgICAga2V5OiBcImdlbmVyYXRlQnV0dG9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlLCB0LCBuKSB7XG4gICAgICAgICAgdmFyIG8gPSB2KFwiYnV0dG9uXCIsIG4sIG51bGwsIG51bGwsIFwiYnV0dG9uXCIpO1xuICAgICAgICAgIG8udGl0bGUgPSB0aGlzLmkxOG5bdF0sIGQobywgdGhpcy5nZXRTZWN0aW9uQ2xhc3NlcyhcImJ1dHRvblwiKSwgdGhpcy5nZXRTZWN0aW9uQ2xhc3Nlcyh0KSk7XG4gICAgICAgICAgdmFyIHIgPSBudWxsO1xuICAgICAgICAgIGlmICh0aGlzLmljb25GcmFtZXdvcmsuaXNUZXh0QmFzZWQgPyByID0gbyA6ICgociA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKS5jbGFzc0xpc3QuYWRkKFwiaWNvblwiKSwgby5hcHBlbmRDaGlsZChyKSksIHRoaXMuaWNvbkZyYW1ld29yay5nZW5lcmF0ZUljb24ociwgdCksIHRoaXMudWlQYXJhbXMudXNlQnV0dG9uR3JvdXApIHtcbiAgICAgICAgICAgIHZhciBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgICAgICAgICBpLmNsYXNzTGlzdC5hZGQoXCJjb250cm9sXCIpLCBpLmFwcGVuZENoaWxkKG8pLCBlLmFwcGVuZENoaWxkKGkpO1xuICAgICAgICAgIH0gZWxzZSBlLmFwcGVuZENoaWxkKG8pO1xuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJjcmVhdGVCdXR0b25Hcm91cFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICAgICAgaWYgKHRoaXMudWlQYXJhbXMudXNlQnV0dG9uR3JvdXApIHtcbiAgICAgICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHJldHVybiBkKGUsIHRoaXMuZ2V0U2VjdGlvbkNsYXNzZXMoXCJidXR0b25Hcm91cFwiKSksIGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBrZShqZShpLnByb3RvdHlwZSksIFwiY3JlYXRlQnV0dG9uR3JvdXBcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2VuZXJhdGVDb250cm9sXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlLCB0LCBuLCBvKSB7XG4gICAgICAgICAgdmFyIHIgPSBudWxsO1xuICAgICAgICAgIGlmIChcInNlbGVjdFwiID09PSB0LnR5cGUpIHtcbiAgICAgICAgICAgIHZhciB1ID0gdihcImRpdlwiLCBudWxsLCBudWxsLCBcInNlbGVjdFwiKTtcbiAgICAgICAgICAgIFwic21hbGxcIiA9PT0gdGhpcy51aVBhcmFtcy5zaXppbmcgPyB1LmNsYXNzTGlzdC5hZGQoXCJpcy1zbWFsbFwiKSA6IFwibWVkaXVtXCIgPT09IHRoaXMudWlQYXJhbXMuc2l6aW5nID8gdS5jbGFzc0xpc3QuYWRkKFwiaXMtbWVkaXVtXCIpIDogXCJsYXJnZVwiID09PSB0aGlzLnVpUGFyYW1zLnNpemluZyAmJiB1LmNsYXNzTGlzdC5hZGQoXCJpcy1sYXJnZVwiKSwgZS5hcHBlbmRDaGlsZCh1KSwgZChyID0ga2UoamUoaS5wcm90b3R5cGUpLCBcImdlbmVyYXRlQ29udHJvbFwiLCB0aGlzKS5jYWxsKHRoaXMsIG51bGwsIHQsIG4sIG8pLCB0LmN0cmxDbGFzcyksIHUuYXBwZW5kQ2hpbGQocik7XG4gICAgICAgICAgfSBlbHNlIGlmIChcImNoZWNrYm94XCIgPT09IHQudHlwZSkge1xuICAgICAgICAgICAgdmFyIGwgPSB2KFwibGFiZWxcIiwgbnVsbCwgbnVsbCwgXCJjaGVja2JveFwiKTtcbiAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQobCksIChyID0gdihcImlucHV0XCIsIG4sIG8sIG51bGwsIFwiY2hlY2tib3hcIikpLnZhbHVlID0gMSwgZChyLCB0LmN0cmxDbGFzcyksIGwuYXBwZW5kQ2hpbGQocik7XG4gICAgICAgICAgfSBlbHNlIFwicmVhZG9ubHlcIiA9PT0gdC50eXBlID8gKGQociA9IHYoXCJpbnB1dFwiLCBuLCBvLCBudWxsLCBcInRleHRcIiksIHRoaXMuZ2V0U2VjdGlvbkNsYXNzZXMoXCJjb250cm9sXCIpLCB0LmN0cmxDbGFzcyksIHIuY2xhc3NMaXN0LmFkZChcImlzLXN0YXRpY1wiKSwgci5yZWFkT25seSA9ICEwLCBlLmFwcGVuZENoaWxkKHIpKSA6IHIgPSBrZShqZShpLnByb3RvdHlwZSksIFwiZ2VuZXJhdGVDb250cm9sXCIsIHRoaXMpLmNhbGwodGhpcywgZSwgdCwgbiwgbyk7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgIH1dKSAmJiBSZSh0LnByb3RvdHlwZSwgbiksIG8gJiYgUmUodCwgbyksIGk7XG4gICAgfShsZSk7XG4gICAgZnVuY3Rpb24gRWUoZSkge1xuICAgICAgcmV0dXJuIChFZSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gX3R5cGVvZihTeW1ib2wuaXRlcmF0b3IpID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIF90eXBlb2YoZSk7XG4gICAgICB9IDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgZS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGUgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogX3R5cGVvZihlKTtcbiAgICAgIH0pKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBCZShlLCB0KSB7XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgdmFyIG8gPSB0W25dO1xuICAgICAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgby5rZXksIG8pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBJZShlLCB0LCBuKSB7XG4gICAgICByZXR1cm4gKEllID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmdldCA/IFJlZmxlY3QuZ2V0IDogZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgdmFyIG8gPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgIGZvciAoOyAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHQpICYmIG51bGwgIT09IChlID0gTGUoZSkpOyk7XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0oZSwgdCk7XG4gICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG8sIHQpO1xuICAgICAgICAgIHJldHVybiByLmdldCA/IHIuZ2V0LmNhbGwobikgOiByLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KShlLCB0LCBuIHx8IGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBEZShlLCB0KSB7XG4gICAgICByZXR1cm4gKERlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHJldHVybiBlLl9fcHJvdG9fXyA9IHQsIGU7XG4gICAgICB9KShlLCB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRmUoZSkge1xuICAgICAgdmFyIHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChcInVuZGVmaW5lZFwiID09IHR5cGVvZiBSZWZsZWN0IHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuICExO1xuICAgICAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuICExO1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBQcm94eSkgcmV0dXJuICEwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpLCAhMDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG4sXG4gICAgICAgICAgbyA9IExlKGUpO1xuICAgICAgICBpZiAodCkge1xuICAgICAgICAgIHZhciByID0gTGUodGhpcykuY29uc3RydWN0b3I7XG4gICAgICAgICAgbiA9IFJlZmxlY3QuY29uc3RydWN0KG8sIGFyZ3VtZW50cywgcik7XG4gICAgICAgIH0gZWxzZSBuID0gby5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gVGUodGhpcywgbik7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBUZShlLCB0KSB7XG4gICAgICByZXR1cm4gIXQgfHwgXCJvYmplY3RcIiAhPT0gRWUodCkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0ID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0oZSkgOiB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBMZShlKSB7XG4gICAgICByZXR1cm4gKExlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihlKTtcbiAgICAgIH0pKGUpO1xuICAgIH1cbiAgICB2YXIgVWUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgIWZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgJiYgbnVsbCAhPT0gdCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSwge1xuICAgICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCB0ICYmIERlKGUsIHQpO1xuICAgICAgfShpLCBlKTtcbiAgICAgIHZhciB0LFxuICAgICAgICBuLFxuICAgICAgICBvLFxuICAgICAgICByID0gRmUoaSk7XG4gICAgICBmdW5jdGlvbiBpKGUsIHQsIG4pIHtcbiAgICAgICAgdmFyIG87XG4gICAgICAgICFmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiB0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSh0aGlzLCBpKSwgKG8gPSByLmNhbGwodGhpcywgdCwgbikpLm5hbWUgPSBcInVpLWZvdW5kYXRpb242XCI7XG4gICAgICAgIHZhciB1ID0ge1xuICAgICAgICAgIHVzZUJ1dHRvbkdyb3VwOiAhMCxcbiAgICAgICAgICBzZWN0aW9uQ2xhc3NlczogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKHUsIGUpO1xuICAgICAgICB2YXIgbCA9IHtcbiAgICAgICAgICBidXR0b246IFwiYnV0dG9uXCIsXG4gICAgICAgICAgYnV0dG9uR3JvdXA6IFwiYnV0dG9uLWdyb3VwXCJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHUuc2VjdGlvbkNsYXNzZXMgJiYgT2JqZWN0LmFzc2lnbihsLCB1LnNlY3Rpb25DbGFzc2VzKSwgby5hcHBseVNlY3Rpb25DbGFzc2VzKGwpLCBvLnVpUGFyYW1zID0gdSwgbztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ID0gaSwgKG4gPSBbe1xuICAgICAgICBrZXk6IFwiY3JlYXRlQnV0dG9uR3JvdXBcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgIGlmICh0aGlzLnVpUGFyYW1zLnVzZUJ1dHRvbkdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICByZXR1cm4gZChlLCB0aGlzLmdldFNlY3Rpb25DbGFzc2VzKFwiYnV0dG9uR3JvdXBcIikpLCBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gSWUoTGUoaS5wcm90b3R5cGUpLCBcImNyZWF0ZUJ1dHRvbkdyb3VwXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1dKSAmJiBCZSh0LnByb3RvdHlwZSwgbiksIG8gJiYgQmUodCwgbyksIGk7XG4gICAgfShsZSk7XG4gICAgZnVuY3Rpb24gQWUoZSwgdCkge1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgICAgIHZhciBvID0gdFtuXTtcbiAgICAgICAgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIG8ua2V5LCBvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIE5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gZSh0KSB7XG4gICAgICAgICFmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiB0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSh0aGlzLCBlKTtcbiAgICAgICAgdmFyIG4gPSB0aGlzO1xuICAgICAgICBPYmplY3QuYXNzaWduKG4sIHtcbiAgICAgICAgICB1bmlxdWVJbmRleDogMCxcbiAgICAgICAgICByb3dPcmRlcjogW10sXG4gICAgICAgICAgaXNEYXRhTG9hZGVkOiAhMSxcbiAgICAgICAgICB2aXNpYmxlQ291bnQ6IDAsXG4gICAgICAgICAgZmluYWxDb2xTcGFuOiAwLFxuICAgICAgICAgIGhpZGVMYXN0Q29sdW1uOiAhMSxcbiAgICAgICAgICBzZXR0aW5nczogbnVsbCxcbiAgICAgICAgICB0Yldob2xlOiBudWxsLFxuICAgICAgICAgIHRiQm9keTogbnVsbCxcbiAgICAgICAgICBpY29uRnJhbWV3b3JrOiBudWxsLFxuICAgICAgICAgIHVpRnJhbWV3b3JrOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbyA9IE9iamVjdC5hc3NpZ24oe30sIHQpO1xuICAgICAgICBuLnNldHRpbmdzID0gbztcbiAgICAgICAgdmFyIHIgPSBudWxsO1xuICAgICAgICBpZiAoIShyID0gXCJzdHJpbmdcIiA9PSB0eXBlb2Ygby5lbGVtZW50ID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoby5lbGVtZW50KSA6IG8uZWxlbWVudCkgfHwgIXIudGFnTmFtZSB8fCBcIlRBQkxFXCIgIT09IHIudGFnTmFtZSkgdGhyb3cgXCIqZWxlbWVudCogaXMgbm90IGRlZmluZWQgb3IgaXMgbm90IGEgdGFibGUgRE9NIGVsZW1lbnQuXCI7XG4gICAgICAgIGlmIChuLnRiV2hvbGUgPSByLCByLmlubmVySFRNTCA9IFwiXCIsIFwiYm9vdHN0cmFwaWNvbnNcIiA9PT0gby5pY29uRnJhbWV3b3JrKSBuLmljb25GcmFtZXdvcmsgPSBuZXcgayhvLmljb25QYXJhbXMpO2Vsc2UgaWYgKFwiZm9udGF3ZXNvbWU1XCIgPT09IG8uaWNvbkZyYW1ld29yaykgbi5pY29uRnJhbWV3b3JrID0gbmV3IEIoby5pY29uUGFyYW1zKTtlbHNlIGlmIChcImlvbmljb240XCIgPT09IG8uaWNvbkZyYW1ld29yaykgbi5pY29uRnJhbWV3b3JrID0gbmV3IFcoby5pY29uUGFyYW1zKTtlbHNlIGlmIChcIm1hdGVyaWFsZGVzaWduaWNvbnMzXCIgPT09IG8uaWNvbkZyYW1ld29yaykgbi5pY29uRnJhbWV3b3JrID0gbmV3IEEoby5pY29uUGFyYW1zKTtlbHNlIGlmIChcIm9wZW5pY29uaWNcIiA9PT0gby5pY29uRnJhbWV3b3JrKSBuLmljb25GcmFtZXdvcmsgPSBuZXcgaWUoby5pY29uUGFyYW1zKTtlbHNlIGlmIChcInR5cGljb25zMlwiID09PSBvLmljb25GcmFtZXdvcmspIG4uaWNvbkZyYW1ld29yayA9IG5ldyBZKG8uaWNvblBhcmFtcyk7ZWxzZSB7XG4gICAgICAgICAgaWYgKG8uaWNvbkZyYW1ld29yayAmJiBcImRlZmF1bHRcIiAhPT0gby5pY29uRnJhbWV3b3JrKSB0aHJvdyBcIlVua25vd24gSWNvbiBmcmFtZXdvcmsgKlwiLmNvbmNhdChvLmljb25GcmFtZXdvcmssIFwiKi5cIik7XG4gICAgICAgICAgbi5pY29uRnJhbWV3b3JrID0gbmV3IHAoby5pY29uUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJib290c3RyYXA0XCIgPT09IG8udWlGcmFtZXdvcmspIG4udWlGcmFtZXdvcmsgPSBuZXcgT2Uoby51aVBhcmFtcywgby5pMThuLCBuLmljb25GcmFtZXdvcmspO2Vsc2UgaWYgKFwiYnVsbWFcIiA9PT0gby51aUZyYW1ld29yaykgbi51aUZyYW1ld29yayA9IG5ldyB4ZShvLnVpUGFyYW1zLCBvLmkxOG4sIG4uaWNvbkZyYW1ld29yayk7ZWxzZSBpZiAoXCJmb3VuZGF0aW9uNlwiID09PSBvLnVpRnJhbWV3b3JrKSBuLnVpRnJhbWV3b3JrID0gbmV3IFVlKG8udWlQYXJhbXMsIG8uaTE4biwgbi5pY29uRnJhbWV3b3JrKTtlbHNlIHtcbiAgICAgICAgICBpZiAoby51aUZyYW1ld29yayAmJiBcImRlZmF1bHRcIiAhPT0gby51aUZyYW1ld29yaykgdGhyb3cgXCJVbmtub3duIFVJIGZyYW1ld29yayAqXCIuY29uY2F0KG8udWlGcmFtZXdvcmssIFwiKi5cIik7XG4gICAgICAgICAgbi51aUZyYW1ld29yayA9IG5ldyBkZShvLnVpUGFyYW1zLCBvLmkxOG4sIG4uaWNvbkZyYW1ld29yayk7XG4gICAgICAgIH1cbiAgICAgICAgbShvLmlkUHJlZml4KSAmJiAoci5pZCA/IG8uaWRQcmVmaXggPSByLmlkIDogby5pZFByZWZpeCA9IFwiYWdcIiArIG5ldyBEYXRlKCkuZ2V0VGltZSgpKSwgby5zZWN0aW9uQ2xhc3NlcyAmJiBuLnVpRnJhbWV3b3JrLmFwcGx5U2VjdGlvbkNsYXNzZXMoby5zZWN0aW9uQ2xhc3NlcyksIGQociwgbi51aUZyYW1ld29yay5nZXRTZWN0aW9uQ2xhc3NlcyhcInRhYmxlXCIpKTtcbiAgICAgICAgdmFyIGkgPSBuLmNyZWF0ZUVsZW1lbnQoXCJ0aGVhZFwiKTtcbiAgICAgICAgci5hcHBlbmRDaGlsZChpKTtcbiAgICAgICAgdmFyIHUsXG4gICAgICAgICAgbCA9IG4uY3JlYXRlRWxlbWVudChcInRyXCIsIFwidGhlYWRSb3dcIik7XG4gICAgICAgIGkuYXBwZW5kQ2hpbGQobCk7XG4gICAgICAgIHZhciBhID0gMDtcbiAgICAgICAgby5oaWRlUm93TnVtQ29sdW1uIHx8ICh1ID0gbi5jcmVhdGVFbGVtZW50KFwidGhcIiwgXCJ0aGVhZENlbGxcIiksIGwuYXBwZW5kQ2hpbGQodSksIGErKyk7XG4gICAgICAgIGZvciAodmFyIGMgPSAwLCBzID0gMDsgcyA8IG8uY29sdW1ucy5sZW5ndGg7IHMrKykgaWYgKFwiaGlkZGVuXCIgIT09IG8uY29sdW1uc1tzXS50eXBlKSB7XG4gICAgICAgICAgaWYgKDAgPT09IGMpIHtcbiAgICAgICAgICAgIGlmICh1ID0gbi5jcmVhdGVFbGVtZW50KFwidGhcIiwgXCJ0aGVhZENlbGxcIiksIGwuYXBwZW5kQ2hpbGQodSksIGQodSwgby5jb2x1bW5zW3NdLmRpc3BsYXlDbGFzcyksICFtKG8uY29sdW1uc1tzXS5kaXNwbGF5Q3NzKSkgZm9yICh2YXIgZiBpbiBvLmNvbHVtbnNbc10uZGlzcGxheUNzcykgdS5zdHlsZVtmXSA9IG8uY29sdW1uc1tzXS5kaXNwbGF5Q3NzW2ZdO1xuICAgICAgICAgICAgby5jb2x1bW5zW3NdLmhlYWRlclNwYW4gPiAxICYmICh1LnNldEF0dHJpYnV0ZShcImNvbFNwYW5cIiwgby5jb2x1bW5zW3NdLmhlYWRlclNwYW4pLCBjID0gby5jb2x1bW5zW3NdLmhlYWRlclNwYW4gLSAxKSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBvLmNvbHVtbnNbc10uZGlzcGxheSA/IG8uY29sdW1uc1tzXS5kaXNwbGF5KHUpIDogby5jb2x1bW5zW3NdLmRpc3BsYXkgJiYgKHUuaW5uZXJUZXh0ID0gby5jb2x1bW5zW3NdLmRpc3BsYXkpO1xuICAgICAgICAgIH0gZWxzZSBjLS07XG4gICAgICAgICAgYSsrO1xuICAgICAgICB9XG4gICAgICAgIHUgPSBuLmNyZWF0ZUVsZW1lbnQoXCJ0aFwiLCBcInRoZWFkQ2VsbFwiKSwgby5oaWRlQnV0dG9ucy5pbnNlcnQgJiYgby5oaWRlQnV0dG9ucy5yZW1vdmUgJiYgby5oaWRlQnV0dG9ucy5tb3ZlVXAgJiYgby5oaWRlQnV0dG9ucy5tb3ZlRG93biA/IChuLmhpZGVMYXN0Q29sdW1uID0gITAsIHUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiKSA6IGErKywgIW4uaGlkZUxhc3RDb2x1bW4gJiYgby5yb3dCdXR0b25zSW5Gcm9udCA/IG8uaGlkZVJvd051bUNvbHVtbiA/IGwuaW5zZXJ0QmVmb3JlKHUsIGwuZmlyc3RDaGlsZCkgOiBsLmluc2VydEJlZm9yZSh1LCBsLmNoaWxkTm9kZXNbMV0pIDogbC5hcHBlbmRDaGlsZCh1KSwgbi5maW5hbENvbFNwYW4gPSBhO1xuICAgICAgICB2YXIgeSA9IG4uY3JlYXRlRWxlbWVudChcInRib2R5XCIpO1xuICAgICAgICByLmFwcGVuZENoaWxkKHkpLCBuLnRiQm9keSA9IHk7XG4gICAgICAgIHZhciBoID0gbi5jcmVhdGVFbGVtZW50KFwidGZvb3RcIik7XG4gICAgICAgIHIuYXBwZW5kQ2hpbGQoaCksIGwgPSBuLmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCBcInRmb290Um93XCIpLCBoLmFwcGVuZENoaWxkKGwpLCAodSA9IG4uY3JlYXRlRWxlbWVudChcInRkXCIsIFwidGZvb3RDZWxsXCIpKS5jb2xTcGFuID0gbi5maW5hbENvbFNwYW4sIGwuYXBwZW5kQ2hpbGQodSk7XG4gICAgICAgIHZhciBiID0gby5pZFByZWZpeCArIFwiX3Jvd09yZGVyXCIsXG4gICAgICAgICAgdyA9IHYoXCJpbnB1dFwiLCBiLCBiLCBudWxsLCBcImhpZGRlblwiKTtcbiAgICAgICAgaWYgKHUuYXBwZW5kQ2hpbGQodyksIG8uaGlkZUJ1dHRvbnMuYXBwZW5kICYmIG8uaGlkZUJ1dHRvbnMucmVtb3ZlTGFzdCkgbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7ZWxzZSB7XG4gICAgICAgICAgdmFyIGcgPSBuLnVpRnJhbWV3b3JrLmNyZWF0ZUJ1dHRvbkdyb3VwKCk7XG4gICAgICAgICAgaWYgKGcgPyB1LmFwcGVuZENoaWxkKGcpIDogZyA9IHUsICFvLmhpZGVCdXR0b25zLmFwcGVuZCkgbi51aUZyYW1ld29yay5nZW5lcmF0ZUJ1dHRvbihnLCBcImFwcGVuZFwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIG4uaW5zZXJ0Um93KDEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghby5oaWRlQnV0dG9ucy5yZW1vdmVMYXN0KSBuLnVpRnJhbWV3b3JrLmdlbmVyYXRlQnV0dG9uKGcsIFwicmVtb3ZlTGFzdFwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIG4ucmVtb3ZlUm93KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaG93RW1wdHlNZXNzYWdlKCksIG4uc2V0dGluZ3MgPSBvO1xuICAgICAgfVxuICAgICAgdmFyIHQsIG4sIG87XG4gICAgICByZXR1cm4gdCA9IGUsIChuID0gW3tcbiAgICAgICAga2V5OiBcImNyZWF0ZUVsZW1lbnRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUsIHQsIG4pIHtcbiAgICAgICAgICByZXR1cm4gdihlLCBuLCBudWxsLCB0aGlzLnVpRnJhbWV3b3JrLmdldFNlY3Rpb25DbGFzc2VzKHQgfHwgZSkpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJsb2FkRGF0YVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSkge1xuICAgICAgICAgIHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gJiYgYXJndW1lbnRzWzFdO1xuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlKSB8fCAhZS5sZW5ndGgpIHRocm93IFwiKnJlY29yZHMqIHNob3VsZCBiZSBpbiBhcnJheSBmb3JtYXQhXCI7XG4gICAgICAgICAgdmFyIG4gPSB0aGlzLFxuICAgICAgICAgICAgbyA9IG4uc2V0dGluZ3M7XG4gICAgICAgICAgbi50YkJvZHkuaW5uZXJIVE1MID0gXCJcIiwgbi5yb3dPcmRlci5sZW5ndGggPSAwLCBuLnVuaXF1ZUluZGV4ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciByID0gbi5pbnNlcnRSb3coZS5sZW5ndGgpLCBpID0gMDsgaSA8IHIuYWRkZWRSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IG8uY29sdW1ucy5sZW5ndGg7IHUrKykgbi5zZXRDdHJsVmFsdWUodSwgbi5yb3dPcmRlcltpXSwgZVtpXVtvLmNvbHVtbnNbdV0ubmFtZV0pO1xuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09IHR5cGVvZiBvLnJvd0RhdGFMb2FkZWQgJiYgby5yb3dEYXRhTG9hZGVkKG4udGJXaG9sZSwgZVtpXSwgaSwgbi5yb3dPcmRlcltpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG4uaXNEYXRhTG9hZGVkID0gITAsIHQgJiYgKG4uc2V0dGluZ3MuaW5pdERhdGEgPSBudWxsKSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBvLmRhdGFMb2FkZWQgJiYgby5kYXRhTG9hZGVkKG4udGJXaG9sZSwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImluc2VydFJvd1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSwgdCwgbikge1xuICAgICAgICAgIHZhciBvLFxuICAgICAgICAgICAgcixcbiAgICAgICAgICAgIGkgPSB0aGlzLFxuICAgICAgICAgICAgdSA9IGkuc2V0dGluZ3MsXG4gICAgICAgICAgICBsID0gaS51aUZyYW1ld29yayxcbiAgICAgICAgICAgIGEgPSBpLnRiQm9keSxcbiAgICAgICAgICAgIGMgPSBbXSxcbiAgICAgICAgICAgIHMgPSBudWxsLFxuICAgICAgICAgICAgZiA9ICExLFxuICAgICAgICAgICAgcCA9IGUsXG4gICAgICAgICAgICBoID0gITE7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkgJiYgKHAgPSBlLmxlbmd0aCwgaCA9ICEwKSwgeShuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBpLnJvd09yZGVyLmxlbmd0aDsgYisrKSBpZiAoaS5yb3dPcmRlcltiXSA9PT0gbikge1xuICAgICAgICAgICAgICB0ID0gYiwgMCAhPT0gYiAmJiAocyA9IGIgLSAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHkodCkgPyB0ID49IGkucm93T3JkZXIubGVuZ3RoID8gdCA9IG51bGwgOiBzID0gdCAtIDEgOiAwICE9PSBpLnJvd09yZGVyLmxlbmd0aCAmJiAodCA9IG51bGwsIHMgPSBpLnJvd09yZGVyLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIDAgPT09IGkucm93T3JkZXIubGVuZ3RoICYmIChhLmlubmVySFRNTCA9IFwiXCIpO1xuICAgICAgICAgIGZvciAodmFyIHcgPSBmdW5jdGlvbiB3KG4pIHtcbiAgICAgICAgICAgICAgaWYgKDAgPCB1Lm1heFJvd3NBbGxvd2VkICYmIGkucm93T3JkZXIubGVuZ3RoID49IHUubWF4Um93c0FsbG93ZWQpIHJldHVybiBmID0gITAsIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgdmFyIHMgPSArK2kudW5pcXVlSW5kZXgsXG4gICAgICAgICAgICAgICAgcCA9IFtdO1xuICAgICAgICAgICAgICBpZiAoKG8gPSBpLmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCBcInRib2R5Um93XCIsIHUuaWRQcmVmaXggKyBcIl8kcm93X1wiICsgcykpLmRhdGFzZXQudW5pcXVlSW5kZXggPSBzLCB5KHQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSB0ICsgbjtcbiAgICAgICAgICAgICAgICBpLnJvd09yZGVyLnNwbGljZShiLCAwLCBzKSwgYS5pbnNlcnRCZWZvcmUobywgYS5jaGlsZE5vZGVzW2JdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGkucm93T3JkZXIucHVzaChzKSwgYS5hcHBlbmRDaGlsZChvKTtcbiAgICAgICAgICAgICAgYy5wdXNoKHMpLCB1LmhpZGVSb3dOdW1Db2x1bW4gfHwgKChyID0gaS5jcmVhdGVFbGVtZW50KFwidGRcIiwgXCJ0Ym9keUNlbGxcIiwgdS5pZFByZWZpeCArIFwiXyRyb3dOdW1fXCIgKyBzKSkuaW5uZXJUZXh0ID0gXCJcIiArIGkucm93T3JkZXIubGVuZ3RoLCBkKHIsIGwuZ2V0U2VjdGlvbkNsYXNzZXMoXCJmaXJzdFwiKSksIG8uYXBwZW5kQ2hpbGQocikpO1xuICAgICAgICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IHUuY29sdW1ucy5sZW5ndGg7IHcrKykgaWYgKFwiaGlkZGVuXCIgIT09IHUuY29sdW1uc1t3XS50eXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHIgPSBpLmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBcInRib2R5Q2VsbFwiKSwgby5hcHBlbmRDaGlsZChyKSwgZChyLCB1LmNvbHVtbnNbd10uY2VsbENsYXNzKSwgIW0odS5jb2x1bW5zW3ddLmNlbGxDc3MpKSBmb3IgKHZhciBnIGluIHUuY29sdW1uc1t3XS5jZWxsQ3NzKSByLnN0eWxlW2ddID0gdS5jb2x1bW5zW3ddLmNlbGxDc3NbZ107XG4gICAgICAgICAgICAgICAgdmFyIE8gPSB1LmlkUHJlZml4ICsgXCJfXCIgKyB1LmNvbHVtbnNbd10ubmFtZSArIFwiX1wiICsgcyxcbiAgICAgICAgICAgICAgICAgIEMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgQyA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdS5uYW1lRm9ybWF0dGVyID8gdS5uYW1lRm9ybWF0dGVyKHUuaWRQcmVmaXgsIHUuY29sdW1uc1t3XS5uYW1lLCBzKSA6IE87XG4gICAgICAgICAgICAgICAgdmFyIFIgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgayA9IFwiY3VzdG9tXCIgPT09IHUuY29sdW1uc1t3XS50eXBlO1xuICAgICAgICAgICAgICAgIGlmIChrKSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHUuY29sdW1uc1t3XS5jdXN0b21CdWlsZGVyICYmIChSID0gdS5jb2x1bW5zW3ddLmN1c3RvbUJ1aWxkZXIociwgdS5pZFByZWZpeCwgdS5jb2x1bW5zW3ddLm5hbWUsIHMpKTtlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChSID0gaS51aUZyYW1ld29yay5nZW5lcmF0ZUNvbnRyb2wociwgdS5jb2x1bW5zW3ddLCBPLCBDKSwgIW0odS5jb2x1bW5zW3ddLmN0cmxBdHRyKSkgZm9yICh2YXIgUCBpbiB1LmNvbHVtbnNbd10uY3RybEF0dHIpIFIuc2V0QXR0cmlidXRlKFAsIHUuY29sdW1uc1t3XS5jdHJsQXR0cltQXSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIW0odS5jb2x1bW5zW3ddLmN0cmxDc3MpKSBmb3IgKHZhciBfIGluIHUuY29sdW1uc1t3XS5jdHJsQ3NzKSBSLnN0eWxlW19dID0gdS5jb2x1bW5zW3ddLmN0cmxDc3NbX107XG4gICAgICAgICAgICAgICAgICBpZiAodS5jb2x1bW5zW3ddLmV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBSLmRhdGFzZXQuY29sdW1uTmFtZSA9IHUuY29sdW1uc1t3XS5uYW1lLCBSLmRhdGFzZXQudW5pcXVlSW5kZXggPSBzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgUyA9IGZ1bmN0aW9uIFMoZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdS5jb2x1bW5zW3ddLmV2ZW50c1tlXTtcbiAgICAgICAgICAgICAgICAgICAgICBSLmFkZEV2ZW50TGlzdGVuZXIoZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuY29sdW1uTmFtZSA9IGUuY3VycmVudFRhcmdldC5kYXRhc2V0LmNvbHVtbk5hbWUsIGUudW5pcXVlSW5kZXggPSBwYXJzZUludChlLmN1cnJlbnRUYXJnZXQuZGF0YXNldC51bmlxdWVJbmRleCksIHQoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogaW4gdS5jb2x1bW5zW3ddLmV2ZW50cykgUyhqKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaCA/IGkuc2V0Q3RybFZhbHVlKHcsIHMsIGVbbl1bdS5jb2x1bW5zW3ddLm5hbWVdKSA6IG0odS5jb2x1bW5zW3ddLnZhbHVlKSB8fCBpLnNldEN0cmxWYWx1ZSh3LCBzLCB1LmNvbHVtbnNbd10udmFsdWUpLCBrIHx8IFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdS5jb2x1bW5zW3ddLmN0cmxBZGRlZCB8fCB1LmNvbHVtbnNbd10uY3RybEFkZGVkKFIsIHIsIHMpO1xuICAgICAgICAgICAgICB9IGVsc2UgcC5wdXNoKHcpO1xuICAgICAgICAgICAgICBpZiAociA9IGkuY3JlYXRlRWxlbWVudChcInRkXCIsIFwidGJvZHlDZWxsXCIsIHUuaWRQcmVmaXggKyBcIl8kcm93QnV0dG9uX1wiICsgcyksIGkuaGlkZUxhc3RDb2x1bW4gfHwgIXUucm93QnV0dG9uc0luRnJvbnQgPyBvLmFwcGVuZENoaWxkKHIpIDogdS5oaWRlUm93TnVtQ29sdW1uID8gby5pbnNlcnRCZWZvcmUociwgby5maXJzdENoaWxkKSA6IG8uaW5zZXJ0QmVmb3JlKHIsIG8uY2hpbGROb2Rlc1sxXSksIHAuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHZhciBvLFxuICAgICAgICAgICAgICAgICAgbCA9IHUuY29sdW1uc1t0XS5uYW1lLFxuICAgICAgICAgICAgICAgICAgYSA9IHUuaWRQcmVmaXggKyBcIl9cIiArIGwgKyBcIl9cIiArIHM7XG4gICAgICAgICAgICAgICAgbyA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdS5uYW1lRm9ybWF0dGVyID8gdS5uYW1lRm9ybWF0dGVyKHUuaWRQcmVmaXgsIGwsIHMpIDogYSwgci5hcHBlbmRDaGlsZCh2KFwiaW5wdXRcIiwgYSwgbywgbnVsbCwgXCJoaWRkZW5cIikpLCBoID8gaS5zZXRDdHJsVmFsdWUodCwgcywgZVtuXVtsXSkgOiBtKHUuY29sdW1uc1t0XS52YWx1ZSkgfHwgaS5zZXRDdHJsVmFsdWUodCwgcywgdS5jb2x1bW5zW3RdLnZhbHVlKTtcbiAgICAgICAgICAgICAgfSksIGkuaGlkZUxhc3RDb2x1bW4pIHIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO2Vsc2UgaWYgKHUuY29sdW1ucy5sZW5ndGggPiBpLnZpc2libGVDb3VudCkge1xuICAgICAgICAgICAgICAgIGQociwgbC5nZXRTZWN0aW9uQ2xhc3NlcyhcImxhc3RcIikpO1xuICAgICAgICAgICAgICAgIHZhciB4ID0gbC5jcmVhdGVCdXR0b25Hcm91cCgpO1xuICAgICAgICAgICAgICAgIHggPyByLmFwcGVuZENoaWxkKHgpIDogeCA9IHIsIFtcImluc2VydFwiLCBcInJlbW92ZVwiLCBcIm1vdmVVcFwiLCBcIm1vdmVEb3duXCJdLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghdS5oaWRlQnV0dG9uc1tlXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHUuaWRQcmVmaXggKyBcIl8kXCIgKyBlICsgXCJfXCIgKyBzLFxuICAgICAgICAgICAgICAgICAgICAgIG4gPSBsLmdlbmVyYXRlQnV0dG9uKHgsIGUsIHQpO1xuICAgICAgICAgICAgICAgICAgICBuLmRhdGFzZXQudW5pcXVlSW5kZXggPSBzLCBuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gcGFyc2VJbnQodC5jdXJyZW50VGFyZ2V0LmRhdGFzZXQudW5pcXVlSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgIGkucm93QnV0dG9uQWN0aW9ucyhlLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGcgPSAwOyBnIDwgcCAmJiBcImJyZWFrXCIgIT09IHcoZyk7IGcrKyk7XG4gICAgICAgICAgcmV0dXJuIGkuc2F2ZVNldHRpbmcoKSwgdS5oaWRlUm93TnVtQ29sdW1uIHx8IG0odCkgfHwgaS5zb3J0U2VxdWVuY2UodCksIHkodCkgPyBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHUuYWZ0ZXJSb3dJbnNlcnRlZCAmJiB1LmFmdGVyUm93SW5zZXJ0ZWQoaS50Yldob2xlLCBzLCBjKSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdS5hZnRlclJvd0FwcGVuZGVkICYmIHUuYWZ0ZXJSb3dBcHBlbmRlZChpLnRiV2hvbGUsIHMsIGMpLCBmICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdS5tYXhOdW1Sb3dzUmVhY2hlZCAmJiB1Lm1heE51bVJvd3NSZWFjaGVkKGkudGJXaG9sZSksIHtcbiAgICAgICAgICAgIGFkZGVkUm93czogYyxcbiAgICAgICAgICAgIHBhcmVudEluZGV4OiBzLFxuICAgICAgICAgICAgcm93SW5kZXg6IHRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJyZW1vdmVSb3dcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUsIHQsIG4pIHtcbiAgICAgICAgICB2YXIgbyA9IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgICByID0gdGhpcy50YkJvZHk7XG4gICAgICAgICAgaWYgKHkodCkpIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dPcmRlci5sZW5ndGg7IGkrKykgaWYgKHRoaXMucm93T3JkZXJbaV0gPT09IHQpIHtcbiAgICAgICAgICAgIGUgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHkoZSkgPyAobiB8fCBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG8uYmVmb3JlUm93UmVtb3ZlIHx8IG8uYmVmb3JlUm93UmVtb3ZlKHRoaXMudGJXaG9sZSwgZSkpICYmICh0aGlzLnJvd09yZGVyLnNwbGljZShlLCAxKSwgci5yZW1vdmVDaGlsZChyLmNoaWxkTm9kZXNbZV0pLCB0aGlzLnNhdmVTZXR0aW5nKCksIG8uaGlkZVJvd051bUNvbHVtbiB8fCB0aGlzLnNvcnRTZXF1ZW5jZShlKSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBvLmFmdGVyUm93UmVtb3ZlZCAmJiBvLmFmdGVyUm93UmVtb3ZlZCh0aGlzLnRiV2hvbGUsIGUpKSA6IChuIHx8IFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygby5iZWZvcmVSb3dSZW1vdmUgfHwgby5iZWZvcmVSb3dSZW1vdmUodGhpcy50Yldob2xlLCB0aGlzLnJvd09yZGVyLmxlbmd0aCAtIDEpKSAmJiAodCA9IHRoaXMucm93T3JkZXIucG9wKCksIHIucmVtb3ZlQ2hpbGQoci5sYXN0Q2hpbGQpLCB0aGlzLnNhdmVTZXR0aW5nKCksIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygby5hZnRlclJvd1JlbW92ZWQgJiYgby5hZnRlclJvd1JlbW92ZWQodGhpcy50Yldob2xlLCBudWxsKSksIDAgPT09IHRoaXMucm93T3JkZXIubGVuZ3RoICYmIHRoaXMuc2hvd0VtcHR5TWVzc2FnZSgpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJtb3ZlVXBSb3dcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUsIHQpIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgICBvID0gdGhpcy50YkJvZHksXG4gICAgICAgICAgICByID0gbnVsbDtcbiAgICAgICAgICBpZiAoeShlKSAmJiBlID4gMCAmJiBlIDwgdGhpcy5yb3dPcmRlci5sZW5ndGggPyAociA9IGUsIHQgPSB0aGlzLnJvd09yZGVyW2VdKSA6IHkodCkgJiYgKHIgPSB0aGlzLmZpbmRSb3dJbmRleCh0KSksICFtKHIpICYmIHIgPiAwKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMucm93T3JkZXJbciAtIDFdLFxuICAgICAgICAgICAgICB1ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobi5pZFByZWZpeCArIFwiXyRyb3dfXCIgKyB0KSxcbiAgICAgICAgICAgICAgbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG4uaWRQcmVmaXggKyBcIl8kcm93X1wiICsgaSk7XG4gICAgICAgICAgICBpZiAoby5yZW1vdmVDaGlsZCh1KSwgby5pbnNlcnRCZWZvcmUodSwgbCksIHRoaXMucm93T3JkZXJbcl0gPSBpLCB0aGlzLnJvd09yZGVyW3IgLSAxXSA9IHQsICFuLmhpZGVSb3dOdW1Db2x1bW4pIHtcbiAgICAgICAgICAgICAgdmFyIGEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChuLmlkUHJlZml4ICsgXCJfJHJvd051bV9cIiArIHQpLFxuICAgICAgICAgICAgICAgIGMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChuLmlkUHJlZml4ICsgXCJfJHJvd051bV9cIiArIGkpLFxuICAgICAgICAgICAgICAgIHMgPSBjLmlubmVySFRNTDtcbiAgICAgICAgICAgICAgYy5pbm5lckhUTUwgPSBhLmlubmVySFRNTCwgYS5pbm5lckhUTUwgPSBzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zYXZlU2V0dGluZygpLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChuLmlkUHJlZml4ICsgXCJfJG1vdmVVcF9cIiArIHQpLmJsdXIoKSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobi5pZFByZWZpeCArIFwiXyRtb3ZlVXBfXCIgKyBpKS5mb2N1cygpLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4uYWZ0ZXJSb3dTd2FwcGVkICYmIG4uYWZ0ZXJSb3dTd2FwcGVkKHRoaXMudGJXaG9sZSwgciwgciAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwibW92ZURvd25Sb3dcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUsIHQpIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgICBvID0gdGhpcy50YkJvZHksXG4gICAgICAgICAgICByID0gbnVsbDtcbiAgICAgICAgICBpZiAoeShlKSAmJiBlID49IDAgJiYgZSA8IHRoaXMucm93T3JkZXIubGVuZ3RoIC0gMSA/IChyID0gZSwgdCA9IHRoaXMucm93T3JkZXJbZV0pIDogeSh0KSAmJiAociA9IHRoaXMuZmluZFJvd0luZGV4KHQpKSwgIW0ocikgJiYgciAhPT0gdGhpcy5yb3dPcmRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMucm93T3JkZXJbciArIDFdLFxuICAgICAgICAgICAgICB1ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobi5pZFByZWZpeCArIFwiXyRyb3dfXCIgKyB0KSxcbiAgICAgICAgICAgICAgbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG4uaWRQcmVmaXggKyBcIl8kcm93X1wiICsgaSk7XG4gICAgICAgICAgICBpZiAoby5yZW1vdmVDaGlsZChsKSwgby5pbnNlcnRCZWZvcmUobCwgdSksIHRoaXMucm93T3JkZXJbcl0gPSBpLCB0aGlzLnJvd09yZGVyW3IgKyAxXSA9IHQsICFuLmhpZGVSb3dOdW1Db2x1bW4pIHtcbiAgICAgICAgICAgICAgdmFyIGEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChuLmlkUHJlZml4ICsgXCJfJHJvd051bV9cIiArIHQpLFxuICAgICAgICAgICAgICAgIGMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChuLmlkUHJlZml4ICsgXCJfJHJvd051bV9cIiArIGkpLFxuICAgICAgICAgICAgICAgIHMgPSBjLmlubmVySFRNTDtcbiAgICAgICAgICAgICAgYy5pbm5lckhUTUwgPSBhLmlubmVySFRNTCwgYS5pbm5lckhUTUwgPSBzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zYXZlU2V0dGluZygpLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChuLmlkUHJlZml4ICsgXCJfJG1vdmVEb3duX1wiICsgdCkuYmx1cigpLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChuLmlkUHJlZml4ICsgXCJfJG1vdmVEb3duX1wiICsgaSkuZm9jdXMoKSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBuLmFmdGVyUm93U3dhcHBlZCAmJiBuLmFmdGVyUm93U3dhcHBlZCh0aGlzLnRiV2hvbGUsIHIsIHIgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcInNldEN0cmxWYWx1ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSwgdCwgbikge1xuICAgICAgICAgIHZhciBvID0gdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgICAgIHIgPSBvLmNvbHVtbnNbZV0udHlwZSxcbiAgICAgICAgICAgIGkgPSBvLmNvbHVtbnNbZV0ubmFtZTtcbiAgICAgICAgICBpZiAoXCJjdXN0b21cIiA9PT0gcikgXCJmdW5jdGlvblwiID09IHR5cGVvZiBvLmNvbHVtbnNbZV0uY3VzdG9tU2V0dGVyICYmIG8uY29sdW1uc1tlXS5jdXN0b21TZXR0ZXIoby5pZFByZWZpeCwgaSwgdCwgbik7ZWxzZSB7XG4gICAgICAgICAgICB2YXIgdSA9IHRoaXMuZ2V0Q2VsbEN0cmwoby5pZFByZWZpeCwgaSwgdCk7XG4gICAgICAgICAgICBcImNoZWNrYm94XCIgPT09IHIgPyBcImJvb2xlYW5cIiA9PSB0eXBlb2YgbiA/IHUuY2hlY2tlZCA9IG4gOiB5KG4pID8gdS5jaGVja2VkID0gMCAhPT0gbiA6IHUuY2hlY2tlZCA9ICFtKG4pIDogdS52YWx1ZSA9IG0obikgPyBcIlwiIDogbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldENlbGxDdHJsXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlLCB0LCBuKSB7XG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUgKyBcIl9cIiArIHQgKyBcIl9cIiArIG4pO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRDdHJsVmFsdWVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUsIHQpIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgICBvID0gbi5jb2x1bW5zW2VdO1xuICAgICAgICAgIGlmIChcImN1c3RvbVwiID09PSBvLnR5cGUpIHtcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG8uY3VzdG9tR2V0dGVyKSByZXR1cm4gby5jdXN0b21HZXR0ZXIobi5pZFByZWZpeCwgby5uYW1lLCB0KTtcbiAgICAgICAgICAgIHRocm93IFwiKmN1c3RvbUdldHRlciogb2YgY29sdW1uICpcIi5jb25jYXQoby5uYW1lLCBcIiogaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgciA9IHRoaXMuZ2V0Q2VsbEN0cmwobi5pZFByZWZpeCwgby5uYW1lLCB0KTtcbiAgICAgICAgICByZXR1cm4gbnVsbCA9PT0gciA/IG51bGwgOiBcImNoZWNrYm94XCIgPT09IG8udHlwZSA/IHIuY2hlY2tlZCA/IDEgOiAwIDogci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0Um93VmFsdWVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUsIHQpIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMsXG4gICAgICAgICAgICBvID0ge30sXG4gICAgICAgICAgICByID0gbSh0KSA/IFwiXCIgOiBcIl9cIiArIHQ7XG4gICAgICAgICAgcmV0dXJuIG4uc2V0dGluZ3MuY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgICAgICAgICB2YXIgdSA9IHQubmFtZSArIHI7XG4gICAgICAgICAgICBvW3VdID0gbi5nZXRDdHJsVmFsdWUoaSwgZSk7XG4gICAgICAgICAgfSksIG87XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldENvbHVtbkluZGV4XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlKSB7XG4gICAgICAgICAgZm9yICh2YXIgdCA9IHRoaXMuc2V0dGluZ3MuY29sdW1ucywgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSBpZiAodFtuXS5uYW1lID09PSBlKSByZXR1cm4gbjtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiaXNSb3dFbXB0eVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSkge1xuICAgICAgICAgIGZvciAodmFyIHQgPSB0aGlzLnNldHRpbmdzLmNvbHVtbnMsIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgdmFyIG8gPSB0W25dLmVtcHR5Q3JpdGVyaWEsXG4gICAgICAgICAgICAgIHIgPSB0aGlzLmdldEN0cmxWYWx1ZShuLCBlKTtcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG8pIHtcbiAgICAgICAgICAgICAgaWYgKCFvKHIpKSByZXR1cm4gITE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgaSA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChtKG8pKSB7XG4gICAgICAgICAgICAgICAgdmFyIHUgPSB0W25dLnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKFwiY2hlY2tib3hcIiA9PT0gdSkgaSA9IDA7ZWxzZSBpZiAoXCJzZWxlY3RcIiA9PT0gdSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGwgPSB0aGlzLmdldENlbGxDdHJsKHRoaXMuc2V0dGluZ3MuaWRQcmVmaXgsIHRbbl0ubmFtZSwgZSkub3B0aW9ucztcbiAgICAgICAgICAgICAgICAgIGkgPSBsLmxlbmd0aCA+IDAgPyBsWzBdLnZhbHVlIDogXCJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaSA9IFwiXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpID0gbztcbiAgICAgICAgICAgICAgaWYgKHIgIT09IGkpIHJldHVybiAhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJmaW5kUm93SW5kZXhcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUpIHtcbiAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHRoaXMucm93T3JkZXIubGVuZ3RoOyB0KyspIGlmICh0aGlzLnJvd09yZGVyW3RdID09PSBlKSByZXR1cm4gdDtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwic2F2ZVNldHRpbmdcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuc2V0dGluZ3MuaWRQcmVmaXggKyBcIl9yb3dPcmRlclwiKS52YWx1ZSA9IHRoaXMucm93T3JkZXIuam9pbigpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJzaG93RW1wdHlNZXNzYWdlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgICB0aGlzLnRiQm9keS5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICAgIHZhciBlID0gdGhpcy5jcmVhdGVFbGVtZW50KFwidHJcIiwgXCJ0Ym9keVJvd1wiKTtcbiAgICAgICAgICB0aGlzLnRiQm9keS5hcHBlbmRDaGlsZChlKTtcbiAgICAgICAgICB2YXIgdCA9IHRoaXMuY3JlYXRlRWxlbWVudChcInRkXCIsIFwidGJvZHlDZWxsXCIpO1xuICAgICAgICAgIHQuc2V0QXR0cmlidXRlKFwiY29sc3BhblwiLCB0aGlzLmZpbmFsQ29sU3BhbiksIGQodCwgdGhpcy51aUZyYW1ld29yay5nZXRTZWN0aW9uQ2xhc3NlcyhcImVtcHR5XCIpKSwgdC5pbm5lclRleHQgPSB0aGlzLnNldHRpbmdzLmkxOG4ucm93RW1wdHksIGUuYXBwZW5kQ2hpbGQodCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcInNvcnRTZXF1ZW5jZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSkge1xuICAgICAgICAgIGZvciAodmFyIHQgPSBlIHx8IDA7IHQgPCB0aGlzLnJvd09yZGVyLmxlbmd0aDsgdCsrKSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLnNldHRpbmdzLmlkUHJlZml4ICsgXCJfJHJvd051bV9cIiArIHRoaXMucm93T3JkZXJbdF0pLmlubmVyVGV4dCA9IFwiXCIgKyAodCArIDEpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJyb3dCdXR0b25BY3Rpb25zXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlLCB0KSB7XG4gICAgICAgICAgXCJpbnNlcnRcIiA9PT0gZSA/IHRoaXMuaW5zZXJ0Um93KDEsIG51bGwsIHQpIDogXCJyZW1vdmVcIiA9PT0gZSA/IHRoaXMucmVtb3ZlUm93KG51bGwsIHQpIDogXCJtb3ZlVXBcIiA9PT0gZSA/IHRoaXMubW92ZVVwUm93KG51bGwsIHQpIDogXCJtb3ZlRG93blwiID09PSBlICYmIHRoaXMubW92ZURvd25Sb3cobnVsbCwgdCk7XG4gICAgICAgIH1cbiAgICAgIH1dKSAmJiBBZSh0LnByb3RvdHlwZSwgbiksIG8gJiYgQWUodCwgbyksIGU7XG4gICAgfSgpO1xuICAgIGZ1bmN0aW9uIEdlKGUsIHQpIHtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgbyA9IHRbbl07XG4gICAgICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBvLmtleSwgbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBNZSA9IG5ldyBXZWFrTWFwKCksXG4gICAgICBxZSA9IHtcbiAgICAgICAgZWxlbWVudDogbnVsbCxcbiAgICAgICAgdWlGcmFtZXdvcms6IG51bGwsXG4gICAgICAgIHVpUGFyYW1zOiBudWxsLFxuICAgICAgICBpY29uRnJhbWV3b3JrOiBudWxsLFxuICAgICAgICBpY29uUGFyYW1zOiBudWxsLFxuICAgICAgICBpbml0Um93czogMyxcbiAgICAgICAgaWRQcmVmaXg6IG51bGwsXG4gICAgICAgIGluaXREYXRhOiBudWxsLFxuICAgICAgICBjb2x1bW5zOiBbXSxcbiAgICAgICAgaTE4bjogbnVsbCxcbiAgICAgICAgaGlkZUJ1dHRvbnM6IG51bGwsXG4gICAgICAgIGhpZGVSb3dOdW1Db2x1bW46ICExLFxuICAgICAgICByb3dCdXR0b25zSW5Gcm9udDogITEsXG4gICAgICAgIHJvd0NvdW50TmFtZTogXCJfUm93Q291bnRcIixcbiAgICAgICAgc2VjdGlvbkNsYXNzZXM6IG51bGwsXG4gICAgICAgIG1heFJvd3NBbGxvd2VkOiAwXG4gICAgICB9LFxuICAgICAgVmUgPSB7XG4gICAgICAgIG5hbWVGb3JtYXR0ZXI6IG51bGwsXG4gICAgICAgIGRhdGFMb2FkZWQ6IG51bGwsXG4gICAgICAgIHJvd0RhdGFMb2FkZWQ6IG51bGwsXG4gICAgICAgIGFmdGVyUm93QXBwZW5kZWQ6IG51bGwsXG4gICAgICAgIGFmdGVyUm93SW5zZXJ0ZWQ6IG51bGwsXG4gICAgICAgIGFmdGVyUm93U3dhcHBlZDogbnVsbCxcbiAgICAgICAgYmVmb3JlUm93UmVtb3ZlOiBudWxsLFxuICAgICAgICBhZnRlclJvd1JlbW92ZWQ6IG51bGwsXG4gICAgICAgIG1heE51bVJvd3NSZWFjaGVkOiBudWxsXG4gICAgICB9LFxuICAgICAgJGUgPSB7XG4gICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgZGlzcGxheTogbnVsbCxcbiAgICAgICAgZGlzcGxheUNzczogbnVsbCxcbiAgICAgICAgZGlzcGxheUNsYXNzOiBudWxsLFxuICAgICAgICBkaXNwbGF5VG9vbHRpcDogbnVsbCxcbiAgICAgICAgaGVhZGVyU3BhbjogMSxcbiAgICAgICAgY2VsbENzczogbnVsbCxcbiAgICAgICAgY2VsbENsYXNzOiBudWxsLFxuICAgICAgICBjdHJsQXR0cjogbnVsbCxcbiAgICAgICAgY3RybFByb3A6IG51bGwsXG4gICAgICAgIGN0cmxDc3M6IG51bGwsXG4gICAgICAgIGN0cmxDbGFzczogbnVsbCxcbiAgICAgICAgY3RybE9wdGlvbnM6IG51bGwsXG4gICAgICAgIGludmlzaWJsZTogITEsXG4gICAgICAgIGVtcHR5Q3JpdGVyaWE6IG51bGwsXG4gICAgICAgIGN1c3RvbUJ1aWxkZXI6IG51bGwsXG4gICAgICAgIGN1c3RvbUdldHRlcjogbnVsbCxcbiAgICAgICAgY3VzdG9tU2V0dGVyOiBudWxsLFxuICAgICAgICBldmVudHM6IG51bGwsXG4gICAgICAgIGN0cmxBZGRlZDogbnVsbFxuICAgICAgfSxcbiAgICAgIFdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBlKHQpIHtcbiAgICAgICAgICAhZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiB0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICB9KHRoaXMsIGUpO1xuICAgICAgICAgIHZhciBuID0gT2JqZWN0LmFzc2lnbih7fSwgcWUsIFZlLCB0KSxcbiAgICAgICAgICAgIG8gPSB7XG4gICAgICAgICAgICAgIGFwcGVuZDogXCJBcHBlbmQgUm93XCIsXG4gICAgICAgICAgICAgIHJlbW92ZUxhc3Q6IFwiUmVtb3ZlIExhc3QgUm93XCIsXG4gICAgICAgICAgICAgIGluc2VydDogXCJJbnNlcnQgUm93IEFib3ZlXCIsXG4gICAgICAgICAgICAgIHJlbW92ZTogXCJSZW1vdmUgQ3VycmVudCBSb3dcIixcbiAgICAgICAgICAgICAgbW92ZVVwOiBcIk1vdmUgVXBcIixcbiAgICAgICAgICAgICAgbW92ZURvd246IFwiTW92ZSBEb3duXCIsXG4gICAgICAgICAgICAgIHJvd0VtcHR5OiBcIlRoaXMgR3JpZCBJcyBFbXB0eVwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIG4uaTE4biAmJiBPYmplY3QuYXNzaWduKG8sIG4uaTE4biksIG4uaTE4biA9IG87XG4gICAgICAgICAgdmFyIHIgPSB7XG4gICAgICAgICAgICBhcHBlbmQ6ICExLFxuICAgICAgICAgICAgcmVtb3ZlTGFzdDogITEsXG4gICAgICAgICAgICBpbnNlcnQ6ICExLFxuICAgICAgICAgICAgcmVtb3ZlOiAhMSxcbiAgICAgICAgICAgIG1vdmVVcDogITEsXG4gICAgICAgICAgICBtb3ZlRG93bjogITFcbiAgICAgICAgICB9O1xuICAgICAgICAgIG4uaGlkZUJ1dHRvbnMgJiYgT2JqZWN0LmFzc2lnbihyLCBuLmhpZGVCdXR0b25zKSwgbi5oaWRlQnV0dG9ucyA9IHI7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuLmNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB1ID0gT2JqZWN0LmFzc2lnbih7fSwgJGUsIG4uY29sdW1uc1tpXSk7XG4gICAgICAgICAgICBuLmNvbHVtbnNbaV0gPSB1O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbCA9IG5ldyBOZShuKTtcbiAgICAgICAgICBNZS5zZXQodGhpcywgbCksIEFycmF5LmlzQXJyYXkobi5pbml0RGF0YSkgPyBsLmxvYWREYXRhKG4uaW5pdERhdGEsICEwKSA6IG4uaW5pdFJvd3MgPiAwICYmIGwuaW5zZXJ0Um93KG4uaW5pdFJvd3MpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0LCBuLCBvO1xuICAgICAgICByZXR1cm4gdCA9IGUsIChuID0gW3tcbiAgICAgICAgICBrZXk6IFwiYXBwZW5kUm93XCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBNZS5nZXQodGhpcykuaW5zZXJ0Um93KGUgfHwgMSkuYWRkZWRSb3dzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJpbnNlcnRSb3dcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSwgdCkge1xuICAgICAgICAgICAgcmV0dXJuIE1lLmdldCh0aGlzKS5pbnNlcnRSb3coZSwgdCkuYWRkZWRSb3dzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJyZW1vdmVSb3dcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSkge1xuICAgICAgICAgICAgTWUuZ2V0KHRoaXMpLnJlbW92ZVJvdyhlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwibW92ZVVwUm93XCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUpIHtcbiAgICAgICAgICAgIE1lLmdldCh0aGlzKS5tb3ZlVXBSb3coZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIm1vdmVEb3duUm93XCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUpIHtcbiAgICAgICAgICAgIE1lLmdldCh0aGlzKS5tb3ZlRG93blJvdyhlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwibG9hZFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlKSB7XG4gICAgICAgICAgICBNZS5nZXQodGhpcykubG9hZERhdGEoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImdldEFsbFZhbHVlXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUpIHtcbiAgICAgICAgICAgIHZhciB0ID0gTWUuZ2V0KHRoaXMpLFxuICAgICAgICAgICAgICBuID0gZSA/IHt9IDogW107XG4gICAgICAgICAgICByZXR1cm4gdC5yb3dPcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChvLCByKSB7XG4gICAgICAgICAgICAgIGUgPyBPYmplY3QuYXNzaWduKG4sIHQuZ2V0Um93VmFsdWUobywgcikpIDogbi5wdXNoKHQuZ2V0Um93VmFsdWUobykpO1xuICAgICAgICAgICAgfSksIGUgJiYgKG5bdC5zZXR0aW5ncy5yb3dDb3VudE5hbWVdID0gdC5yb3dPcmRlci5sZW5ndGgpLCBuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJnZXRVbmlxdWVJbmRleFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IE1lLmdldCh0aGlzKS5yb3dPcmRlcjtcbiAgICAgICAgICAgIHJldHVybiBlID49IDAgJiYgZSA8IHQubGVuZ3RoID8gdFtlXSA6IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImdldFJvd0luZGV4XCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSBNZS5nZXQodGhpcykucm93T3JkZXIsIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykgaWYgKHRbbl0gPT09IGUpIHJldHVybiBuO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImdldFJvd0NvdW50XCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1lLmdldCh0aGlzKS5yb3dPcmRlci5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImdldFJvd09yZGVyXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1lLmdldCh0aGlzKS5yb3dPcmRlci5zbGljZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJnZXRSb3dWYWx1ZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMuZ2V0VW5pcXVlSW5kZXgoZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbCAhPT0gdCA/IE1lLmdldCh0aGlzKS5nZXRSb3dWYWx1ZSh0KSA6IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImdldEN0cmxWYWx1ZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlLCB0KSB7XG4gICAgICAgICAgICB2YXIgbiA9IE1lLmdldCh0aGlzKS5nZXRDb2x1bW5JbmRleChlKSxcbiAgICAgICAgICAgICAgbyA9IHRoaXMuZ2V0VW5pcXVlSW5kZXgodCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbCAhPT0gbiAmJiBudWxsICE9PSBvID8gTWUuZ2V0KHRoaXMpLmdldEN0cmxWYWx1ZShuLCBvKSA6IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInNldEN0cmxWYWx1ZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlLCB0LCBuKSB7XG4gICAgICAgICAgICB2YXIgbyA9IE1lLmdldCh0aGlzKS5nZXRDb2x1bW5JbmRleChlKSxcbiAgICAgICAgICAgICAgciA9IHRoaXMuZ2V0VW5pcXVlSW5kZXgodCk7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gbyAmJiBudWxsICE9PSByKSByZXR1cm4gTWUuZ2V0KHRoaXMpLnNldEN0cmxWYWx1ZShvLCByLCBuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiZ2V0Q29sdW1uc1wiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBNZS5nZXQodGhpcykuc2V0dGluZ3MuY29sdW1ucy5zbGljZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJnZXRDZWxsQ3RybFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlLCB0KSB7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuZ2V0VW5pcXVlSW5kZXgodCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDZWxsQ3RybEJ5VW5pcXVlSW5kZXgoZSwgbik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImdldENlbGxDdHJsQnlVbmlxdWVJbmRleFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlLCB0KSB7XG4gICAgICAgICAgICB2YXIgbiA9IE1lLmdldCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsICE9PSBuLmdldENvbHVtbkluZGV4KGUpICYmIHkodCkgPyBuLmdldENlbGxDdHJsKG4uc2V0dGluZ3MuaWRQcmVmaXgsIGUsIHQpIDogbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiaXNSb3dFbXB0eVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMuZ2V0VW5pcXVlSW5kZXgoZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PT0gdCB8fCBNZS5nZXQodGhpcykuaXNSb3dFbXB0eSh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwicmVtb3ZlRW1wdHlSb3dzXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZSA9IE1lLmdldCh0aGlzKSwgdCA9IHRoaXMuZ2V0Um93T3JkZXIoKSwgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSBlLmlzUm93RW1wdHkodFtuXSkgJiYgZS5yZW1vdmVSb3cobnVsbCwgdFtuXSwgITApO1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pICYmIEdlKHQucHJvdG90eXBlLCBuKSwgbyAmJiBHZSh0LCBvKSwgZTtcbiAgICAgIH0oKTtcbiAgICB0W1wiZGVmYXVsdFwiXSA9IFdlO1xuICB9XSlbXCJkZWZhdWx0XCJdO1xufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./assets/scripts/modules/table-input.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.nmd = function(module) {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./assets/scripts/modules/table-input.js");
/******/ 	
/******/ })()
;