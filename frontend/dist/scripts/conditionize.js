/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./assets/scripts/modules/conditionize.js":
/*!************************************************!*\
  !*** ./assets/scripts/modules/conditionize.js ***!
  \************************************************/
/***/ (function() {

eval("function _typeof2(obj) { \"@babel/helpers - typeof\"; return _typeof2 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof2(obj); }\n/*!\n * Name    : Conditionize - jQuery conditions for forms\n * Version : 1.0.1\n * Author  : nK <https://nkdev.info>\n * GitHub  : https://github.com/nk-o/conditionize\n */\n/******/\n(function (modules) {\n  // webpackBootstrap\n  /******/ // The module cache\n  /******/\n  var installedModules = {};\n  /******/\n  /******/ // The require function\n  /******/\n  function __nested_webpack_require_693__(moduleId) {\n    /******/\n    /******/ // Check if module is in cache\n    /******/if (installedModules[moduleId]) {\n      /******/return installedModules[moduleId].exports;\n      /******/\n    }\n    /******/ // Create a new module (and put it into the cache)\n    /******/\n    var module = installedModules[moduleId] = {\n      /******/i: moduleId,\n      /******/l: false,\n      /******/exports: {}\n      /******/\n    };\n    /******/\n    /******/ // Execute the module function\n    /******/\n    modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_693__);\n    /******/\n    /******/ // Flag the module as loaded\n    /******/\n    module.l = true;\n    /******/\n    /******/ // Return the exports of the module\n    /******/\n    return module.exports;\n    /******/\n  }\n  /******/\n  /******/\n  /******/ // expose the modules object (__webpack_modules__)\n  /******/\n  __nested_webpack_require_693__.m = modules;\n  /******/\n  /******/ // expose the module cache\n  /******/\n  __nested_webpack_require_693__.c = installedModules;\n  /******/\n  /******/ // define getter function for harmony exports\n  /******/\n  __nested_webpack_require_693__.d = function (exports, name, getter) {\n    /******/if (!__nested_webpack_require_693__.o(exports, name)) {\n      /******/Object.defineProperty(exports, name, {\n        /******/configurable: false,\n        /******/enumerable: true,\n        /******/get: getter\n        /******/\n      });\n      /******/\n    }\n    /******/\n  };\n  /******/\n  /******/ // getDefaultExport function for compatibility with non-harmony modules\n  /******/\n  __nested_webpack_require_693__.n = function (module) {\n    /******/var getter = module && module.__esModule ? /******/function getDefault() {\n      return module['default'];\n    } : /******/function getModuleExports() {\n      return module;\n    };\n    /******/\n    __nested_webpack_require_693__.d(getter, 'a', getter);\n    /******/\n    return getter;\n    /******/\n  };\n  /******/\n  /******/ // Object.prototype.hasOwnProperty.call\n  /******/\n  __nested_webpack_require_693__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n  /******/\n  /******/ // __webpack_public_path__\n  /******/\n  __nested_webpack_require_693__.p = \"\";\n  /******/\n  /******/ // Load entry module and return exports\n  /******/\n  return __nested_webpack_require_693__(__nested_webpack_require_693__.s = 1);\n  /******/\n}\n/************************************************************************/\n/******/)([/* 0 */\n/***/function (module, exports, __nested_webpack_require_3170__) {\n  \"use strict\";\n\n  /* WEBPACK VAR INJECTION */\n  (function (global) {\n    var win;\n    if (typeof window !== \"undefined\") {\n      win = window;\n    } else if (typeof global !== \"undefined\") {\n      win = global;\n    } else if (typeof self !== \"undefined\") {\n      win = self;\n    } else {\n      win = {};\n    }\n    module.exports = win;\n    /* WEBPACK VAR INJECTION */\n  }).call(exports, __nested_webpack_require_3170__(5));\n\n  /***/\n}, /* 1 */\n/***/function (module, exports, __nested_webpack_require_3658__) {\n  module.exports = __nested_webpack_require_3658__(2);\n\n  /***/\n}, /* 2 */\n/***/function (module, exports, __nested_webpack_require_3776__) {\n  \"use strict\";\n\n  var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n    return _typeof2(obj);\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n  };\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n  var _throttleDebounce = __nested_webpack_require_3776__(3);\n  var _rafl = __nested_webpack_require_3776__(4);\n  var _rafl2 = _interopRequireDefault(_rafl);\n  var _global = __nested_webpack_require_3776__(0);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n  var $ = _global.window.jQuery;\n  var instanceID = 0;\n\n  // https://gist.github.com/aaditmshah/6683499\n  /* eslint-disable */\n  function Parser(e) {\n    this.table = e;\n  }\n  Parser.prototype.parse = function (e) {\n    for (var r = e.length, t = this.table, s = [], a = [], h = 0; r > h;) {\n      var i = e[h++];\n      switch (i) {\n        case \"(\":\n          a.unshift(i);\n          break;\n        case \")\":\n          for (; a.length;) {\n            var i = a.shift();\n            if (\"(\" === i) break;\n            s.push(i);\n          }\n          if (\"(\" !== i) throw new Error(\"Mismatched parentheses.\");\n          break;\n        default:\n          if (t.hasOwnProperty(i)) {\n            for (; a.length;) {\n              var f = a[0];\n              if (\"(\" === f) break;\n              var n = t[i],\n                o = n.precedence,\n                c = t[f].precedence;\n              if (o > c || o === c && \"right\" === n.associativity) break;\n              s.push(a.shift());\n            }\n            a.unshift(i);\n          } else s.push(i);\n      }\n    }\n    for (; a.length;) {\n      var i = a.shift();\n      if (\"(\" === i) throw new Error(\"Mismatched parentheses.\");\n      s.push(i);\n    }\n    return s;\n  };\n  /* eslint-enable */\n\n  var sortRelational = {\n    precedence: 3,\n    associativity: 'left'\n  };\n  var sortEquality = {\n    precedence: 2,\n    associativity: 'left'\n  };\n\n  // available relations\n  var relations = {\n    '==': {\n      eval: function _eval(a, b) {\n        return a == b; // eslint-disable-line\n      },\n\n      sort: sortEquality\n    },\n    '!=': {\n      eval: function _eval(a, b) {\n        return a != b; // eslint-disable-line\n      },\n\n      sort: sortEquality\n    },\n    '===': {\n      eval: function _eval(a, b) {\n        return a === b;\n      },\n      sort: sortEquality\n    },\n    '!==': {\n      eval: function _eval(a, b) {\n        return a !== b;\n      },\n      sort: sortEquality\n    },\n    '*=': {\n      eval: function _eval(a, b) {\n        return a.indexOf(b) !== -1;\n      },\n      sort: sortEquality\n    },\n    '<=': {\n      eval: function _eval(a, b) {\n        return a <= b;\n      },\n      sort: sortRelational\n    },\n    '>=': {\n      eval: function _eval(a, b) {\n        return a >= b;\n      },\n      sort: sortRelational\n    },\n    '<': {\n      eval: function _eval(a, b) {\n        return a < b;\n      },\n      sort: sortRelational\n    },\n    '>': {\n      eval: function _eval(a, b) {\n        return a > b;\n      },\n      sort: sortRelational\n    },\n    '&&': {\n      eval: function _eval(a, b) {\n        return a && b;\n      },\n      sort: {\n        precedence: 1,\n        associativity: 'right'\n      }\n    },\n    '||': {\n      eval: function _eval(a, b) {\n        return a || b;\n      },\n      sort: {\n        precedence: 0,\n        associativity: 'right'\n      }\n    }\n  };\n\n  // Conditionize class\n\n  var Conditionize = function () {\n    function Conditionize(container, userOptions) {\n      _classCallCheck(this, Conditionize);\n      var self = this;\n      self.instanceID = instanceID++;\n      self.$container = $(container);\n      self.defaults = {\n        selector: '[data-cond]',\n        conditionAttr: 'data-cond',\n        checkDebounce: 150,\n        // custom toggle function\n        customToggle: null,\n        // function( $item, show ) { $item[ show ? 'show' : 'hide' ](); }\n\n        // events\n        onInit: null,\n        // function() {}\n        onDestroy: null,\n        // function() {}\n        onCheck: null // function( $item, show ) {}\n      };\n\n      self.options = Object.assign({}, self.defaults, userOptions);\n      self.runCheck = (0, _throttleDebounce.debounce)(self.options.checkDebounce, self.runCheck);\n      self.init();\n    }\n    _createClass(Conditionize, [{\n      key: 'init',\n      value: function init() {\n        var self = this;\n\n        // hide all controls by default\n        if (self.options.customToggle) {\n          self.options.customToggle.call(self, self.$container.find(self.options.selector), false);\n        } else {\n          self.$container.find(self.options.selector).hide();\n        }\n\n        // event listener\n        self.$container.on('change.conditionize', 'input, select, textarea', function () {\n          self.runCheck(self.$container.find(self.options.selector));\n        });\n        self.runCheck(self.$container.find(self.options.selector));\n\n        // call onInit event\n        if (self.options.onInit) {\n          self.options.onInit.call(self);\n        }\n      }\n    }, {\n      key: 'runCheck',\n      value: function runCheck($items) {\n        var self = this;\n        (0, _rafl2[\"default\"])(function () {\n          $items.each(function () {\n            var $this = $(this);\n            var conditionString = $this.attr(self.options.conditionAttr).toString();\n            var conditionResult = self.checkCondition(conditionString);\n            if (self.options.customToggle) {\n              self.options.customToggle.call(self, $this, conditionResult);\n            } else {\n              $this[conditionResult ? 'show' : 'hide']();\n            }\n            if (self.options.onCheck) {\n              self.options.onCheck($this, conditionResult);\n            }\n          });\n        });\n      }\n\n      // parse condition\n    }, {\n      key: 'checkCondition',\n      value: function checkCondition(str) {\n        var self = this;\n        var tokens = str.match(/[^\\s]+/g);\n        var token = void 0;\n        var parserRelations = {};\n        Object.keys(relations).forEach(function (k) {\n          parserRelations[k] = relations[k].sort;\n        });\n        var parser = new Parser(parserRelations);\n        tokens = parser.parse(tokens);\n        var stack = [];\n        var index = 0;\n        while (index < tokens.length) {\n          token = tokens[index++];\n          if (token in relations) {\n            var b = stack.pop();\n            var a = stack.pop();\n            stack.push([a, token, b]);\n          } else {\n            stack.push(token);\n          }\n        }\n        return self.compare(stack.length && stack[0]);\n      }\n\n      // check if is valid jquery selector\n    }, {\n      key: 'isValidSelector',\n      value: function isValidSelector(selector) {\n        if (typeof selector !== 'string' || $.isNumeric(selector) || selector === 'false' || selector === 'true' || selector == false // eslint-disable-line\n        || selector == true // eslint-disable-line\n        ) {\n          return false;\n        }\n        try {\n          $(selector);\n        } catch (error) {\n          return false;\n        }\n        return true;\n      }\n\n      // eval\n    }, {\n      key: 'condition',\n      value: function condition(a, operator, b) {\n        if (operator in relations) {\n          if (a === 'false') {\n            a = false;\n          } else if (a === 'true') {\n            a = true;\n          }\n          if (b === 'false') {\n            b = false;\n          } else if (b === 'true') {\n            b = true;\n          }\n          return relations[operator].eval(a, b);\n        }\n        return false;\n      }\n\n      // compare items\n    }, {\n      key: 'compare',\n      value: function compare(arr) {\n        var self = this;\n        if (arr instanceof Array) {\n          if (arr.length === 3) {\n            arr[0] = self.compare(arr[0]);\n            if (arr[2] instanceof Array) {\n              arr[2] = self.compare(arr[2]);\n            }\n            return self.condition(arr[0], arr[1], arr[2]);\n          } else if (arr.length === 1) {\n            return self.compare(arr[0]);\n          }\n          return false;\n        } else if (self.isValidSelector(arr)) {\n          var $listenTo = $(arr);\n          var result = false;\n          if ($listenTo.is('[type=radio], [type=checkbox]')) {\n            result = $listenTo.is(':checked');\n          } else if ($listenTo.is('textarea, select, input')) {\n            result = $listenTo.val();\n          }\n          return result;\n        }\n        return arr;\n      }\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        var self = this;\n\n        // call onDestroy event\n        if (self.options.onDestroy) {\n          self.options.onDestroy.call(self);\n        }\n\n        // disable event.\n        self.$container.off('change.conditionize');\n\n        // show all controls\n        if (self.options.customToggle) {\n          self.options.customToggle.call(self, self.$container.find(self.options.selector), true);\n        } else {\n          self.$container.find(self.options.selector).show();\n        }\n\n        // delete Conditionize instance from container\n        delete self.$container.Conditionize;\n      }\n    }]);\n    return Conditionize;\n  }();\n\n  // global definition\n\n  var plugin = function plugin(items) {\n    // check for dom element\n    // thanks: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n    if ((typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement)) === 'object' ? items instanceof HTMLElement : items && (typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null && items.nodeType === 1 && typeof items.nodeName === 'string') {\n      items = [items];\n    }\n    var options = arguments[1];\n    var args = Array.prototype.slice.call(arguments, 2);\n    var len = items.length;\n    var k = 0;\n    var ret = void 0;\n    for (k; k < len; k++) {\n      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' || typeof options === 'undefined') {\n        if (!items[k].Conditionize) {\n          // eslint-disable-next-line new-cap\n          items[k].Conditionize = new Conditionize(items[k], options);\n        }\n      } else if (items[k].Conditionize) {\n        // eslint-disable-next-line prefer-spread\n        ret = items[k].Conditionize[options].apply(items[k].Conditionize, args);\n      }\n      if (typeof ret !== 'undefined') {\n        return ret;\n      }\n    }\n    return items;\n  };\n  plugin.constructor = Conditionize;\n  _global.window.Conditionize = Conditionize;\n  var jQueryPlugin = function jQueryPlugin() {\n    var args = arguments || [];\n    Array.prototype.unshift.call(args, this);\n    var res = plugin.apply(_global.window, args);\n    return (typeof res === 'undefined' ? 'undefined' : _typeof(res)) !== 'object' ? res : this;\n  };\n  jQueryPlugin.constructor = plugin.constructor;\n\n  // no conflict\n  var oldJqPlugin = $.fn.conditionize;\n  $.fn.conditionize = jQueryPlugin;\n  $.fn.conditionize.noConflict = function () {\n    $.fn.conditionize = oldJqPlugin;\n    return this;\n  };\n\n  /***/\n}, /* 3 */\n/***/function (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  /* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n  /**\n   * Throttle execution of a function. Especially useful for rate limiting\n   * execution of handlers on events like resize and scroll.\n   *\n   * @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n   * @param  {Boolean}   [noTrailing]   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the\n   *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time\n   *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,\n   *                                    the internal counter is reset)\n   * @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n   *                                    to `callback` when the throttled-function is executed.\n   * @param  {Boolean}   [debounceMode] If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),\n   *                                    schedule `callback` to execute after `delay` ms.\n   *\n   * @return {Function}  A new, throttled, function.\n   */\n  function throttle(delay, noTrailing, callback, debounceMode) {\n    /*\n     * After wrapper has stopped being called, this timeout ensures that\n     * `callback` is executed at the proper times in `throttle` and `end`\n     * debounce modes.\n     */\n    var timeoutID;\n\n    // Keep track of the last time `callback` was executed.\n    var lastExec = 0;\n\n    // `noTrailing` defaults to falsy.\n    if (typeof noTrailing !== 'boolean') {\n      debounceMode = callback;\n      callback = noTrailing;\n      noTrailing = undefined;\n    }\n\n    /*\n     * The `wrapper` function encapsulates all of the throttling / debouncing\n     * functionality and when executed will limit the rate at which `callback`\n     * is executed.\n     */\n    function wrapper() {\n      var self = this;\n      var elapsed = Number(new Date()) - lastExec;\n      var args = arguments;\n\n      // Execute `callback` and update the `lastExec` timestamp.\n      function exec() {\n        lastExec = Number(new Date());\n        callback.apply(self, args);\n      }\n\n      /*\n       * If `debounceMode` is true (at begin) this is used to clear the flag\n       * to allow future `callback` executions.\n       */\n      function clear() {\n        timeoutID = undefined;\n      }\n      if (debounceMode && !timeoutID) {\n        /*\n         * Since `wrapper` is being called for the first time and\n         * `debounceMode` is true (at begin), execute `callback`.\n         */\n        exec();\n      }\n\n      // Clear any existing timeout.\n      if (timeoutID) {\n        clearTimeout(timeoutID);\n      }\n      if (debounceMode === undefined && elapsed > delay) {\n        /*\n         * In throttle mode, if `delay` time has been exceeded, execute\n         * `callback`.\n         */\n        exec();\n      } else if (noTrailing !== true) {\n        /*\n         * In trailing throttle mode, since `delay` time has not been\n         * exceeded, schedule `callback` to execute `delay` ms after most\n         * recent execution.\n         *\n         * If `debounceMode` is true (at begin), schedule `clear` to execute\n         * after `delay` ms.\n         *\n         * If `debounceMode` is false (at end), schedule `callback` to\n         * execute after `delay` ms.\n         */\n        timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n      }\n    }\n\n    // Return the wrapper function.\n    return wrapper;\n  }\n\n  /* eslint-disable no-undefined */\n\n  /**\n   * Debounce execution of a function. Debouncing, unlike throttling,\n   * guarantees that a function is only executed a single time, either at the\n   * very beginning of a series of calls, or at the very end.\n   *\n   * @param  {Number}   delay         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n   * @param  {Boolean}  [atBegin]     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n   *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n   *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n   * @param  {Function} callback      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n   *                                  to `callback` when the debounced-function is executed.\n   *\n   * @return {Function} A new, debounced function.\n   */\n  function debounce(delay, atBegin, callback) {\n    return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);\n  }\n  exports.throttle = throttle;\n  exports.debounce = debounce;\n\n  /***/\n}, /* 4 */\n/***/function (module, exports, __nested_webpack_require_21316__) {\n  \"use strict\";\n\n  var global = __nested_webpack_require_21316__(0);\n\n  /**\n   * `requestAnimationFrame()`\n   */\n\n  var request = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || fallback;\n  var prev = +new Date();\n  function fallback(fn) {\n    var curr = +new Date();\n    var ms = Math.max(0, 16 - (curr - prev));\n    var req = setTimeout(fn, ms);\n    return prev = curr, req;\n  }\n\n  /**\n   * `cancelAnimationFrame()`\n   */\n\n  var cancel = global.cancelAnimationFrame || global.webkitCancelAnimationFrame || global.mozCancelAnimationFrame || clearTimeout;\n  if (Function.prototype.bind) {\n    request = request.bind(global);\n    cancel = cancel.bind(global);\n  }\n  exports = module.exports = request;\n  exports.cancel = cancel;\n\n  /***/\n}, /* 5 */\n/***/function (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n    return _typeof2(obj);\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n  };\n  var g;\n\n  // This works in non-strict mode\n  g = function () {\n    return this;\n  }();\n  try {\n    // This works if eval is allowed (see CSP)\n    g = g || Function(\"return this\")() || (1, eval)(\"this\");\n  } catch (e) {\n    // This works if the window reference is available\n    if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n  }\n\n  // g can still be undefined, but nothing to do about it...\n  // We return undefined, instead of nothing here, so it's\n  // easier to handle this case. if(!global) { ...}\n\n  module.exports = g;\n\n  /***/\n}\n/******/]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvc2NyaXB0cy9tb2R1bGVzL2NvbmRpdGlvbml6ZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VucHJpc2UtZnJvbnRlbmQtdG9vbC8uL2Fzc2V0cy9zY3JpcHRzL21vZHVsZXMvY29uZGl0aW9uaXplLmpzPzc0YTciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YyID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZjIob2JqKTsgfVxuLyohXG4gKiBOYW1lICAgIDogQ29uZGl0aW9uaXplIC0galF1ZXJ5IGNvbmRpdGlvbnMgZm9yIGZvcm1zXG4gKiBWZXJzaW9uIDogMS4wLjFcbiAqIEF1dGhvciAgOiBuSyA8aHR0cHM6Ly9ua2Rldi5pbmZvPlxuICogR2l0SHViICA6IGh0dHBzOi8vZ2l0aHViLmNvbS9uay1vL2NvbmRpdGlvbml6ZVxuICovXG4vKioqKioqL1xuKGZ1bmN0aW9uIChtb2R1bGVzKSB7XG4gIC8vIHdlYnBhY2tCb290c3RyYXBcbiAgLyoqKioqKi8gLy8gVGhlIG1vZHVsZSBjYWNoZVxuICAvKioqKioqL1xuICB2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuICAvKioqKioqL1xuICAvKioqKioqLyAvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuICAvKioqKioqL1xuICBmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4gICAgLyoqKioqKi9cbiAgICAvKioqKioqLyAvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiAgICAvKioqKioqL2lmIChpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuICAgICAgLyoqKioqKi9yZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiAgICAgIC8qKioqKiovXG4gICAgfVxuICAgIC8qKioqKiovIC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gICAgLyoqKioqKi9cbiAgICB2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gICAgICAvKioqKioqL2k6IG1vZHVsZUlkLFxuICAgICAgLyoqKioqKi9sOiBmYWxzZSxcbiAgICAgIC8qKioqKiovZXhwb3J0czoge31cbiAgICAgIC8qKioqKiovXG4gICAgfTtcbiAgICAvKioqKioqL1xuICAgIC8qKioqKiovIC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuICAgIC8qKioqKiovXG4gICAgbW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4gICAgLyoqKioqKi9cbiAgICAvKioqKioqLyAvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gICAgLyoqKioqKi9cbiAgICBtb2R1bGUubCA9IHRydWU7XG4gICAgLyoqKioqKi9cbiAgICAvKioqKioqLyAvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuICAgIC8qKioqKiovXG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuICAgIC8qKioqKiovXG4gIH1cbiAgLyoqKioqKi9cbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiAgLyoqKioqKi9cbiAgX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiAgLyoqKioqKi9cbiAgX193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gIC8qKioqKiovXG4gIF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uIChleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiAgICAvKioqKioqL2lmICghX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gICAgICAvKioqKioqL09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gICAgICAgIC8qKioqKiovY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgLyoqKioqKi9lbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAvKioqKioqL2dldDogZ2V0dGVyXG4gICAgICAgIC8qKioqKiovXG4gICAgICB9KTtcbiAgICAgIC8qKioqKiovXG4gICAgfVxuICAgIC8qKioqKiovXG4gIH07XG4gIC8qKioqKiovXG4gIC8qKioqKiovIC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gIC8qKioqKiovXG4gIF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAvKioqKioqL3ZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgPyAvKioqKioqL2Z1bmN0aW9uIGdldERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107XG4gICAgfSA6IC8qKioqKiovZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHtcbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfTtcbiAgICAvKioqKioqL1xuICAgIF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiAgICAvKioqKioqL1xuICAgIHJldHVybiBnZXR0ZXI7XG4gICAgLyoqKioqKi9cbiAgfTtcbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gIC8qKioqKiovXG4gIF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uIChvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTtcbiAgfTtcbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiAgLyoqKioqKi9cbiAgX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gIC8qKioqKiovXG4gIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEpO1xuICAvKioqKioqL1xufVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovKShbLyogMCAqL1xuLyoqKi9mdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL1xuICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgIHZhciB3aW47XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbiA9IHdpbmRvdztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbiA9IGdsb2JhbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3aW4gPSBzZWxmO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW4gPSB7fTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB3aW47XG4gICAgLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovXG4gIH0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyg1KSk7XG5cbiAgLyoqKi9cbn0sIC8qIDEgKi9cbi8qKiovZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbiAgLyoqKi9cbn0sIC8qIDIgKi9cbi8qKiovZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mMihTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBfdHlwZW9mMihvYmopO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBfdHlwZW9mMihvYmopO1xuICB9O1xuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICAgIH07XG4gIH0oKTtcbiAgdmFyIF90aHJvdHRsZURlYm91bmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbiAgdmFyIF9yYWZsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbiAgdmFyIF9yYWZsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JhZmwpO1xuICB2YXIgX2dsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgdmFyICQgPSBfZ2xvYmFsLndpbmRvdy5qUXVlcnk7XG4gIHZhciBpbnN0YW5jZUlEID0gMDtcblxuICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9hYWRpdG1zaGFoLzY2ODM0OTlcbiAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgZnVuY3Rpb24gUGFyc2VyKGUpIHtcbiAgICB0aGlzLnRhYmxlID0gZTtcbiAgfVxuICBQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGUpIHtcbiAgICBmb3IgKHZhciByID0gZS5sZW5ndGgsIHQgPSB0aGlzLnRhYmxlLCBzID0gW10sIGEgPSBbXSwgaCA9IDA7IHIgPiBoOykge1xuICAgICAgdmFyIGkgPSBlW2grK107XG4gICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICBhLnVuc2hpZnQoaSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIpXCI6XG4gICAgICAgICAgZm9yICg7IGEubGVuZ3RoOykge1xuICAgICAgICAgICAgdmFyIGkgPSBhLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoXCIoXCIgPT09IGkpIGJyZWFrO1xuICAgICAgICAgICAgcy5wdXNoKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCIoXCIgIT09IGkpIHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgcGFyZW50aGVzZXMuXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICh0Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBmb3IgKDsgYS5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgIHZhciBmID0gYVswXTtcbiAgICAgICAgICAgICAgaWYgKFwiKFwiID09PSBmKSBicmVhaztcbiAgICAgICAgICAgICAgdmFyIG4gPSB0W2ldLFxuICAgICAgICAgICAgICAgIG8gPSBuLnByZWNlZGVuY2UsXG4gICAgICAgICAgICAgICAgYyA9IHRbZl0ucHJlY2VkZW5jZTtcbiAgICAgICAgICAgICAgaWYgKG8gPiBjIHx8IG8gPT09IGMgJiYgXCJyaWdodFwiID09PSBuLmFzc29jaWF0aXZpdHkpIGJyZWFrO1xuICAgICAgICAgICAgICBzLnB1c2goYS5zaGlmdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEudW5zaGlmdChpKTtcbiAgICAgICAgICB9IGVsc2Ugcy5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKDsgYS5sZW5ndGg7KSB7XG4gICAgICB2YXIgaSA9IGEuc2hpZnQoKTtcbiAgICAgIGlmIChcIihcIiA9PT0gaSkgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBwYXJlbnRoZXNlcy5cIik7XG4gICAgICBzLnB1c2goaSk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgdmFyIHNvcnRSZWxhdGlvbmFsID0ge1xuICAgIHByZWNlZGVuY2U6IDMsXG4gICAgYXNzb2NpYXRpdml0eTogJ2xlZnQnXG4gIH07XG4gIHZhciBzb3J0RXF1YWxpdHkgPSB7XG4gICAgcHJlY2VkZW5jZTogMixcbiAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCdcbiAgfTtcblxuICAvLyBhdmFpbGFibGUgcmVsYXRpb25zXG4gIHZhciByZWxhdGlvbnMgPSB7XG4gICAgJz09Jzoge1xuICAgICAgZXZhbDogZnVuY3Rpb24gX2V2YWwoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA9PSBiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICB9LFxuXG4gICAgICBzb3J0OiBzb3J0RXF1YWxpdHlcbiAgICB9LFxuICAgICchPSc6IHtcbiAgICAgIGV2YWw6IGZ1bmN0aW9uIF9ldmFsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgIT0gYjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgfSxcblxuICAgICAgc29ydDogc29ydEVxdWFsaXR5XG4gICAgfSxcbiAgICAnPT09Jzoge1xuICAgICAgZXZhbDogZnVuY3Rpb24gX2V2YWwoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgIH0sXG4gICAgICBzb3J0OiBzb3J0RXF1YWxpdHlcbiAgICB9LFxuICAgICchPT0nOiB7XG4gICAgICBldmFsOiBmdW5jdGlvbiBfZXZhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICE9PSBiO1xuICAgICAgfSxcbiAgICAgIHNvcnQ6IHNvcnRFcXVhbGl0eVxuICAgIH0sXG4gICAgJyo9Jzoge1xuICAgICAgZXZhbDogZnVuY3Rpb24gX2V2YWwoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5pbmRleE9mKGIpICE9PSAtMTtcbiAgICAgIH0sXG4gICAgICBzb3J0OiBzb3J0RXF1YWxpdHlcbiAgICB9LFxuICAgICc8PSc6IHtcbiAgICAgIGV2YWw6IGZ1bmN0aW9uIF9ldmFsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPD0gYjtcbiAgICAgIH0sXG4gICAgICBzb3J0OiBzb3J0UmVsYXRpb25hbFxuICAgIH0sXG4gICAgJz49Jzoge1xuICAgICAgZXZhbDogZnVuY3Rpb24gX2V2YWwoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA+PSBiO1xuICAgICAgfSxcbiAgICAgIHNvcnQ6IHNvcnRSZWxhdGlvbmFsXG4gICAgfSxcbiAgICAnPCc6IHtcbiAgICAgIGV2YWw6IGZ1bmN0aW9uIF9ldmFsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPCBiO1xuICAgICAgfSxcbiAgICAgIHNvcnQ6IHNvcnRSZWxhdGlvbmFsXG4gICAgfSxcbiAgICAnPic6IHtcbiAgICAgIGV2YWw6IGZ1bmN0aW9uIF9ldmFsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPiBiO1xuICAgICAgfSxcbiAgICAgIHNvcnQ6IHNvcnRSZWxhdGlvbmFsXG4gICAgfSxcbiAgICAnJiYnOiB7XG4gICAgICBldmFsOiBmdW5jdGlvbiBfZXZhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICYmIGI7XG4gICAgICB9LFxuICAgICAgc29ydDoge1xuICAgICAgICBwcmVjZWRlbmNlOiAxLFxuICAgICAgICBhc3NvY2lhdGl2aXR5OiAncmlnaHQnXG4gICAgICB9XG4gICAgfSxcbiAgICAnfHwnOiB7XG4gICAgICBldmFsOiBmdW5jdGlvbiBfZXZhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIHx8IGI7XG4gICAgICB9LFxuICAgICAgc29ydDoge1xuICAgICAgICBwcmVjZWRlbmNlOiAwLFxuICAgICAgICBhc3NvY2lhdGl2aXR5OiAncmlnaHQnXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIENvbmRpdGlvbml6ZSBjbGFzc1xuXG4gIHZhciBDb25kaXRpb25pemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uZGl0aW9uaXplKGNvbnRhaW5lciwgdXNlck9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25kaXRpb25pemUpO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgc2VsZi5pbnN0YW5jZUlEID0gaW5zdGFuY2VJRCsrO1xuICAgICAgc2VsZi4kY29udGFpbmVyID0gJChjb250YWluZXIpO1xuICAgICAgc2VsZi5kZWZhdWx0cyA9IHtcbiAgICAgICAgc2VsZWN0b3I6ICdbZGF0YS1jb25kXScsXG4gICAgICAgIGNvbmRpdGlvbkF0dHI6ICdkYXRhLWNvbmQnLFxuICAgICAgICBjaGVja0RlYm91bmNlOiAxNTAsXG4gICAgICAgIC8vIGN1c3RvbSB0b2dnbGUgZnVuY3Rpb25cbiAgICAgICAgY3VzdG9tVG9nZ2xlOiBudWxsLFxuICAgICAgICAvLyBmdW5jdGlvbiggJGl0ZW0sIHNob3cgKSB7ICRpdGVtWyBzaG93ID8gJ3Nob3cnIDogJ2hpZGUnIF0oKTsgfVxuXG4gICAgICAgIC8vIGV2ZW50c1xuICAgICAgICBvbkluaXQ6IG51bGwsXG4gICAgICAgIC8vIGZ1bmN0aW9uKCkge31cbiAgICAgICAgb25EZXN0cm95OiBudWxsLFxuICAgICAgICAvLyBmdW5jdGlvbigpIHt9XG4gICAgICAgIG9uQ2hlY2s6IG51bGwgLy8gZnVuY3Rpb24oICRpdGVtLCBzaG93ICkge31cbiAgICAgIH07XG5cbiAgICAgIHNlbGYub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHNlbGYuZGVmYXVsdHMsIHVzZXJPcHRpb25zKTtcbiAgICAgIHNlbGYucnVuQ2hlY2sgPSAoMCwgX3Rocm90dGxlRGVib3VuY2UuZGVib3VuY2UpKHNlbGYub3B0aW9ucy5jaGVja0RlYm91bmNlLCBzZWxmLnJ1bkNoZWNrKTtcbiAgICAgIHNlbGYuaW5pdCgpO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoQ29uZGl0aW9uaXplLCBbe1xuICAgICAga2V5OiAnaW5pdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8vIGhpZGUgYWxsIGNvbnRyb2xzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5jdXN0b21Ub2dnbGUpIHtcbiAgICAgICAgICBzZWxmLm9wdGlvbnMuY3VzdG9tVG9nZ2xlLmNhbGwoc2VsZiwgc2VsZi4kY29udGFpbmVyLmZpbmQoc2VsZi5vcHRpb25zLnNlbGVjdG9yKSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuJGNvbnRhaW5lci5maW5kKHNlbGYub3B0aW9ucy5zZWxlY3RvcikuaGlkZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgc2VsZi4kY29udGFpbmVyLm9uKCdjaGFuZ2UuY29uZGl0aW9uaXplJywgJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYucnVuQ2hlY2soc2VsZi4kY29udGFpbmVyLmZpbmQoc2VsZi5vcHRpb25zLnNlbGVjdG9yKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLnJ1bkNoZWNrKHNlbGYuJGNvbnRhaW5lci5maW5kKHNlbGYub3B0aW9ucy5zZWxlY3RvcikpO1xuXG4gICAgICAgIC8vIGNhbGwgb25Jbml0IGV2ZW50XG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMub25Jbml0KSB7XG4gICAgICAgICAgc2VsZi5vcHRpb25zLm9uSW5pdC5jYWxsKHNlbGYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAncnVuQ2hlY2snLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bkNoZWNrKCRpdGVtcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICgwLCBfcmFmbDJbXCJkZWZhdWx0XCJdKShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJGl0ZW1zLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBjb25kaXRpb25TdHJpbmcgPSAkdGhpcy5hdHRyKHNlbGYub3B0aW9ucy5jb25kaXRpb25BdHRyKS50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFyIGNvbmRpdGlvblJlc3VsdCA9IHNlbGYuY2hlY2tDb25kaXRpb24oY29uZGl0aW9uU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuY3VzdG9tVG9nZ2xlKSB7XG4gICAgICAgICAgICAgIHNlbGYub3B0aW9ucy5jdXN0b21Ub2dnbGUuY2FsbChzZWxmLCAkdGhpcywgY29uZGl0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICR0aGlzW2NvbmRpdGlvblJlc3VsdCA/ICdzaG93JyA6ICdoaWRlJ10oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMub25DaGVjaykge1xuICAgICAgICAgICAgICBzZWxmLm9wdGlvbnMub25DaGVjaygkdGhpcywgY29uZGl0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhcnNlIGNvbmRpdGlvblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NoZWNrQ29uZGl0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0NvbmRpdGlvbihzdHIpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgdG9rZW5zID0gc3RyLm1hdGNoKC9bXlxcc10rL2cpO1xuICAgICAgICB2YXIgdG9rZW4gPSB2b2lkIDA7XG4gICAgICAgIHZhciBwYXJzZXJSZWxhdGlvbnMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMocmVsYXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcGFyc2VyUmVsYXRpb25zW2tdID0gcmVsYXRpb25zW2tdLnNvcnQ7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcihwYXJzZXJSZWxhdGlvbnMpO1xuICAgICAgICB0b2tlbnMgPSBwYXJzZXIucGFyc2UodG9rZW5zKTtcbiAgICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpbmRleCsrXTtcbiAgICAgICAgICBpZiAodG9rZW4gaW4gcmVsYXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgYiA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdmFyIGEgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goW2EsIHRva2VuLCBiXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2godG9rZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZi5jb21wYXJlKHN0YWNrLmxlbmd0aCAmJiBzdGFja1swXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGlmIGlzIHZhbGlkIGpxdWVyeSBzZWxlY3RvclxuICAgIH0sIHtcbiAgICAgIGtleTogJ2lzVmFsaWRTZWxlY3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaXNWYWxpZFNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09ICdzdHJpbmcnIHx8ICQuaXNOdW1lcmljKHNlbGVjdG9yKSB8fCBzZWxlY3RvciA9PT0gJ2ZhbHNlJyB8fCBzZWxlY3RvciA9PT0gJ3RydWUnIHx8IHNlbGVjdG9yID09IGZhbHNlIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgfHwgc2VsZWN0b3IgPT0gdHJ1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICQoc2VsZWN0b3IpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZXZhbFxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NvbmRpdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29uZGl0aW9uKGEsIG9wZXJhdG9yLCBiKSB7XG4gICAgICAgIGlmIChvcGVyYXRvciBpbiByZWxhdGlvbnMpIHtcbiAgICAgICAgICBpZiAoYSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgYSA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgICBhID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGIgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIGIgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgYiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZWxhdGlvbnNbb3BlcmF0b3JdLmV2YWwoYSwgYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBjb21wYXJlIGl0ZW1zXG4gICAgfSwge1xuICAgICAga2V5OiAnY29tcGFyZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZShhcnIpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoYXJyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgYXJyWzBdID0gc2VsZi5jb21wYXJlKGFyclswXSk7XG4gICAgICAgICAgICBpZiAoYXJyWzJdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgYXJyWzJdID0gc2VsZi5jb21wYXJlKGFyclsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jb25kaXRpb24oYXJyWzBdLCBhcnJbMV0sIGFyclsyXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChhcnIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jb21wYXJlKGFyclswXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLmlzVmFsaWRTZWxlY3RvcihhcnIpKSB7XG4gICAgICAgICAgdmFyICRsaXN0ZW5UbyA9ICQoYXJyKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgaWYgKCRsaXN0ZW5Uby5pcygnW3R5cGU9cmFkaW9dLCBbdHlwZT1jaGVja2JveF0nKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gJGxpc3RlblRvLmlzKCc6Y2hlY2tlZCcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJGxpc3RlblRvLmlzKCd0ZXh0YXJlYSwgc2VsZWN0LCBpbnB1dCcpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAkbGlzdGVuVG8udmFsKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkZXN0cm95JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gY2FsbCBvbkRlc3Ryb3kgZXZlbnRcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5vbkRlc3Ryb3kpIHtcbiAgICAgICAgICBzZWxmLm9wdGlvbnMub25EZXN0cm95LmNhbGwoc2VsZik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkaXNhYmxlIGV2ZW50LlxuICAgICAgICBzZWxmLiRjb250YWluZXIub2ZmKCdjaGFuZ2UuY29uZGl0aW9uaXplJyk7XG5cbiAgICAgICAgLy8gc2hvdyBhbGwgY29udHJvbHNcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5jdXN0b21Ub2dnbGUpIHtcbiAgICAgICAgICBzZWxmLm9wdGlvbnMuY3VzdG9tVG9nZ2xlLmNhbGwoc2VsZiwgc2VsZi4kY29udGFpbmVyLmZpbmQoc2VsZi5vcHRpb25zLnNlbGVjdG9yKSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi4kY29udGFpbmVyLmZpbmQoc2VsZi5vcHRpb25zLnNlbGVjdG9yKS5zaG93KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZWxldGUgQ29uZGl0aW9uaXplIGluc3RhbmNlIGZyb20gY29udGFpbmVyXG4gICAgICAgIGRlbGV0ZSBzZWxmLiRjb250YWluZXIuQ29uZGl0aW9uaXplO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gQ29uZGl0aW9uaXplO1xuICB9KCk7XG5cbiAgLy8gZ2xvYmFsIGRlZmluaXRpb25cblxuICB2YXIgcGx1Z2luID0gZnVuY3Rpb24gcGx1Z2luKGl0ZW1zKSB7XG4gICAgLy8gY2hlY2sgZm9yIGRvbSBlbGVtZW50XG4gICAgLy8gdGhhbmtzOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM4NDI4Ni9qYXZhc2NyaXB0LWlzZG9tLWhvdy1kby15b3UtY2hlY2staWYtYS1qYXZhc2NyaXB0LW9iamVjdC1pcy1hLWRvbS1vYmplY3RcbiAgICBpZiAoKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoSFRNTEVsZW1lbnQpKSA9PT0gJ29iamVjdCcgPyBpdGVtcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IDogaXRlbXMgJiYgKHR5cGVvZiBpdGVtcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaXRlbXMpKSA9PT0gJ29iamVjdCcgJiYgaXRlbXMgIT09IG51bGwgJiYgaXRlbXMubm9kZVR5cGUgPT09IDEgJiYgdHlwZW9mIGl0ZW1zLm5vZGVOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgaXRlbXMgPSBbaXRlbXNdO1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICB2YXIgayA9IDA7XG4gICAgdmFyIHJldCA9IHZvaWQgMDtcbiAgICBmb3IgKGs7IGsgPCBsZW47IGsrKykge1xuICAgICAgaWYgKCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob3B0aW9ucykpID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKCFpdGVtc1trXS5Db25kaXRpb25pemUpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICAgICAgICAgIGl0ZW1zW2tdLkNvbmRpdGlvbml6ZSA9IG5ldyBDb25kaXRpb25pemUoaXRlbXNba10sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zW2tdLkNvbmRpdGlvbml6ZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuICAgICAgICByZXQgPSBpdGVtc1trXS5Db25kaXRpb25pemVbb3B0aW9uc10uYXBwbHkoaXRlbXNba10uQ29uZGl0aW9uaXplLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXRlbXM7XG4gIH07XG4gIHBsdWdpbi5jb25zdHJ1Y3RvciA9IENvbmRpdGlvbml6ZTtcbiAgX2dsb2JhbC53aW5kb3cuQ29uZGl0aW9uaXplID0gQ29uZGl0aW9uaXplO1xuICB2YXIgalF1ZXJ5UGx1Z2luID0gZnVuY3Rpb24galF1ZXJ5UGx1Z2luKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzIHx8IFtdO1xuICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmNhbGwoYXJncywgdGhpcyk7XG4gICAgdmFyIHJlcyA9IHBsdWdpbi5hcHBseShfZ2xvYmFsLndpbmRvdywgYXJncyk7XG4gICAgcmV0dXJuICh0eXBlb2YgcmVzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihyZXMpKSAhPT0gJ29iamVjdCcgPyByZXMgOiB0aGlzO1xuICB9O1xuICBqUXVlcnlQbHVnaW4uY29uc3RydWN0b3IgPSBwbHVnaW4uY29uc3RydWN0b3I7XG5cbiAgLy8gbm8gY29uZmxpY3RcbiAgdmFyIG9sZEpxUGx1Z2luID0gJC5mbi5jb25kaXRpb25pemU7XG4gICQuZm4uY29uZGl0aW9uaXplID0galF1ZXJ5UGx1Z2luO1xuICAkLmZuLmNvbmRpdGlvbml6ZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uY29uZGl0aW9uaXplID0gb2xkSnFQbHVnaW47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqKi9cbn0sIC8qIDMgKi9cbi8qKiovZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkLG5vLXBhcmFtLXJlYXNzaWduLG5vLXNoYWRvdyAqL1xuXG4gIC8qKlxuICAgKiBUaHJvdHRsZSBleGVjdXRpb24gb2YgYSBmdW5jdGlvbi4gRXNwZWNpYWxseSB1c2VmdWwgZm9yIHJhdGUgbGltaXRpbmdcbiAgICogZXhlY3V0aW9uIG9mIGhhbmRsZXJzIG9uIGV2ZW50cyBsaWtlIHJlc2l6ZSBhbmQgc2Nyb2xsLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgIGRlbGF5ICAgICAgICAgIEEgemVyby1vci1ncmVhdGVyIGRlbGF5IGluIG1pbGxpc2Vjb25kcy4gRm9yIGV2ZW50IGNhbGxiYWNrcywgdmFsdWVzIGFyb3VuZCAxMDAgb3IgMjUwIChvciBldmVuIGhpZ2hlcikgYXJlIG1vc3QgdXNlZnVsLlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgIFtub1RyYWlsaW5nXSAgIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZS4gSWYgbm9UcmFpbGluZyBpcyB0cnVlLCBjYWxsYmFjayB3aWxsIG9ubHkgZXhlY3V0ZSBldmVyeSBgZGVsYXlgIG1pbGxpc2Vjb25kcyB3aGlsZSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgYmVpbmcgY2FsbGVkLiBJZiBub1RyYWlsaW5nIGlzIGZhbHNlIG9yIHVuc3BlY2lmaWVkLCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIG9uZSBmaW5hbCB0aW1lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgdGhlIGxhc3QgdGhyb3R0bGVkLWZ1bmN0aW9uIGNhbGwuIChBZnRlciB0aGUgdGhyb3R0bGVkLWZ1bmN0aW9uIGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIGBkZWxheWAgbWlsbGlzZWNvbmRzLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrICAgICAgIEEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgZGVsYXkgbWlsbGlzZWNvbmRzLiBUaGUgYHRoaXNgIGNvbnRleHQgYW5kIGFsbCBhcmd1bWVudHMgYXJlIHBhc3NlZCB0aHJvdWdoLCBhcy1pcyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBgY2FsbGJhY2tgIHdoZW4gdGhlIHRocm90dGxlZC1mdW5jdGlvbiBpcyBleGVjdXRlZC5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICBbZGVib3VuY2VNb2RlXSBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIHNjaGVkdWxlIGBjbGVhcmAgdG8gZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLiBJZiBgZGVib3VuY2VNb2RlYCBpcyBmYWxzZSAoYXQgZW5kKSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZSBgY2FsbGJhY2tgIHRvIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy5cbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb259ICBBIG5ldywgdGhyb3R0bGVkLCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIHRocm90dGxlKGRlbGF5LCBub1RyYWlsaW5nLCBjYWxsYmFjaywgZGVib3VuY2VNb2RlKSB7XG4gICAgLypcbiAgICAgKiBBZnRlciB3cmFwcGVyIGhhcyBzdG9wcGVkIGJlaW5nIGNhbGxlZCwgdGhpcyB0aW1lb3V0IGVuc3VyZXMgdGhhdFxuICAgICAqIGBjYWxsYmFja2AgaXMgZXhlY3V0ZWQgYXQgdGhlIHByb3BlciB0aW1lcyBpbiBgdGhyb3R0bGVgIGFuZCBgZW5kYFxuICAgICAqIGRlYm91bmNlIG1vZGVzLlxuICAgICAqL1xuICAgIHZhciB0aW1lb3V0SUQ7XG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBsYXN0IHRpbWUgYGNhbGxiYWNrYCB3YXMgZXhlY3V0ZWQuXG4gICAgdmFyIGxhc3RFeGVjID0gMDtcblxuICAgIC8vIGBub1RyYWlsaW5nYCBkZWZhdWx0cyB0byBmYWxzeS5cbiAgICBpZiAodHlwZW9mIG5vVHJhaWxpbmcgIT09ICdib29sZWFuJykge1xuICAgICAgZGVib3VuY2VNb2RlID0gY2FsbGJhY2s7XG4gICAgICBjYWxsYmFjayA9IG5vVHJhaWxpbmc7XG4gICAgICBub1RyYWlsaW5nID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogVGhlIGB3cmFwcGVyYCBmdW5jdGlvbiBlbmNhcHN1bGF0ZXMgYWxsIG9mIHRoZSB0aHJvdHRsaW5nIC8gZGVib3VuY2luZ1xuICAgICAqIGZ1bmN0aW9uYWxpdHkgYW5kIHdoZW4gZXhlY3V0ZWQgd2lsbCBsaW1pdCB0aGUgcmF0ZSBhdCB3aGljaCBgY2FsbGJhY2tgXG4gICAgICogaXMgZXhlY3V0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBlbGFwc2VkID0gTnVtYmVyKG5ldyBEYXRlKCkpIC0gbGFzdEV4ZWM7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICAgICAgLy8gRXhlY3V0ZSBgY2FsbGJhY2tgIGFuZCB1cGRhdGUgdGhlIGBsYXN0RXhlY2AgdGltZXN0YW1wLlxuICAgICAgZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgbGFzdEV4ZWMgPSBOdW1iZXIobmV3IERhdGUoKSk7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICogSWYgYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pIHRoaXMgaXMgdXNlZCB0byBjbGVhciB0aGUgZmxhZ1xuICAgICAgICogdG8gYWxsb3cgZnV0dXJlIGBjYWxsYmFja2AgZXhlY3V0aW9ucy5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIHRpbWVvdXRJRCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChkZWJvdW5jZU1vZGUgJiYgIXRpbWVvdXRJRCkge1xuICAgICAgICAvKlxuICAgICAgICAgKiBTaW5jZSBgd3JhcHBlcmAgaXMgYmVpbmcgY2FsbGVkIGZvciB0aGUgZmlyc3QgdGltZSBhbmRcbiAgICAgICAgICogYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pLCBleGVjdXRlIGBjYWxsYmFja2AuXG4gICAgICAgICAqL1xuICAgICAgICBleGVjKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyB0aW1lb3V0LlxuICAgICAgaWYgKHRpbWVvdXRJRCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWJvdW5jZU1vZGUgPT09IHVuZGVmaW5lZCAmJiBlbGFwc2VkID4gZGVsYXkpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogSW4gdGhyb3R0bGUgbW9kZSwgaWYgYGRlbGF5YCB0aW1lIGhhcyBiZWVuIGV4Y2VlZGVkLCBleGVjdXRlXG4gICAgICAgICAqIGBjYWxsYmFja2AuXG4gICAgICAgICAqL1xuICAgICAgICBleGVjKCk7XG4gICAgICB9IGVsc2UgaWYgKG5vVHJhaWxpbmcgIT09IHRydWUpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogSW4gdHJhaWxpbmcgdGhyb3R0bGUgbW9kZSwgc2luY2UgYGRlbGF5YCB0aW1lIGhhcyBub3QgYmVlblxuICAgICAgICAgKiBleGNlZWRlZCwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0byBleGVjdXRlIGBkZWxheWAgbXMgYWZ0ZXIgbW9zdFxuICAgICAgICAgKiByZWNlbnQgZXhlY3V0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIHNjaGVkdWxlIGBjbGVhcmAgdG8gZXhlY3V0ZVxuICAgICAgICAgKiBhZnRlciBgZGVsYXlgIG1zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyBmYWxzZSAoYXQgZW5kKSwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0b1xuICAgICAgICAgKiBleGVjdXRlIGFmdGVyIGBkZWxheWAgbXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KGRlYm91bmNlTW9kZSA/IGNsZWFyIDogZXhlYywgZGVib3VuY2VNb2RlID09PSB1bmRlZmluZWQgPyBkZWxheSAtIGVsYXBzZWQgOiBkZWxheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgIHJldHVybiB3cmFwcGVyO1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkICovXG5cbiAgLyoqXG4gICAqIERlYm91bmNlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uLiBEZWJvdW5jaW5nLCB1bmxpa2UgdGhyb3R0bGluZyxcbiAgICogZ3VhcmFudGVlcyB0aGF0IGEgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBhIHNpbmdsZSB0aW1lLCBlaXRoZXIgYXQgdGhlXG4gICAqIHZlcnkgYmVnaW5uaW5nIG9mIGEgc2VyaWVzIG9mIGNhbGxzLCBvciBhdCB0aGUgdmVyeSBlbmQuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcn0gICBkZWxheSAgICAgICAgIEEgemVyby1vci1ncmVhdGVyIGRlbGF5IGluIG1pbGxpc2Vjb25kcy4gRm9yIGV2ZW50IGNhbGxiYWNrcywgdmFsdWVzIGFyb3VuZCAxMDAgb3IgMjUwIChvciBldmVuIGhpZ2hlcikgYXJlIG1vc3QgdXNlZnVsLlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgW2F0QmVnaW5dICAgICBPcHRpb25hbCwgZGVmYXVsdHMgdG8gZmFsc2UuIElmIGF0QmVnaW4gaXMgZmFsc2Ugb3IgdW5zcGVjaWZpZWQsIGNhbGxiYWNrIHdpbGwgb25seSBiZSBleGVjdXRlZCBgZGVsYXlgIG1pbGxpc2Vjb25kc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlciB0aGUgbGFzdCBkZWJvdW5jZWQtZnVuY3Rpb24gY2FsbC4gSWYgYXRCZWdpbiBpcyB0cnVlLCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIG9ubHkgYXQgdGhlIGZpcnN0IGRlYm91bmNlZC1mdW5jdGlvbiBjYWxsLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoQWZ0ZXIgdGhlIHRocm90dGxlZC1mdW5jdGlvbiBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciBgZGVsYXlgIG1pbGxpc2Vjb25kcywgdGhlIGludGVybmFsIGNvdW50ZXIgaXMgcmVzZXQpLlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgICAgICBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcy4gVGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhbGwgYXJndW1lbnRzIGFyZSBwYXNzZWQgdGhyb3VnaCwgYXMtaXMsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGBjYWxsYmFja2Agd2hlbiB0aGUgZGVib3VuY2VkLWZ1bmN0aW9uIGlzIGV4ZWN1dGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcsIGRlYm91bmNlZCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGRlYm91bmNlKGRlbGF5LCBhdEJlZ2luLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gdGhyb3R0bGUoZGVsYXksIGF0QmVnaW4sIGZhbHNlKSA6IHRocm90dGxlKGRlbGF5LCBjYWxsYmFjaywgYXRCZWdpbiAhPT0gZmFsc2UpO1xuICB9XG4gIGV4cG9ydHMudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgZXhwb3J0cy5kZWJvdW5jZSA9IGRlYm91bmNlO1xuXG4gIC8qKiovXG59LCAvKiA0ICovXG4vKioqL2Z1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbiAgLyoqXG4gICAqIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKWBcbiAgICovXG5cbiAgdmFyIHJlcXVlc3QgPSBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdsb2JhbC53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZ2xvYmFsLm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBmYWxsYmFjaztcbiAgdmFyIHByZXYgPSArbmV3IERhdGUoKTtcbiAgZnVuY3Rpb24gZmFsbGJhY2soZm4pIHtcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnIgLSBwcmV2KSk7XG4gICAgdmFyIHJlcSA9IHNldFRpbWVvdXQoZm4sIG1zKTtcbiAgICByZXR1cm4gcHJldiA9IGN1cnIsIHJlcTtcbiAgfVxuXG4gIC8qKlxuICAgKiBgY2FuY2VsQW5pbWF0aW9uRnJhbWUoKWBcbiAgICovXG5cbiAgdmFyIGNhbmNlbCA9IGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBnbG9iYWwud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZ2xvYmFsLm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGNsZWFyVGltZW91dDtcbiAgaWYgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XG4gICAgcmVxdWVzdCA9IHJlcXVlc3QuYmluZChnbG9iYWwpO1xuICAgIGNhbmNlbCA9IGNhbmNlbC5iaW5kKGdsb2JhbCk7XG4gIH1cbiAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWVzdDtcbiAgZXhwb3J0cy5jYW5jZWwgPSBjYW5jZWw7XG5cbiAgLyoqKi9cbn0sIC8qIDUgKi9cbi8qKiovZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mMihTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBfdHlwZW9mMihvYmopO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBfdHlwZW9mMihvYmopO1xuICB9O1xuICB2YXIgZztcblxuICAvLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuICBnID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KCk7XG4gIHRyeSB7XG4gICAgLy8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG4gICAgZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLCBldmFsKShcInRoaXNcIik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuICAgIGlmICgodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHdpbmRvdykpID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xuICB9XG5cbiAgLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuICAvLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuICAvLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBnO1xuXG4gIC8qKiovXG59XG4vKioqKioqL10pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/scripts/modules/conditionize.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./assets/scripts/modules/conditionize.js"]();
/******/ 	
/******/ })()
;