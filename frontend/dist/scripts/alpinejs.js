/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/.pnpm/@vue+reactivity@3.1.5/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vue+reactivity@3.1.5/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \**************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ITERATE_KEY\": function() { return /* binding */ ITERATE_KEY; },\n/* harmony export */   \"computed\": function() { return /* binding */ computed; },\n/* harmony export */   \"customRef\": function() { return /* binding */ customRef; },\n/* harmony export */   \"effect\": function() { return /* binding */ effect; },\n/* harmony export */   \"enableTracking\": function() { return /* binding */ enableTracking; },\n/* harmony export */   \"isProxy\": function() { return /* binding */ isProxy; },\n/* harmony export */   \"isReactive\": function() { return /* binding */ isReactive; },\n/* harmony export */   \"isReadonly\": function() { return /* binding */ isReadonly; },\n/* harmony export */   \"isRef\": function() { return /* binding */ isRef; },\n/* harmony export */   \"markRaw\": function() { return /* binding */ markRaw; },\n/* harmony export */   \"pauseTracking\": function() { return /* binding */ pauseTracking; },\n/* harmony export */   \"proxyRefs\": function() { return /* binding */ proxyRefs; },\n/* harmony export */   \"reactive\": function() { return /* binding */ reactive; },\n/* harmony export */   \"readonly\": function() { return /* binding */ readonly; },\n/* harmony export */   \"ref\": function() { return /* binding */ ref; },\n/* harmony export */   \"resetTracking\": function() { return /* binding */ resetTracking; },\n/* harmony export */   \"shallowReactive\": function() { return /* binding */ shallowReactive; },\n/* harmony export */   \"shallowReadonly\": function() { return /* binding */ shallowReadonly; },\n/* harmony export */   \"shallowRef\": function() { return /* binding */ shallowRef; },\n/* harmony export */   \"stop\": function() { return /* binding */ stop; },\n/* harmony export */   \"toRaw\": function() { return /* binding */ toRaw; },\n/* harmony export */   \"toRef\": function() { return /* binding */ toRef; },\n/* harmony export */   \"toRefs\": function() { return /* binding */ toRefs; },\n/* harmony export */   \"track\": function() { return /* binding */ track; },\n/* harmony export */   \"trigger\": function() { return /* binding */ trigger; },\n/* harmony export */   \"triggerRef\": function() { return /* binding */ triggerRef; },\n/* harmony export */   \"unref\": function() { return /* binding */ unref; }\n/* harmony export */ });\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ \"./node_modules/.pnpm/@vue+shared@3.1.5/node_modules/@vue/shared/dist/shared.esm-bundler.js\");\n\n\nconst targetMap = new WeakMap();\r\nconst effectStack = [];\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol(( true) ? 'iterate' : 0);\r\nconst MAP_KEY_ITERATE_KEY = Symbol(( true) ? 'Map key iterate' : 0);\r\nfunction isEffect(fn) {\r\n    return fn && fn._isEffect === true;\r\n}\r\nfunction effect(fn, options = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ) {\r\n    if (isEffect(fn)) {\r\n        fn = fn.raw;\r\n    }\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) {\r\n        effect();\r\n    }\r\n    return effect;\r\n}\r\nfunction stop(effect) {\r\n    if (effect.active) {\r\n        cleanup(effect);\r\n        if (effect.options.onStop) {\r\n            effect.options.onStop();\r\n        }\r\n        effect.active = false;\r\n    }\r\n}\r\nlet uid = 0;\r\nfunction createReactiveEffect(fn, options) {\r\n    const effect = function reactiveEffect() {\r\n        if (!effect.active) {\r\n            return fn();\r\n        }\r\n        if (!effectStack.includes(effect)) {\r\n            cleanup(effect);\r\n            try {\r\n                enableTracking();\r\n                effectStack.push(effect);\r\n                activeEffect = effect;\r\n                return fn();\r\n            }\r\n            finally {\r\n                effectStack.pop();\r\n                resetTracking();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    effect.id = uid++;\r\n    effect.allowRecurse = !!options.allowRecurse;\r\n    effect._isEffect = true;\r\n    effect.active = true;\r\n    effect.raw = fn;\r\n    effect.deps = [];\r\n    effect.options = options;\r\n    return effect;\r\n}\r\nfunction cleanup(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (!shouldTrack || activeEffect === undefined) {\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if (( true) && activeEffect.options.onTrack) {\r\n            activeEffect.options.onTrack({\r\n                effect: activeEffect,\r\n                target,\r\n                type,\r\n                key\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    const effects = new Set();\r\n    const add = (effectsToAdd) => {\r\n        if (effectsToAdd) {\r\n            effectsToAdd.forEach(effect => {\r\n                if (effect !== activeEffect || effect.allowRecurse) {\r\n                    effects.add(effect);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        depsMap.forEach(add);\r\n    }\r\n    else if (key === 'length' && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                add(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            add(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* ADD */:\r\n                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)) {\r\n                    // new index added to array -> length changes\r\n                    add(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* DELETE */:\r\n                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* SET */:\r\n                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const run = (effect) => {\r\n        if (( true) && effect.options.onTrigger) {\r\n            effect.options.onTrigger({\r\n                effect,\r\n                target,\r\n                key,\r\n                type,\r\n                newValue,\r\n                oldValue,\r\n                oldTarget\r\n            });\r\n        }\r\n        if (effect.options.scheduler) {\r\n            effect.options.scheduler(effect);\r\n        }\r\n        else {\r\n            effect();\r\n        }\r\n    };\r\n    effects.forEach(run);\r\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`__proto__,__v_isRef,__isVue`);\r\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();\r\nfunction createArrayInstrumentations() {\r\n    const instrumentations = {};\r\n    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n        instrumentations[key] = function (...args) {\r\n            const arr = toRaw(this);\r\n            for (let i = 0, l = this.length; i < l; i++) {\r\n                track(arr, \"get\" /* GET */, i + '');\r\n            }\r\n            // we run the method using the original args first (which may be reactive)\r\n            const res = arr[key](...args);\r\n            if (res === -1 || res === false) {\r\n                // if that didn't work, run it again using raw values.\r\n                return arr[key](...args.map(toRaw));\r\n            }\r\n            else {\r\n                return res;\r\n            }\r\n        };\r\n    });\r\n    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n        instrumentations[key] = function (...args) {\r\n            pauseTracking();\r\n            const res = toRaw(this)[key].apply(this, args);\r\n            resetTracking();\r\n            return res;\r\n        };\r\n    });\r\n    return instrumentations;\r\n}\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */ &&\r\n            receiver ===\r\n                (isReadonly\r\n                    ? shallow\r\n                        ? shallowReadonlyMap\r\n                        : readonlyMap\r\n                    : shallow\r\n                        ? shallowReactiveMap\r\n                        : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);\r\n        if (!isReadonly && targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - does not apply for Array + integer key.\r\n            const shouldUnwrap = !targetIsArray || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key);\r\n            return shouldUnwrap ? res.value : res;\r\n        }\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        let oldValue = target[key];\r\n        if (!shallow) {\r\n            value = toRaw(value);\r\n            oldValue = toRaw(oldValue);\r\n            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)\r\n            ? Number(key) < target.length\r\n            : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, value);\r\n            }\r\n            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {\r\n                trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* ITERATE */, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) ? 'length' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((true)) {\r\n            console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((true)) {\r\n            console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toReactive = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? readonly(value) : value;\r\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"get\" /* GET */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n    else if (target !== rawTarget) {\r\n        // #3602 readonly(reactive(Map))\r\n        // ensure that the nested reactive `Map` can do tracking for itself\r\n        target.get(key);\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    if (!hadKey) {\r\n        target.add(value);\r\n        trigger(target, \"add\" /* ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((true)) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, key, value);\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {\r\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((true)) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = ( true)\r\n        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)\r\n            ? new Map(target)\r\n            : new Set(target)\r\n        : 0;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((true)) {\r\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n            console.warn(`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n        }\r\n        return type === \"delete\" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nfunction createInstrumentations() {\r\n    const mutableInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key);\r\n        },\r\n        get size() {\r\n            return size(this);\r\n        },\r\n        has: has$1,\r\n        add,\r\n        set: set$1,\r\n        delete: deleteEntry,\r\n        clear,\r\n        forEach: createForEach(false, false)\r\n    };\r\n    const shallowInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key, false, true);\r\n        },\r\n        get size() {\r\n            return size(this);\r\n        },\r\n        has: has$1,\r\n        add,\r\n        set: set$1,\r\n        delete: deleteEntry,\r\n        clear,\r\n        forEach: createForEach(false, true)\r\n    };\r\n    const readonlyInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key, true);\r\n        },\r\n        get size() {\r\n            return size(this, true);\r\n        },\r\n        has(key) {\r\n            return has$1.call(this, key, true);\r\n        },\r\n        add: createReadonlyMethod(\"add\" /* ADD */),\r\n        set: createReadonlyMethod(\"set\" /* SET */),\r\n        delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n        clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n        forEach: createForEach(true, false)\r\n    };\r\n    const shallowReadonlyInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key, true, true);\r\n        },\r\n        get size() {\r\n            return size(this, true);\r\n        },\r\n        has(key) {\r\n            return has$1.call(this, key, true);\r\n        },\r\n        add: createReadonlyMethod(\"add\" /* ADD */),\r\n        set: createReadonlyMethod(\"set\" /* SET */),\r\n        delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n        clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n        forEach: createForEach(true, true)\r\n    };\r\n    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\n    iteratorMethods.forEach(method => {\r\n        mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n        readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n        shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\r\n    });\r\n    return [\r\n        mutableInstrumentations,\r\n        readonlyInstrumentations,\r\n        shallowInstrumentations,\r\n        shallowReadonlyInstrumentations\r\n    ];\r\n}\r\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? isReadonly\r\n            ? shallowReadonlyInstrumentations\r\n            : shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(false, false)\r\n};\r\nconst shallowCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(false, true)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(true, false)\r\n};\r\nconst shallowReadonlyCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst shallowReactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nconst shallowReadonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (target && target[\"__v_isReadonly\" /* IS_READONLY */]) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\r\n}\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nfunction shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\r\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {\r\n        if ((true)) {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    return ((observed && toRaw(observed[\"__v_raw\" /* RAW */])) || observed);\r\n}\r\nfunction markRaw(value) {\r\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.def)(value, \"__v_skip\" /* SKIP */, true);\r\n    return value;\r\n}\n\nconst convert = (val) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(val) ? reactive(val) : val;\r\nfunction isRef(r) {\r\n    return Boolean(r && r.__v_isRef === true);\r\n}\r\nfunction ref(value) {\r\n    return createRef(value);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nclass RefImpl {\r\n    constructor(value, _shallow = false) {\r\n        this._shallow = _shallow;\r\n        this.__v_isRef = true;\r\n        this._rawValue = _shallow ? value : toRaw(value);\r\n        this._value = _shallow ? value : convert(value);\r\n    }\r\n    get value() {\r\n        track(toRaw(this), \"get\" /* GET */, 'value');\r\n        return this._value;\r\n    }\r\n    set value(newVal) {\r\n        newVal = this._shallow ? newVal : toRaw(newVal);\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(newVal, this._rawValue)) {\r\n            this._rawValue = newVal;\r\n            this._value = this._shallow ? newVal : convert(newVal);\r\n            trigger(toRaw(this), \"set\" /* SET */, 'value', newVal);\r\n        }\r\n    }\r\n}\r\nfunction createRef(rawValue, shallow = false) {\r\n    if (isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    return new RefImpl(rawValue, shallow);\r\n}\r\nfunction triggerRef(ref) {\r\n    trigger(toRaw(ref), \"set\" /* SET */, 'value', ( true) ? ref.value : 0);\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nconst shallowUnwrapHandlers = {\r\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n    set: (target, key, value, receiver) => {\r\n        const oldValue = target[key];\r\n        if (isRef(oldValue) && !isRef(value)) {\r\n            oldValue.value = value;\r\n            return true;\r\n        }\r\n        else {\r\n            return Reflect.set(target, key, value, receiver);\r\n        }\r\n    }\r\n};\r\nfunction proxyRefs(objectWithRefs) {\r\n    return isReactive(objectWithRefs)\r\n        ? objectWithRefs\r\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n}\r\nclass CustomRefImpl {\r\n    constructor(factory) {\r\n        this.__v_isRef = true;\r\n        const { get, set } = factory(() => track(this, \"get\" /* GET */, 'value'), () => trigger(this, \"set\" /* SET */, 'value'));\r\n        this._get = get;\r\n        this._set = set;\r\n    }\r\n    get value() {\r\n        return this._get();\r\n    }\r\n    set value(newVal) {\r\n        this._set(newVal);\r\n    }\r\n}\r\nfunction customRef(factory) {\r\n    return new CustomRefImpl(factory);\r\n}\r\nfunction toRefs(object) {\r\n    if (( true) && !isProxy(object)) {\r\n        console.warn(`toRefs() expects a reactive object but received a plain one.`);\r\n    }\r\n    const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(object) ? new Array(object.length) : {};\r\n    for (const key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nclass ObjectRefImpl {\r\n    constructor(_object, _key) {\r\n        this._object = _object;\r\n        this._key = _key;\r\n        this.__v_isRef = true;\r\n    }\r\n    get value() {\r\n        return this._object[this._key];\r\n    }\r\n    set value(newVal) {\r\n        this._object[this._key] = newVal;\r\n    }\r\n}\r\nfunction toRef(object, key) {\r\n    return isRef(object[key])\r\n        ? object[key]\r\n        : new ObjectRefImpl(object, key);\r\n}\n\nclass ComputedRefImpl {\r\n    constructor(getter, _setter, isReadonly) {\r\n        this._setter = _setter;\r\n        this._dirty = true;\r\n        this.__v_isRef = true;\r\n        this.effect = effect(getter, {\r\n            lazy: true,\r\n            scheduler: () => {\r\n                if (!this._dirty) {\r\n                    this._dirty = true;\r\n                    trigger(toRaw(this), \"set\" /* SET */, 'value');\r\n                }\r\n            }\r\n        });\r\n        this[\"__v_isReadonly\" /* IS_READONLY */] = isReadonly;\r\n    }\r\n    get value() {\r\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n        const self = toRaw(this);\r\n        if (self._dirty) {\r\n            self._value = this.effect();\r\n            self._dirty = false;\r\n        }\r\n        track(self, \"get\" /* GET */, 'value');\r\n        return self._value;\r\n    }\r\n    set value(newValue) {\r\n        this._setter(newValue);\r\n    }\r\n}\r\nfunction computed(getterOrOptions) {\r\n    let getter;\r\n    let setter;\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions)) {\r\n        getter = getterOrOptions;\r\n        setter = ( true)\r\n            ? () => {\r\n                console.warn('Write operation failed: computed value is readonly');\r\n            }\r\n            : 0;\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    return new ComputedRefImpl(getter, setter, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions) || !getterOrOptions.set);\r\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQHZ1ZStyZWFjdGl2aXR5QDMuMS41L25vZGVfbW9kdWxlcy9AdnVlL3JlYWN0aXZpdHkvZGlzdC9yZWFjdGl2aXR5LmVzbS1idW5kbGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNks7O0FBRTdLO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFxQyxnQkFBZ0IsQ0FBRTtBQUNuRixvQ0FBb0MsS0FBcUMsd0JBQXdCLENBQUU7QUFDbkc7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtEQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBcUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FB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U0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtREFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBUztBQUM5QixpQ0FBaUMsTUFBTTtBQUN2QywwQ0FBMEMsaUNBQWlDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMscURBQVE7QUFDakIsYUFBYSxJQUFxQztBQUNsRCwyREFBMkQsZUFBZTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFHO0FBQ1A7QUFDQTs7QUFFQSx5QkFBeUIscURBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVEQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELEtBQXFDLGdCQUFnQixDQUFNO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBcUM7QUFDOUM7QUFDQTtBQUNBLGdCQUFnQixvREFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBVTtBQUNsQjtBQUNBLGtCQUFrQixLQUFxQztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxjQUFjLENBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx1REFBVTtBQUN6RDs7QUFFb1MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW5wcmlzZS1mcm9udGVuZC10b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B2dWUrcmVhY3Rpdml0eUAzLjEuNS9ub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5lc20tYnVuZGxlci5qcz84NmMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVNUFRZX09CSiwgaXNBcnJheSwgaXNNYXAsIGlzSW50ZWdlcktleSwgaXNTeW1ib2wsIGV4dGVuZCwgaGFzT3duLCBpc09iamVjdCwgaGFzQ2hhbmdlZCwgbWFrZU1hcCwgY2FwaXRhbGl6ZSwgdG9SYXdUeXBlLCBkZWYsIGlzRnVuY3Rpb24sIE5PT1AgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IHRhcmdldE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IGVmZmVjdFN0YWNrID0gW107XHJcbmxldCBhY3RpdmVFZmZlY3Q7XHJcbmNvbnN0IElURVJBVEVfS0VZID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdpdGVyYXRlJyA6ICcnKTtcclxuY29uc3QgTUFQX0tFWV9JVEVSQVRFX0tFWSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnTWFwIGtleSBpdGVyYXRlJyA6ICcnKTtcclxuZnVuY3Rpb24gaXNFZmZlY3QoZm4pIHtcclxuICAgIHJldHVybiBmbiAmJiBmbi5faXNFZmZlY3QgPT09IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gZWZmZWN0KGZuLCBvcHRpb25zID0gRU1QVFlfT0JKKSB7XHJcbiAgICBpZiAoaXNFZmZlY3QoZm4pKSB7XHJcbiAgICAgICAgZm4gPSBmbi5yYXc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlZmZlY3QgPSBjcmVhdGVSZWFjdGl2ZUVmZmVjdChmbiwgb3B0aW9ucyk7XHJcbiAgICBpZiAoIW9wdGlvbnMubGF6eSkge1xyXG4gICAgICAgIGVmZmVjdCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVmZmVjdDtcclxufVxyXG5mdW5jdGlvbiBzdG9wKGVmZmVjdCkge1xyXG4gICAgaWYgKGVmZmVjdC5hY3RpdmUpIHtcclxuICAgICAgICBjbGVhbnVwKGVmZmVjdCk7XHJcbiAgICAgICAgaWYgKGVmZmVjdC5vcHRpb25zLm9uU3RvcCkge1xyXG4gICAgICAgICAgICBlZmZlY3Qub3B0aW9ucy5vblN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWZmZWN0LmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbmxldCB1aWQgPSAwO1xyXG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZUVmZmVjdChmbiwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgZWZmZWN0ID0gZnVuY3Rpb24gcmVhY3RpdmVFZmZlY3QoKSB7XHJcbiAgICAgICAgaWYgKCFlZmZlY3QuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWVmZmVjdFN0YWNrLmluY2x1ZGVzKGVmZmVjdCkpIHtcclxuICAgICAgICAgICAgY2xlYW51cChlZmZlY3QpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZW5hYmxlVHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgICAgIGVmZmVjdFN0YWNrLnB1c2goZWZmZWN0KTtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUVmZmVjdCA9IGVmZmVjdDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgZWZmZWN0U3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVFZmZlY3QgPSBlZmZlY3RTdGFja1tlZmZlY3RTdGFjay5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBlZmZlY3QuaWQgPSB1aWQrKztcclxuICAgIGVmZmVjdC5hbGxvd1JlY3Vyc2UgPSAhIW9wdGlvbnMuYWxsb3dSZWN1cnNlO1xyXG4gICAgZWZmZWN0Ll9pc0VmZmVjdCA9IHRydWU7XHJcbiAgICBlZmZlY3QuYWN0aXZlID0gdHJ1ZTtcclxuICAgIGVmZmVjdC5yYXcgPSBmbjtcclxuICAgIGVmZmVjdC5kZXBzID0gW107XHJcbiAgICBlZmZlY3Qub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICByZXR1cm4gZWZmZWN0O1xyXG59XHJcbmZ1bmN0aW9uIGNsZWFudXAoZWZmZWN0KSB7XHJcbiAgICBjb25zdCB7IGRlcHMgfSA9IGVmZmVjdDtcclxuICAgIGlmIChkZXBzLmxlbmd0aCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkZXBzW2ldLmRlbGV0ZShlZmZlY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXBzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbn1cclxubGV0IHNob3VsZFRyYWNrID0gdHJ1ZTtcclxuY29uc3QgdHJhY2tTdGFjayA9IFtdO1xyXG5mdW5jdGlvbiBwYXVzZVRyYWNraW5nKCkge1xyXG4gICAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcclxuICAgIHNob3VsZFRyYWNrID0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gZW5hYmxlVHJhY2tpbmcoKSB7XHJcbiAgICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xyXG4gICAgc2hvdWxkVHJhY2sgPSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHJlc2V0VHJhY2tpbmcoKSB7XHJcbiAgICBjb25zdCBsYXN0ID0gdHJhY2tTdGFjay5wb3AoKTtcclxuICAgIHNob3VsZFRyYWNrID0gbGFzdCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGxhc3Q7XHJcbn1cclxuZnVuY3Rpb24gdHJhY2sodGFyZ2V0LCB0eXBlLCBrZXkpIHtcclxuICAgIGlmICghc2hvdWxkVHJhY2sgfHwgYWN0aXZlRWZmZWN0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcclxuICAgIGlmICghZGVwc01hcCkge1xyXG4gICAgICAgIHRhcmdldE1hcC5zZXQodGFyZ2V0LCAoZGVwc01hcCA9IG5ldyBNYXAoKSkpO1xyXG4gICAgfVxyXG4gICAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XHJcbiAgICBpZiAoIWRlcCkge1xyXG4gICAgICAgIGRlcHNNYXAuc2V0KGtleSwgKGRlcCA9IG5ldyBTZXQoKSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFkZXAuaGFzKGFjdGl2ZUVmZmVjdCkpIHtcclxuICAgICAgICBkZXAuYWRkKGFjdGl2ZUVmZmVjdCk7XHJcbiAgICAgICAgYWN0aXZlRWZmZWN0LmRlcHMucHVzaChkZXApO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgYWN0aXZlRWZmZWN0Lm9wdGlvbnMub25UcmFjaykge1xyXG4gICAgICAgICAgICBhY3RpdmVFZmZlY3Qub3B0aW9ucy5vblRyYWNrKHtcclxuICAgICAgICAgICAgICAgIGVmZmVjdDogYWN0aXZlRWZmZWN0LFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgIGtleVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJpZ2dlcih0YXJnZXQsIHR5cGUsIGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvbGRUYXJnZXQpIHtcclxuICAgIGNvbnN0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XHJcbiAgICBpZiAoIWRlcHNNYXApIHtcclxuICAgICAgICAvLyBuZXZlciBiZWVuIHRyYWNrZWRcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBlZmZlY3RzID0gbmV3IFNldCgpO1xyXG4gICAgY29uc3QgYWRkID0gKGVmZmVjdHNUb0FkZCkgPT4ge1xyXG4gICAgICAgIGlmIChlZmZlY3RzVG9BZGQpIHtcclxuICAgICAgICAgICAgZWZmZWN0c1RvQWRkLmZvckVhY2goZWZmZWN0ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QgIT09IGFjdGl2ZUVmZmVjdCB8fCBlZmZlY3QuYWxsb3dSZWN1cnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0cy5hZGQoZWZmZWN0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGlmICh0eXBlID09PSBcImNsZWFyXCIgLyogQ0xFQVIgKi8pIHtcclxuICAgICAgICAvLyBjb2xsZWN0aW9uIGJlaW5nIGNsZWFyZWRcclxuICAgICAgICAvLyB0cmlnZ2VyIGFsbCBlZmZlY3RzIGZvciB0YXJnZXRcclxuICAgICAgICBkZXBzTWFwLmZvckVhY2goYWRkKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGtleSA9PT0gJ2xlbmd0aCcgJiYgaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgZGVwc01hcC5mb3JFYWNoKChkZXAsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnbGVuZ3RoJyB8fCBrZXkgPj0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGFkZChkZXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBzY2hlZHVsZSBydW5zIGZvciBTRVQgfCBBREQgfCBERUxFVEVcclxuICAgICAgICBpZiAoa2V5ICE9PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KGtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhbHNvIHJ1biBmb3IgaXRlcmF0aW9uIGtleSBvbiBBREQgfCBERUxFVEUgfCBNYXAuU0VUXHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJhZGRcIiAvKiBBREQgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNJbnRlZ2VyS2V5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBuZXcgaW5kZXggYWRkZWQgdG8gYXJyYXkgLT4gbGVuZ3RoIGNoYW5nZXNcclxuICAgICAgICAgICAgICAgICAgICBhZGQoZGVwc01hcC5nZXQoJ2xlbmd0aCcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZGVsZXRlXCIgLyogREVMRVRFICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGQoZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGQoZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwic2V0XCIgLyogU0VUICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGQoZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHJ1biA9IChlZmZlY3QpID0+IHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGVmZmVjdC5vcHRpb25zLm9uVHJpZ2dlcikge1xyXG4gICAgICAgICAgICBlZmZlY3Qub3B0aW9ucy5vblRyaWdnZXIoe1xyXG4gICAgICAgICAgICAgICAgZWZmZWN0LFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUsXHJcbiAgICAgICAgICAgICAgICBvbGRUYXJnZXRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlZmZlY3Qub3B0aW9ucy5zY2hlZHVsZXIpIHtcclxuICAgICAgICAgICAgZWZmZWN0Lm9wdGlvbnMuc2NoZWR1bGVyKGVmZmVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlZmZlY3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZWZmZWN0cy5mb3JFYWNoKHJ1bik7XHJcbn1cblxuY29uc3QgaXNOb25UcmFja2FibGVLZXlzID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBfX3Byb3RvX18sX192X2lzUmVmLF9faXNWdWVgKTtcclxuY29uc3QgYnVpbHRJblN5bWJvbHMgPSBuZXcgU2V0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFN5bWJvbClcclxuICAgIC5tYXAoa2V5ID0+IFN5bWJvbFtrZXldKVxyXG4gICAgLmZpbHRlcihpc1N5bWJvbCkpO1xyXG5jb25zdCBnZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcigpO1xyXG5jb25zdCBzaGFsbG93R2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIoZmFsc2UsIHRydWUpO1xyXG5jb25zdCByZWFkb25seUdldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKHRydWUpO1xyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlHZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcih0cnVlLCB0cnVlKTtcclxuY29uc3QgYXJyYXlJbnN0cnVtZW50YXRpb25zID0gLyojX19QVVJFX18qLyBjcmVhdGVBcnJheUluc3RydW1lbnRhdGlvbnMoKTtcclxuZnVuY3Rpb24gY3JlYXRlQXJyYXlJbnN0cnVtZW50YXRpb25zKCkge1xyXG4gICAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IHt9O1xyXG4gICAgWydpbmNsdWRlcycsICdpbmRleE9mJywgJ2xhc3RJbmRleE9mJ10uZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIGluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IHRvUmF3KHRoaXMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjayhhcnIsIFwiZ2V0XCIgLyogR0VUICovLCBpICsgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHdlIHJ1biB0aGUgbWV0aG9kIHVzaW5nIHRoZSBvcmlnaW5hbCBhcmdzIGZpcnN0ICh3aGljaCBtYXkgYmUgcmVhY3RpdmUpXHJcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGFycltrZXldKC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICBpZiAocmVzID09PSAtMSB8fCByZXMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGF0IGRpZG4ndCB3b3JrLCBydW4gaXQgYWdhaW4gdXNpbmcgcmF3IHZhbHVlcy5cclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJba2V5XSguLi5hcmdzLm1hcCh0b1JhdykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAndW5zaGlmdCcsICdzcGxpY2UnXS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgaW5zdHJ1bWVudGF0aW9uc1trZXldID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSB0b1Jhdyh0aGlzKVtrZXldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbnM7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlR2V0dGVyKGlzUmVhZG9ubHkgPSBmYWxzZSwgc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikge1xyXG4gICAgICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiIC8qIFJBVyAqLyAmJlxyXG4gICAgICAgICAgICByZWNlaXZlciA9PT1cclxuICAgICAgICAgICAgICAgIChpc1JlYWRvbmx5XHJcbiAgICAgICAgICAgICAgICAgICAgPyBzaGFsbG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2hhbGxvd1JlYWRvbmx5TWFwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVhZG9ubHlNYXBcclxuICAgICAgICAgICAgICAgICAgICA6IHNoYWxsb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzaGFsbG93UmVhY3RpdmVNYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZWFjdGl2ZU1hcCkuZ2V0KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SXNBcnJheSA9IGlzQXJyYXkodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIWlzUmVhZG9ubHkgJiYgdGFyZ2V0SXNBcnJheSAmJiBoYXNPd24oYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldChhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIGlmIChpc1N5bWJvbChrZXkpID8gYnVpbHRJblN5bWJvbHMuaGFzKGtleSkgOiBpc05vblRyYWNrYWJsZUtleXMoa2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzUmVhZG9ubHkpIHtcclxuICAgICAgICAgICAgdHJhY2sodGFyZ2V0LCBcImdldFwiIC8qIEdFVCAqLywga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYWxsb3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzUmVmKHJlcykpIHtcclxuICAgICAgICAgICAgLy8gcmVmIHVud3JhcHBpbmcgLSBkb2VzIG5vdCBhcHBseSBmb3IgQXJyYXkgKyBpbnRlZ2VyIGtleS5cclxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkVW53cmFwID0gIXRhcmdldElzQXJyYXkgfHwgIWlzSW50ZWdlcktleShrZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2hvdWxkVW53cmFwID8gcmVzLnZhbHVlIDogcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHJldHVybmVkIHZhbHVlIGludG8gYSBwcm94eSBhcyB3ZWxsLiB3ZSBkbyB0aGUgaXNPYmplY3QgY2hlY2tcclxuICAgICAgICAgICAgLy8gaGVyZSB0byBhdm9pZCBpbnZhbGlkIHZhbHVlIHdhcm5pbmcuIEFsc28gbmVlZCB0byBsYXp5IGFjY2VzcyByZWFkb25seVxyXG4gICAgICAgICAgICAvLyBhbmQgcmVhY3RpdmUgaGVyZSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5LlxyXG4gICAgICAgICAgICByZXR1cm4gaXNSZWFkb25seSA/IHJlYWRvbmx5KHJlcykgOiByZWFjdGl2ZShyZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBzZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZVNldHRlcigpO1xyXG5jb25zdCBzaGFsbG93U2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVTZXR0ZXIodHJ1ZSk7XHJcbmZ1bmN0aW9uIGNyZWF0ZVNldHRlcihzaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBzZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikge1xyXG4gICAgICAgIGxldCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xyXG4gICAgICAgIGlmICghc2hhbGxvdykge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcclxuICAgICAgICAgICAgb2xkVmFsdWUgPSB0b1JhdyhvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpICYmIGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGFkS2V5ID0gaXNBcnJheSh0YXJnZXQpICYmIGlzSW50ZWdlcktleShrZXkpXHJcbiAgICAgICAgICAgID8gTnVtYmVyKGtleSkgPCB0YXJnZXQubGVuZ3RoXHJcbiAgICAgICAgICAgIDogaGFzT3duKHRhcmdldCwga2V5KTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcclxuICAgICAgICAvLyBkb24ndCB0cmlnZ2VyIGlmIHRhcmdldCBpcyBzb21ldGhpbmcgdXAgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiBvZiBvcmlnaW5hbFxyXG4gICAgICAgIGlmICh0YXJnZXQgPT09IHRvUmF3KHJlY2VpdmVyKSkge1xyXG4gICAgICAgICAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIgLyogQUREICovLCBrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiIC8qIFNFVCAqLywga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XHJcbiAgICBjb25zdCBoYWRLZXkgPSBoYXNPd24odGFyZ2V0LCBrZXkpO1xyXG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKHJlc3VsdCAmJiBoYWRLZXkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiAvKiBERUxFVEUgKi8sIGtleSwgdW5kZWZpbmVkLCBvbGRWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGhhcyh0YXJnZXQsIGtleSkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5oYXModGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKCFpc1N5bWJvbChrZXkpIHx8ICFidWlsdEluU3ltYm9scy5oYXMoa2V5KSkge1xyXG4gICAgICAgIHRyYWNrKHRhcmdldCwgXCJoYXNcIiAvKiBIQVMgKi8sIGtleSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIG93bktleXModGFyZ2V0KSB7XHJcbiAgICB0cmFjayh0YXJnZXQsIFwiaXRlcmF0ZVwiIC8qIElURVJBVEUgKi8sIGlzQXJyYXkodGFyZ2V0KSA/ICdsZW5ndGgnIDogSVRFUkFURV9LRVkpO1xyXG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xyXG59XHJcbmNvbnN0IG11dGFibGVIYW5kbGVycyA9IHtcclxuICAgIGdldCxcclxuICAgIHNldCxcclxuICAgIGRlbGV0ZVByb3BlcnR5LFxyXG4gICAgaGFzLFxyXG4gICAgb3duS2V5c1xyXG59O1xyXG5jb25zdCByZWFkb25seUhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiByZWFkb25seUdldCxcclxuICAgIHNldCh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBTZXQgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRGVsZXRlIG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyA9IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBtdXRhYmxlSGFuZGxlcnMsIHtcclxuICAgIGdldDogc2hhbGxvd0dldCxcclxuICAgIHNldDogc2hhbGxvd1NldFxyXG59KTtcclxuLy8gUHJvcHMgaGFuZGxlcnMgYXJlIHNwZWNpYWwgaW4gdGhlIHNlbnNlIHRoYXQgaXQgc2hvdWxkIG5vdCB1bndyYXAgdG9wLWxldmVsXHJcbi8vIHJlZnMgKGluIG9yZGVyIHRvIGFsbG93IHJlZnMgdG8gYmUgZXhwbGljaXRseSBwYXNzZWQgZG93biksIGJ1dCBzaG91bGRcclxuLy8gcmV0YWluIHRoZSByZWFjdGl2aXR5IG9mIHRoZSBub3JtYWwgcmVhZG9ubHkgb2JqZWN0LlxyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlIYW5kbGVycyA9IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCByZWFkb25seUhhbmRsZXJzLCB7XHJcbiAgICBnZXQ6IHNoYWxsb3dSZWFkb25seUdldFxyXG59KTtcblxuY29uc3QgdG9SZWFjdGl2ZSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhY3RpdmUodmFsdWUpIDogdmFsdWU7XHJcbmNvbnN0IHRvUmVhZG9ubHkgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWRvbmx5KHZhbHVlKSA6IHZhbHVlO1xyXG5jb25zdCB0b1NoYWxsb3cgPSAodmFsdWUpID0+IHZhbHVlO1xyXG5jb25zdCBnZXRQcm90byA9ICh2KSA9PiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHYpO1xyXG5mdW5jdGlvbiBnZXQkMSh0YXJnZXQsIGtleSwgaXNSZWFkb25seSA9IGZhbHNlLCBpc1NoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgLy8gIzE3NzI6IHJlYWRvbmx5KHJlYWN0aXZlKE1hcCkpIHNob3VsZCByZXR1cm4gcmVhZG9ubHkgKyByZWFjdGl2ZSB2ZXJzaW9uXHJcbiAgICAvLyBvZiB0aGUgdmFsdWVcclxuICAgIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XHJcbiAgICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcclxuICAgICAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIgLyogR0VUICovLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiIC8qIEdFVCAqLywgcmF3S2V5KTtcclxuICAgIGNvbnN0IHsgaGFzIH0gPSBnZXRQcm90byhyYXdUYXJnZXQpO1xyXG4gICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcclxuICAgIGlmIChoYXMuY2FsbChyYXdUYXJnZXQsIGtleSkpIHtcclxuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KGtleSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaGFzLmNhbGwocmF3VGFyZ2V0LCByYXdLZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChyYXdLZXkpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRhcmdldCAhPT0gcmF3VGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gIzM2MDIgcmVhZG9ubHkocmVhY3RpdmUoTWFwKSlcclxuICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgbmVzdGVkIHJlYWN0aXZlIGBNYXBgIGNhbiBkbyB0cmFja2luZyBmb3IgaXRzZWxmXHJcbiAgICAgICAgdGFyZ2V0LmdldChrZXkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhcyQxKGtleSwgaXNSZWFkb25seSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcclxuICAgIGlmIChrZXkgIT09IHJhd0tleSkge1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiAvKiBIQVMgKi8sIGtleSk7XHJcbiAgICB9XHJcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIgLyogSEFTICovLCByYXdLZXkpO1xyXG4gICAgcmV0dXJuIGtleSA9PT0gcmF3S2V5XHJcbiAgICAgICAgPyB0YXJnZXQuaGFzKGtleSlcclxuICAgICAgICA6IHRhcmdldC5oYXMoa2V5KSB8fCB0YXJnZXQuaGFzKHJhd0tleSk7XHJcbn1cclxuZnVuY3Rpb24gc2l6ZSh0YXJnZXQsIGlzUmVhZG9ubHkgPSBmYWxzZSkge1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayh0b1Jhdyh0YXJnZXQpLCBcIml0ZXJhdGVcIiAvKiBJVEVSQVRFICovLCBJVEVSQVRFX0tFWSk7XHJcbiAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCAnc2l6ZScsIHRhcmdldCk7XHJcbn1cclxuZnVuY3Rpb24gYWRkKHZhbHVlKSB7XHJcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gICAgY29uc3QgcHJvdG8gPSBnZXRQcm90byh0YXJnZXQpO1xyXG4gICAgY29uc3QgaGFkS2V5ID0gcHJvdG8uaGFzLmNhbGwodGFyZ2V0LCB2YWx1ZSk7XHJcbiAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgIHRhcmdldC5hZGQodmFsdWUpO1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIEFERCAqLywgdmFsdWUsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcbmZ1bmN0aW9uIHNldCQxKGtleSwgdmFsdWUpIHtcclxuICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICBjb25zdCB7IGhhcywgZ2V0IH0gPSBnZXRQcm90byh0YXJnZXQpO1xyXG4gICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcclxuICAgICAgICBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgdGFyZ2V0LnNldChrZXksIHZhbHVlKTtcclxuICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIgLyogQUREICovLCBrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiIC8qIFNFVCAqLywga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuZnVuY3Rpb24gZGVsZXRlRW50cnkoa2V5KSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGNvbnN0IHsgaGFzLCBnZXQgfSA9IGdldFByb3RvKHRhcmdldCk7XHJcbiAgICBsZXQgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQgPyBnZXQuY2FsbCh0YXJnZXQsIGtleSkgOiB1bmRlZmluZWQ7XHJcbiAgICAvLyBmb3J3YXJkIHRoZSBvcGVyYXRpb24gYmVmb3JlIHF1ZXVlaW5nIHJlYWN0aW9uc1xyXG4gICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmRlbGV0ZShrZXkpO1xyXG4gICAgaWYgKGhhZEtleSkge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiIC8qIERFTEVURSAqLywga2V5LCB1bmRlZmluZWQsIG9sZFZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gY2xlYXIoKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGNvbnN0IGhhZEl0ZW1zID0gdGFyZ2V0LnNpemUgIT09IDA7XHJcbiAgICBjb25zdCBvbGRUYXJnZXQgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICA/IGlzTWFwKHRhcmdldClcclxuICAgICAgICAgICAgPyBuZXcgTWFwKHRhcmdldClcclxuICAgICAgICAgICAgOiBuZXcgU2V0KHRhcmdldClcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIC8vIGZvcndhcmQgdGhlIG9wZXJhdGlvbiBiZWZvcmUgcXVldWVpbmcgcmVhY3Rpb25zXHJcbiAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQuY2xlYXIoKTtcclxuICAgIGlmIChoYWRJdGVtcykge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImNsZWFyXCIgLyogQ0xFQVIgKi8sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGRUYXJnZXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVGb3JFYWNoKGlzUmVhZG9ubHksIGlzU2hhbGxvdykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcclxuICAgICAgICBjb25zdCBvYnNlcnZlZCA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gb2JzZXJ2ZWRbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XHJcbiAgICAgICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiAvKiBJVEVSQVRFICovLCBJVEVSQVRFX0tFWSk7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGltcG9ydGFudDogbWFrZSBzdXJlIHRoZSBjYWxsYmFjayBpc1xyXG4gICAgICAgICAgICAvLyAxLiBpbnZva2VkIHdpdGggdGhlIHJlYWN0aXZlIG1hcCBhcyBgdGhpc2AgYW5kIDNyZCBhcmdcclxuICAgICAgICAgICAgLy8gMi4gdGhlIHZhbHVlIHJlY2VpdmVkIHNob3VsZCBiZSBhIGNvcnJlc3BvbmRpbmcgcmVhY3RpdmUvcmVhZG9ubHkuXHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHdyYXAodmFsdWUpLCB3cmFwKGtleSksIG9ic2VydmVkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldElzTWFwID0gaXNNYXAocmF3VGFyZ2V0KTtcclxuICAgICAgICBjb25zdCBpc1BhaXIgPSBtZXRob2QgPT09ICdlbnRyaWVzJyB8fCAobWV0aG9kID09PSBTeW1ib2wuaXRlcmF0b3IgJiYgdGFyZ2V0SXNNYXApO1xyXG4gICAgICAgIGNvbnN0IGlzS2V5T25seSA9IG1ldGhvZCA9PT0gJ2tleXMnICYmIHRhcmdldElzTWFwO1xyXG4gICAgICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0YXJnZXRbbWV0aG9kXSguLi5hcmdzKTtcclxuICAgICAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmXHJcbiAgICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIgLyogSVRFUkFURSAqLywgaXNLZXlPbmx5ID8gTUFQX0tFWV9JVEVSQVRFX0tFWSA6IElURVJBVEVfS0VZKTtcclxuICAgICAgICAvLyByZXR1cm4gYSB3cmFwcGVkIGl0ZXJhdG9yIHdoaWNoIHJldHVybnMgb2JzZXJ2ZWQgdmVyc2lvbnMgb2YgdGhlXHJcbiAgICAgICAgLy8gdmFsdWVzIGVtaXR0ZWQgZnJvbSB0aGUgcmVhbCBpdGVyYXRvclxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdG9yIHByb3RvY29sXHJcbiAgICAgICAgICAgIG5leHQoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgPyB7IHZhbHVlLCBkb25lIH1cclxuICAgICAgICAgICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlzUGFpciA/IFt3cmFwKHZhbHVlWzBdKSwgd3JhcCh2YWx1ZVsxXSldIDogd3JhcCh2YWx1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBpdGVyYWJsZSBwcm90b2NvbFxyXG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVhZG9ubHlNZXRob2QodHlwZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBhcmdzWzBdID8gYG9uIGtleSBcIiR7YXJnc1swXX1cIiBgIDogYGA7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtjYXBpdGFsaXplKHR5cGUpfSBvcGVyYXRpb24gJHtrZXl9ZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdG9SYXcodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJkZWxldGVcIiAvKiBERUxFVEUgKi8gPyBmYWxzZSA6IHRoaXM7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbnMoKSB7XHJcbiAgICBjb25zdCBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICAgICAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaXplKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzOiBoYXMkMSxcclxuICAgICAgICBhZGQsXHJcbiAgICAgICAgc2V0OiBzZXQkMSxcclxuICAgICAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxyXG4gICAgICAgIGNsZWFyLFxyXG4gICAgICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIGZhbHNlKVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zID0ge1xyXG4gICAgICAgIGdldChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaXplKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzOiBoYXMkMSxcclxuICAgICAgICBhZGQsXHJcbiAgICAgICAgc2V0OiBzZXQkMSxcclxuICAgICAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxyXG4gICAgICAgIGNsZWFyLFxyXG4gICAgICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIHRydWUpXHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zID0ge1xyXG4gICAgICAgIGdldChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXMoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoYXMkMS5jYWxsKHRoaXMsIGtleSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIgLyogQUREICovKSxcclxuICAgICAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIgLyogU0VUICovKSxcclxuICAgICAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIgLyogREVMRVRFICovKSxcclxuICAgICAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiIC8qIENMRUFSICovKSxcclxuICAgICAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKHRydWUsIGZhbHNlKVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMgPSB7XHJcbiAgICAgICAgZ2V0KGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCB0cnVlLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhcyhrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhcyQxLmNhbGwodGhpcywga2V5LCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiAvKiBBREQgKi8pLFxyXG4gICAgICAgIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiAvKiBTRVQgKi8pLFxyXG4gICAgICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiAvKiBERUxFVEUgKi8pLFxyXG4gICAgICAgIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIgLyogQ0xFQVIgKi8pLFxyXG4gICAgICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgdHJ1ZSlcclxuICAgIH07XHJcbiAgICBjb25zdCBpdGVyYXRvck1ldGhvZHMgPSBbJ2tleXMnLCAndmFsdWVzJywgJ2VudHJpZXMnLCBTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaXRlcmF0b3JNZXRob2RzLmZvckVhY2gobWV0aG9kID0+IHtcclxuICAgICAgICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICAgIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMsXHJcbiAgICAgICAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zLFxyXG4gICAgICAgIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zLFxyXG4gICAgICAgIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNcclxuICAgIF07XHJcbn1cclxuY29uc3QgW211dGFibGVJbnN0cnVtZW50YXRpb25zLCByZWFkb25seUluc3RydW1lbnRhdGlvbnMsIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zLCBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXSA9IC8qICNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbnMoKTtcclxuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGlzUmVhZG9ubHksIHNoYWxsb3cpIHtcclxuICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSBzaGFsbG93XHJcbiAgICAgICAgPyBpc1JlYWRvbmx5XHJcbiAgICAgICAgICAgID8gc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1xyXG4gICAgICAgICAgICA6IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zXHJcbiAgICAgICAgOiBpc1JlYWRvbmx5XHJcbiAgICAgICAgICAgID8gcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXHJcbiAgICAgICAgICAgIDogbXV0YWJsZUluc3RydW1lbnRhdGlvbnM7XHJcbiAgICByZXR1cm4gKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4ge1xyXG4gICAgICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiIC8qIFJBVyAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoaGFzT3duKGluc3RydW1lbnRhdGlvbnMsIGtleSkgJiYga2V5IGluIHRhcmdldFxyXG4gICAgICAgICAgICA/IGluc3RydW1lbnRhdGlvbnNcclxuICAgICAgICAgICAgOiB0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiAvKiNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgZmFsc2UpXHJcbn07XHJcbmNvbnN0IHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IC8qI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCB0cnVlKVxyXG59O1xyXG5jb25zdCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcclxuICAgIGdldDogLyojX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgZmFsc2UpXHJcbn07XHJcbmNvbnN0IHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcclxuICAgIGdldDogLyojX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgdHJ1ZSlcclxufTtcclxuZnVuY3Rpb24gY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSkge1xyXG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcclxuICAgIGlmIChyYXdLZXkgIT09IGtleSAmJiBoYXMuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gdG9SYXdUeXBlKHRhcmdldCk7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBSZWFjdGl2ZSAke3R5cGV9IGNvbnRhaW5zIGJvdGggdGhlIHJhdyBhbmQgcmVhY3RpdmUgYCArXHJcbiAgICAgICAgICAgIGB2ZXJzaW9ucyBvZiB0aGUgc2FtZSBvYmplY3Qke3R5cGUgPT09IGBNYXBgID8gYCBhcyBrZXlzYCA6IGBgfSwgYCArXHJcbiAgICAgICAgICAgIGB3aGljaCBjYW4gbGVhZCB0byBpbmNvbnNpc3RlbmNpZXMuIGAgK1xyXG4gICAgICAgICAgICBgQXZvaWQgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgYCArXHJcbiAgICAgICAgICAgIGBvZiBhbiBvYmplY3QgYW5kIG9ubHkgdXNlIHRoZSByZWFjdGl2ZSB2ZXJzaW9uIGlmIHBvc3NpYmxlLmApO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHJlYWN0aXZlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3Qgc2hhbGxvd1JlYWN0aXZlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3QgcmVhZG9ubHlNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5mdW5jdGlvbiB0YXJnZXRUeXBlTWFwKHJhd1R5cGUpIHtcclxuICAgIHN3aXRjaCAocmF3VHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ09iamVjdCc6XHJcbiAgICAgICAgY2FzZSAnQXJyYXknOlxyXG4gICAgICAgICAgICByZXR1cm4gMSAvKiBDT01NT04gKi87XHJcbiAgICAgICAgY2FzZSAnTWFwJzpcclxuICAgICAgICBjYXNlICdTZXQnOlxyXG4gICAgICAgIGNhc2UgJ1dlYWtNYXAnOlxyXG4gICAgICAgIGNhc2UgJ1dlYWtTZXQnOlxyXG4gICAgICAgICAgICByZXR1cm4gMiAvKiBDT0xMRUNUSU9OICovO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiAwIC8qIElOVkFMSUQgKi87XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0VGFyZ2V0VHlwZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlW1wiX192X3NraXBcIiAvKiBTS0lQICovXSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSlcclxuICAgICAgICA/IDAgLyogSU5WQUxJRCAqL1xyXG4gICAgICAgIDogdGFyZ2V0VHlwZU1hcCh0b1Jhd1R5cGUodmFsdWUpKTtcclxufVxyXG5mdW5jdGlvbiByZWFjdGl2ZSh0YXJnZXQpIHtcclxuICAgIC8vIGlmIHRyeWluZyB0byBvYnNlcnZlIGEgcmVhZG9ubHkgcHJveHksIHJldHVybiB0aGUgcmVhZG9ubHkgdmVyc2lvbi5cclxuICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0W1wiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqL10pIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgZmFsc2UsIG11dGFibGVIYW5kbGVycywgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycywgcmVhY3RpdmVNYXApO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBzaGFsbG93bHktcmVhY3RpdmUgY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LCB3aGVyZSBvbmx5IHRoZSByb290XHJcbiAqIGxldmVsIHByb3BlcnRpZXMgYXJlIHJlYWN0aXZlLiBJdCBhbHNvIGRvZXMgbm90IGF1dG8tdW53cmFwIHJlZnMgKGV2ZW4gYXQgdGhlXHJcbiAqIHJvb3QgbGV2ZWwpLlxyXG4gKi9cclxuZnVuY3Rpb24gc2hhbGxvd1JlYWN0aXZlKHRhcmdldCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgZmFsc2UsIHNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzLCBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzLCBzaGFsbG93UmVhY3RpdmVNYXApO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgcmVhZG9ubHkgY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LiBOb3RlIHRoZSByZXR1cm5lZCBjb3B5IGlzIG5vdFxyXG4gKiBtYWRlIHJlYWN0aXZlLCBidXQgYHJlYWRvbmx5YCBjYW4gYmUgY2FsbGVkIG9uIGFuIGFscmVhZHkgcmVhY3RpdmUgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCB0cnVlLCByZWFkb25seUhhbmRsZXJzLCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycywgcmVhZG9ubHlNYXApO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcmVhY3RpdmUtY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LCB3aGVyZSBvbmx5IHRoZSByb290IGxldmVsXHJcbiAqIHByb3BlcnRpZXMgYXJlIHJlYWRvbmx5LCBhbmQgZG9lcyBOT1QgdW53cmFwIHJlZnMgbm9yIHJlY3Vyc2l2ZWx5IGNvbnZlcnRcclxuICogcmV0dXJuZWQgcHJvcGVydGllcy5cclxuICogVGhpcyBpcyB1c2VkIGZvciBjcmVhdGluZyB0aGUgcHJvcHMgcHJveHkgb2JqZWN0IGZvciBzdGF0ZWZ1bCBjb21wb25lbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gc2hhbGxvd1JlYWRvbmx5KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMsIHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycywgc2hhbGxvd1JlYWRvbmx5TWFwKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGlzUmVhZG9ubHksIGJhc2VIYW5kbGVycywgY29sbGVjdGlvbkhhbmRsZXJzLCBwcm94eU1hcCkge1xyXG4gICAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHZhbHVlIGNhbm5vdCBiZSBtYWRlIHJlYWN0aXZlOiAke1N0cmluZyh0YXJnZXQpfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLy8gdGFyZ2V0IGlzIGFscmVhZHkgYSBQcm94eSwgcmV0dXJuIGl0LlxyXG4gICAgLy8gZXhjZXB0aW9uOiBjYWxsaW5nIHJlYWRvbmx5KCkgb24gYSByZWFjdGl2ZSBvYmplY3RcclxuICAgIGlmICh0YXJnZXRbXCJfX3ZfcmF3XCIgLyogUkFXICovXSAmJlxyXG4gICAgICAgICEoaXNSZWFkb25seSAmJiB0YXJnZXRbXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIElTX1JFQUNUSVZFICovXSkpIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLy8gdGFyZ2V0IGFscmVhZHkgaGFzIGNvcnJlc3BvbmRpbmcgUHJveHlcclxuICAgIGNvbnN0IGV4aXN0aW5nUHJveHkgPSBwcm94eU1hcC5nZXQodGFyZ2V0KTtcclxuICAgIGlmIChleGlzdGluZ1Byb3h5KSB7XHJcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nUHJveHk7XHJcbiAgICB9XHJcbiAgICAvLyBvbmx5IGEgd2hpdGVsaXN0IG9mIHZhbHVlIHR5cGVzIGNhbiBiZSBvYnNlcnZlZC5cclxuICAgIGNvbnN0IHRhcmdldFR5cGUgPSBnZXRUYXJnZXRUeXBlKHRhcmdldCk7XHJcbiAgICBpZiAodGFyZ2V0VHlwZSA9PT0gMCAvKiBJTlZBTElEICovKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHRhcmdldCwgdGFyZ2V0VHlwZSA9PT0gMiAvKiBDT0xMRUNUSU9OICovID8gY29sbGVjdGlvbkhhbmRsZXJzIDogYmFzZUhhbmRsZXJzKTtcclxuICAgIHByb3h5TWFwLnNldCh0YXJnZXQsIHByb3h5KTtcclxuICAgIHJldHVybiBwcm94eTtcclxufVxyXG5mdW5jdGlvbiBpc1JlYWN0aXZlKHZhbHVlKSB7XHJcbiAgICBpZiAoaXNSZWFkb25seSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZVtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dKTtcclxuICAgIH1cclxuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWN0aXZlXCIgLyogSVNfUkVBQ1RJVkUgKi9dKTtcclxufVxyXG5mdW5jdGlvbiBpc1JlYWRvbmx5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovXSk7XHJcbn1cclxuZnVuY3Rpb24gaXNQcm94eSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWUpIHx8IGlzUmVhZG9ubHkodmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIHRvUmF3KG9ic2VydmVkKSB7XHJcbiAgICByZXR1cm4gKChvYnNlcnZlZCAmJiB0b1JhdyhvYnNlcnZlZFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dKSkgfHwgb2JzZXJ2ZWQpO1xyXG59XHJcbmZ1bmN0aW9uIG1hcmtSYXcodmFsdWUpIHtcclxuICAgIGRlZih2YWx1ZSwgXCJfX3Zfc2tpcFwiIC8qIFNLSVAgKi8sIHRydWUpO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XG5cbmNvbnN0IGNvbnZlcnQgPSAodmFsKSA9PiBpc09iamVjdCh2YWwpID8gcmVhY3RpdmUodmFsKSA6IHZhbDtcclxuZnVuY3Rpb24gaXNSZWYocikge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4ociAmJiByLl9fdl9pc1JlZiA9PT0gdHJ1ZSk7XHJcbn1cclxuZnVuY3Rpb24gcmVmKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiBzaGFsbG93UmVmKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCB0cnVlKTtcclxufVxyXG5jbGFzcyBSZWZJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBfc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICAgICAgdGhpcy5fc2hhbGxvdyA9IF9zaGFsbG93O1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9yYXdWYWx1ZSA9IF9zaGFsbG93ID8gdmFsdWUgOiB0b1Jhdyh2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfc2hhbGxvdyA/IHZhbHVlIDogY29udmVydCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgdHJhY2sodG9SYXcodGhpcyksIFwiZ2V0XCIgLyogR0VUICovLCAndmFsdWUnKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICAgICAgbmV3VmFsID0gdGhpcy5fc2hhbGxvdyA/IG5ld1ZhbCA6IHRvUmF3KG5ld1ZhbCk7XHJcbiAgICAgICAgaWYgKGhhc0NoYW5nZWQobmV3VmFsLCB0aGlzLl9yYXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmF3VmFsdWUgPSBuZXdWYWw7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5fc2hhbGxvdyA/IG5ld1ZhbCA6IGNvbnZlcnQobmV3VmFsKTtcclxuICAgICAgICAgICAgdHJpZ2dlcih0b1Jhdyh0aGlzKSwgXCJzZXRcIiAvKiBTRVQgKi8sICd2YWx1ZScsIG5ld1ZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlZihyYXdWYWx1ZSwgc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhd1ZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBSZWZJbXBsKHJhd1ZhbHVlLCBzaGFsbG93KTtcclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyUmVmKHJlZikge1xyXG4gICAgdHJpZ2dlcih0b1JhdyhyZWYpLCBcInNldFwiIC8qIFNFVCAqLywgJ3ZhbHVlJywgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gcmVmLnZhbHVlIDogdm9pZCAwKTtcclxufVxyXG5mdW5jdGlvbiB1bnJlZihyZWYpIHtcclxuICAgIHJldHVybiBpc1JlZihyZWYpID8gcmVmLnZhbHVlIDogcmVmO1xyXG59XHJcbmNvbnN0IHNoYWxsb3dVbndyYXBIYW5kbGVycyA9IHtcclxuICAgIGdldDogKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4gdW5yZWYoUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSksXHJcbiAgICBzZXQ6ICh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcclxuICAgICAgICBpZiAoaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBwcm94eVJlZnMob2JqZWN0V2l0aFJlZnMpIHtcclxuICAgIHJldHVybiBpc1JlYWN0aXZlKG9iamVjdFdpdGhSZWZzKVxyXG4gICAgICAgID8gb2JqZWN0V2l0aFJlZnNcclxuICAgICAgICA6IG5ldyBQcm94eShvYmplY3RXaXRoUmVmcywgc2hhbGxvd1Vud3JhcEhhbmRsZXJzKTtcclxufVxyXG5jbGFzcyBDdXN0b21SZWZJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGZhY3RvcnkpIHtcclxuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgeyBnZXQsIHNldCB9ID0gZmFjdG9yeSgoKSA9PiB0cmFjayh0aGlzLCBcImdldFwiIC8qIEdFVCAqLywgJ3ZhbHVlJyksICgpID0+IHRyaWdnZXIodGhpcywgXCJzZXRcIiAvKiBTRVQgKi8sICd2YWx1ZScpKTtcclxuICAgICAgICB0aGlzLl9nZXQgPSBnZXQ7XHJcbiAgICAgICAgdGhpcy5fc2V0ID0gc2V0O1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXQoKTtcclxuICAgIH1cclxuICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcclxuICAgICAgICB0aGlzLl9zZXQobmV3VmFsKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjdXN0b21SZWYoZmFjdG9yeSkge1xyXG4gICAgcmV0dXJuIG5ldyBDdXN0b21SZWZJbXBsKGZhY3RvcnkpO1xyXG59XHJcbmZ1bmN0aW9uIHRvUmVmcyhvYmplY3QpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzUHJveHkob2JqZWN0KSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgdG9SZWZzKCkgZXhwZWN0cyBhIHJlYWN0aXZlIG9iamVjdCBidXQgcmVjZWl2ZWQgYSBwbGFpbiBvbmUuYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXQgPSBpc0FycmF5KG9iamVjdCkgPyBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCkgOiB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xyXG4gICAgICAgIHJldFtrZXldID0gdG9SZWYob2JqZWN0LCBrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5jbGFzcyBPYmplY3RSZWZJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKF9vYmplY3QsIF9rZXkpIHtcclxuICAgICAgICB0aGlzLl9vYmplY3QgPSBfb2JqZWN0O1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XTtcclxuICAgIH1cclxuICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcclxuICAgICAgICB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XSA9IG5ld1ZhbDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0b1JlZihvYmplY3QsIGtleSkge1xyXG4gICAgcmV0dXJuIGlzUmVmKG9iamVjdFtrZXldKVxyXG4gICAgICAgID8gb2JqZWN0W2tleV1cclxuICAgICAgICA6IG5ldyBPYmplY3RSZWZJbXBsKG9iamVjdCwga2V5KTtcclxufVxuXG5jbGFzcyBDb21wdXRlZFJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoZ2V0dGVyLCBfc2V0dGVyLCBpc1JlYWRvbmx5KSB7XHJcbiAgICAgICAgdGhpcy5fc2V0dGVyID0gX3NldHRlcjtcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZWZmZWN0ID0gZWZmZWN0KGdldHRlciwge1xyXG4gICAgICAgICAgICBsYXp5OiB0cnVlLFxyXG4gICAgICAgICAgICBzY2hlZHVsZXI6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGlydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcih0b1Jhdyh0aGlzKSwgXCJzZXRcIiAvKiBTRVQgKi8sICd2YWx1ZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCIgLyogSVNfUkVBRE9OTFkgKi9dID0gaXNSZWFkb25seTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICAvLyB0aGUgY29tcHV0ZWQgcmVmIG1heSBnZXQgd3JhcHBlZCBieSBvdGhlciBwcm94aWVzIGUuZy4gcmVhZG9ubHkoKSAjMzM3NlxyXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0b1Jhdyh0aGlzKTtcclxuICAgICAgICBpZiAoc2VsZi5fZGlydHkpIHtcclxuICAgICAgICAgICAgc2VsZi5fdmFsdWUgPSB0aGlzLmVmZmVjdCgpO1xyXG4gICAgICAgICAgICBzZWxmLl9kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmFjayhzZWxmLCBcImdldFwiIC8qIEdFVCAqLywgJ3ZhbHVlJyk7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYuX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0dGVyKG5ld1ZhbHVlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMpIHtcclxuICAgIGxldCBnZXR0ZXI7XHJcbiAgICBsZXQgc2V0dGVyO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oZ2V0dGVyT3JPcHRpb25zKSkge1xyXG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucztcclxuICAgICAgICBzZXR0ZXIgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgPyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHZhbHVlIGlzIHJlYWRvbmx5Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBOT09QO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLmdldDtcclxuICAgICAgICBzZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuc2V0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBDb21wdXRlZFJlZkltcGwoZ2V0dGVyLCBzZXR0ZXIsIGlzRnVuY3Rpb24oZ2V0dGVyT3JPcHRpb25zKSB8fCAhZ2V0dGVyT3JPcHRpb25zLnNldCk7XHJcbn1cblxuZXhwb3J0IHsgSVRFUkFURV9LRVksIGNvbXB1dGVkLCBjdXN0b21SZWYsIGVmZmVjdCwgZW5hYmxlVHJhY2tpbmcsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBtYXJrUmF3LCBwYXVzZVRyYWNraW5nLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCByZXNldFRyYWNraW5nLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRyYWNrLCB0cmlnZ2VyLCB0cmlnZ2VyUmVmLCB1bnJlZiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@vue+reactivity@3.1.5/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\n");

/***/ }),

/***/ "./node_modules/.pnpm/@vue+shared@3.1.5/node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@vue+shared@3.1.5/node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EMPTY_ARR\": function() { return /* binding */ EMPTY_ARR; },\n/* harmony export */   \"EMPTY_OBJ\": function() { return /* binding */ EMPTY_OBJ; },\n/* harmony export */   \"NO\": function() { return /* binding */ NO; },\n/* harmony export */   \"NOOP\": function() { return /* binding */ NOOP; },\n/* harmony export */   \"PatchFlagNames\": function() { return /* binding */ PatchFlagNames; },\n/* harmony export */   \"babelParserDefaultPlugins\": function() { return /* binding */ babelParserDefaultPlugins; },\n/* harmony export */   \"camelize\": function() { return /* binding */ camelize; },\n/* harmony export */   \"capitalize\": function() { return /* binding */ capitalize; },\n/* harmony export */   \"def\": function() { return /* binding */ def; },\n/* harmony export */   \"escapeHtml\": function() { return /* binding */ escapeHtml; },\n/* harmony export */   \"escapeHtmlComment\": function() { return /* binding */ escapeHtmlComment; },\n/* harmony export */   \"extend\": function() { return /* binding */ extend; },\n/* harmony export */   \"generateCodeFrame\": function() { return /* binding */ generateCodeFrame; },\n/* harmony export */   \"getGlobalThis\": function() { return /* binding */ getGlobalThis; },\n/* harmony export */   \"hasChanged\": function() { return /* binding */ hasChanged; },\n/* harmony export */   \"hasOwn\": function() { return /* binding */ hasOwn; },\n/* harmony export */   \"hyphenate\": function() { return /* binding */ hyphenate; },\n/* harmony export */   \"invokeArrayFns\": function() { return /* binding */ invokeArrayFns; },\n/* harmony export */   \"isArray\": function() { return /* binding */ isArray; },\n/* harmony export */   \"isBooleanAttr\": function() { return /* binding */ isBooleanAttr; },\n/* harmony export */   \"isDate\": function() { return /* binding */ isDate; },\n/* harmony export */   \"isFunction\": function() { return /* binding */ isFunction; },\n/* harmony export */   \"isGloballyWhitelisted\": function() { return /* binding */ isGloballyWhitelisted; },\n/* harmony export */   \"isHTMLTag\": function() { return /* binding */ isHTMLTag; },\n/* harmony export */   \"isIntegerKey\": function() { return /* binding */ isIntegerKey; },\n/* harmony export */   \"isKnownAttr\": function() { return /* binding */ isKnownAttr; },\n/* harmony export */   \"isMap\": function() { return /* binding */ isMap; },\n/* harmony export */   \"isModelListener\": function() { return /* binding */ isModelListener; },\n/* harmony export */   \"isNoUnitNumericStyleProp\": function() { return /* binding */ isNoUnitNumericStyleProp; },\n/* harmony export */   \"isObject\": function() { return /* binding */ isObject; },\n/* harmony export */   \"isOn\": function() { return /* binding */ isOn; },\n/* harmony export */   \"isPlainObject\": function() { return /* binding */ isPlainObject; },\n/* harmony export */   \"isPromise\": function() { return /* binding */ isPromise; },\n/* harmony export */   \"isReservedProp\": function() { return /* binding */ isReservedProp; },\n/* harmony export */   \"isSSRSafeAttrName\": function() { return /* binding */ isSSRSafeAttrName; },\n/* harmony export */   \"isSVGTag\": function() { return /* binding */ isSVGTag; },\n/* harmony export */   \"isSet\": function() { return /* binding */ isSet; },\n/* harmony export */   \"isSpecialBooleanAttr\": function() { return /* binding */ isSpecialBooleanAttr; },\n/* harmony export */   \"isString\": function() { return /* binding */ isString; },\n/* harmony export */   \"isSymbol\": function() { return /* binding */ isSymbol; },\n/* harmony export */   \"isVoidTag\": function() { return /* binding */ isVoidTag; },\n/* harmony export */   \"looseEqual\": function() { return /* binding */ looseEqual; },\n/* harmony export */   \"looseIndexOf\": function() { return /* binding */ looseIndexOf; },\n/* harmony export */   \"makeMap\": function() { return /* binding */ makeMap; },\n/* harmony export */   \"normalizeClass\": function() { return /* binding */ normalizeClass; },\n/* harmony export */   \"normalizeStyle\": function() { return /* binding */ normalizeStyle; },\n/* harmony export */   \"objectToString\": function() { return /* binding */ objectToString; },\n/* harmony export */   \"parseStringStyle\": function() { return /* binding */ parseStringStyle; },\n/* harmony export */   \"propsToAttrMap\": function() { return /* binding */ propsToAttrMap; },\n/* harmony export */   \"remove\": function() { return /* binding */ remove; },\n/* harmony export */   \"slotFlagsText\": function() { return /* binding */ slotFlagsText; },\n/* harmony export */   \"stringifyStyle\": function() { return /* binding */ stringifyStyle; },\n/* harmony export */   \"toDisplayString\": function() { return /* binding */ toDisplayString; },\n/* harmony export */   \"toHandlerKey\": function() { return /* binding */ toHandlerKey; },\n/* harmony export */   \"toNumber\": function() { return /* binding */ toNumber; },\n/* harmony export */   \"toRawType\": function() { return /* binding */ toRawType; },\n/* harmony export */   \"toTypeString\": function() { return /* binding */ toTypeString; }\n/* harmony export */ });\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\n/**\r\n * dev only flag -> name mapping\r\n */\r\nconst PatchFlagNames = {\r\n    [1 /* TEXT */]: `TEXT`,\r\n    [2 /* CLASS */]: `CLASS`,\r\n    [4 /* STYLE */]: `STYLE`,\r\n    [8 /* PROPS */]: `PROPS`,\r\n    [16 /* FULL_PROPS */]: `FULL_PROPS`,\r\n    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\r\n    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\r\n    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\r\n    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\r\n    [512 /* NEED_PATCH */]: `NEED_PATCH`,\r\n    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\r\n    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\r\n    [-1 /* HOISTED */]: `HOISTED`,\r\n    [-2 /* BAIL */]: `BAIL`\r\n};\n\n/**\r\n * Dev only\r\n */\r\nconst slotFlagsText = {\r\n    [1 /* STABLE */]: 'STABLE',\r\n    [2 /* DYNAMIC */]: 'DYNAMIC',\r\n    [3 /* FORWARDED */]: 'FORWARDED'\r\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\r\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\r\nfunction generateCodeFrame(source, start = 0, end = source.length) {\r\n    // Split the content into individual lines but capture the newline sequence\r\n    // that separated each line. This is important because the actual sequence is\r\n    // needed to properly take into account the full line length for offset\r\n    // comparison\r\n    let lines = source.split(/(\\r?\\n)/);\r\n    // Separate the lines and newline sequences into separate arrays for easier referencing\r\n    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\r\n    lines = lines.filter((_, idx) => idx % 2 === 0);\r\n    let count = 0;\r\n    const res = [];\r\n    for (let i = 0; i < lines.length; i++) {\r\n        count +=\r\n            lines[i].length +\r\n                ((newlineSequences[i] && newlineSequences[i].length) || 0);\r\n        if (count >= start) {\r\n            for (let j = i - range; j <= i + range || end > count; j++) {\r\n                if (j < 0 || j >= lines.length)\r\n                    continue;\r\n                const line = j + 1;\r\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\r\n                const lineLength = lines[j].length;\r\n                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;\r\n                if (j === i) {\r\n                    // push underline\r\n                    const pad = start - (count - (lineLength + newLineSeqLength));\r\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\r\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\r\n                }\r\n                else if (j > i) {\r\n                    if (end > count) {\r\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\r\n                        res.push(`   |  ` + '^'.repeat(length));\r\n                    }\r\n                    count += lineLength + newLineSeqLength;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return res.join('\\n');\r\n}\n\n/**\r\n * On the client we only need to offer special cases for boolean attributes that\r\n * have different names from their corresponding dom properties:\r\n * - itemscope -> N/A\r\n * - allowfullscreen -> allowFullscreen\r\n * - formnovalidate -> formNoValidate\r\n * - ismap -> isMap\r\n * - nomodule -> noModule\r\n * - novalidate -> noValidate\r\n * - readonly -> readOnly\r\n */\r\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\r\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\r\n/**\r\n * The full list is needed during SSR to produce the correct initial markup.\r\n */\r\nconst isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +\r\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\r\n    `loop,open,required,reversed,scoped,seamless,` +\r\n    `checked,muted,multiple,selected`);\r\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\r\nconst attrValidationCache = {};\r\nfunction isSSRSafeAttrName(name) {\r\n    if (attrValidationCache.hasOwnProperty(name)) {\r\n        return attrValidationCache[name];\r\n    }\r\n    const isUnsafe = unsafeAttrCharRE.test(name);\r\n    if (isUnsafe) {\r\n        console.error(`unsafe attribute name: ${name}`);\r\n    }\r\n    return (attrValidationCache[name] = !isUnsafe);\r\n}\r\nconst propsToAttrMap = {\r\n    acceptCharset: 'accept-charset',\r\n    className: 'class',\r\n    htmlFor: 'for',\r\n    httpEquiv: 'http-equiv'\r\n};\r\n/**\r\n * CSS properties that accept plain numbers\r\n */\r\nconst isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +\r\n    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +\r\n    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +\r\n    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +\r\n    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +\r\n    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +\r\n    // SVG\r\n    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width`);\r\n/**\r\n * Known attributes, this is used for stringification of runtime static nodes\r\n * so that we don't stringify bindings that cannot be set from HTML.\r\n * Don't also forget to allow `data-*` and `aria-*`!\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\r\n */\r\nconst isKnownAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\r\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\r\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\r\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\r\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\r\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\r\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\r\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\r\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\r\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\r\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\r\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\r\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\r\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\r\n    `value,width,wrap`);\n\nfunction normalizeStyle(value) {\r\n    if (isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst propertyDelimiterRE = /:(.+)/;\r\nfunction parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction stringifyStyle(styles) {\r\n    let ret = '';\r\n    if (!styles) {\r\n        return ret;\r\n    }\r\n    for (const key in styles) {\r\n        const value = styles[key];\r\n        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\r\n        if (isString(value) ||\r\n            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {\r\n            // only render valid values\r\n            ret += `${normalizedKey}:${value};`;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nfunction normalizeClass(value) {\r\n    let res = '';\r\n    if (isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            const normalized = normalizeClass(value[i]);\r\n            if (normalized) {\r\n                res += normalized + ' ';\r\n            }\r\n        }\r\n    }\r\n    else if (isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\r\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n    'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +\r\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n    'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +\r\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n    'option,output,progress,select,textarea,details,dialog,menu,' +\r\n    'summary,template,blockquote,iframe,tfoot';\r\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\r\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\r\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\r\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\r\n    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\r\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\r\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\r\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\r\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\r\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\r\n    'text,textPath,title,tspan,unknown,use,view';\r\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\r\nconst isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\r\nconst isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\r\nconst isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\nconst escapeRE = /[\"'&<>]/;\r\nfunction escapeHtml(string) {\r\n    const str = '' + string;\r\n    const match = escapeRE.exec(str);\r\n    if (!match) {\r\n        return str;\r\n    }\r\n    let html = '';\r\n    let escaped;\r\n    let index;\r\n    let lastIndex = 0;\r\n    for (index = match.index; index < str.length; index++) {\r\n        switch (str.charCodeAt(index)) {\r\n            case 34: // \"\r\n                escaped = '&quot;';\r\n                break;\r\n            case 38: // &\r\n                escaped = '&amp;';\r\n                break;\r\n            case 39: // '\r\n                escaped = '&#39;';\r\n                break;\r\n            case 60: // <\r\n                escaped = '&lt;';\r\n                break;\r\n            case 62: // >\r\n                escaped = '&gt;';\r\n                break;\r\n            default:\r\n                continue;\r\n        }\r\n        if (lastIndex !== index) {\r\n            html += str.substring(lastIndex, index);\r\n        }\r\n        lastIndex = index + 1;\r\n        html += escaped;\r\n    }\r\n    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\r\n}\r\n// https://www.w3.org/TR/html52/syntax.html#comments\r\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\r\nfunction escapeHtmlComment(src) {\r\n    return src.replace(commentStripRE, '');\r\n}\n\nfunction looseCompareArrays(a, b) {\r\n    if (a.length !== b.length)\r\n        return false;\r\n    let equal = true;\r\n    for (let i = 0; equal && i < a.length; i++) {\r\n        equal = looseEqual(a[i], b[i]);\r\n    }\r\n    return equal;\r\n}\r\nfunction looseEqual(a, b) {\r\n    if (a === b)\r\n        return true;\r\n    let aValidType = isDate(a);\r\n    let bValidType = isDate(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\r\n    }\r\n    aValidType = isArray(a);\r\n    bValidType = isArray(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\r\n    }\r\n    aValidType = isObject(a);\r\n    bValidType = isObject(b);\r\n    if (aValidType || bValidType) {\r\n        /* istanbul ignore if: this if will probably never be called */\r\n        if (!aValidType || !bValidType) {\r\n            return false;\r\n        }\r\n        const aKeysCount = Object.keys(a).length;\r\n        const bKeysCount = Object.keys(b).length;\r\n        if (aKeysCount !== bKeysCount) {\r\n            return false;\r\n        }\r\n        for (const key in a) {\r\n            const aHasKey = a.hasOwnProperty(key);\r\n            const bHasKey = b.hasOwnProperty(key);\r\n            if ((aHasKey && !bHasKey) ||\r\n                (!aHasKey && bHasKey) ||\r\n                !looseEqual(a[key], b[key])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return String(a) === String(b);\r\n}\r\nfunction looseIndexOf(arr, val) {\r\n    return arr.findIndex(item => looseEqual(item, val));\r\n}\n\n/**\r\n * For converting {{ interpolation }} values to displayed strings.\r\n * @private\r\n */\r\nconst toDisplayString = (val) => {\r\n    return val == null\r\n        ? ''\r\n        : isObject(val)\r\n            ? JSON.stringify(val, replacer, 2)\r\n            : String(val);\r\n};\r\nconst replacer = (_key, val) => {\r\n    if (isMap(val)) {\r\n        return {\r\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\r\n                entries[`${key} =>`] = val;\r\n                return entries;\r\n            }, {})\r\n        };\r\n    }\r\n    else if (isSet(val)) {\r\n        return {\r\n            [`Set(${val.size})`]: [...val.values()]\r\n        };\r\n    }\r\n    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\r\n        return String(val);\r\n    }\r\n    return val;\r\n};\n\n/**\r\n * List of @babel/parser plugins that are used for template expression\r\n * transforms and SFC script transforms. By default we enable proposals slated\r\n * for ES2020. This will need to be updated as the spec moves forward.\r\n * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins\r\n */\r\nconst babelParserDefaultPlugins = [\r\n    'bigInt',\r\n    'optionalChaining',\r\n    'nullishCoalescingOperator'\r\n];\r\nconst EMPTY_OBJ = ( true)\r\n    ? Object.freeze({})\r\n    : 0;\r\nconst EMPTY_ARR = ( true) ? Object.freeze([]) : 0;\r\nconst NOOP = () => { };\r\n/**\r\n * Always return false.\r\n */\r\nconst NO = () => false;\r\nconst onRE = /^on[^a-z]/;\r\nconst isOn = (key) => onRE.test(key);\r\nconst isModelListener = (key) => key.startsWith('onUpdate:');\r\nconst extend = Object.assign;\r\nconst remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nconst isArray = Array.isArray;\r\nconst isMap = (val) => toTypeString(val) === '[object Map]';\r\nconst isSet = (val) => toTypeString(val) === '[object Set]';\r\nconst isDate = (val) => val instanceof Date;\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst isPromise = (val) => {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst toRawType = (value) => {\r\n    // extract \"RawType\" from strings like \"[object RawType]\"\r\n    return toTypeString(value).slice(8, -1);\r\n};\r\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\r\nconst isIntegerKey = (key) => isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst isReservedProp = /*#__PURE__*/ makeMap(\r\n// the leading comma is intentional so empty string \"\" is also included\r\n',key,ref,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\r\nconst hyphenateRE = /\\B([A-Z])/g;\r\n/**\r\n * @private\r\n */\r\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\r\n/**\r\n * @private\r\n */\r\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n/**\r\n * @private\r\n */\r\nconst toHandlerKey = cacheStringFunction((str) => (str ? `on${capitalize(str)}` : ``));\r\n// compare whether a value has changed, accounting for NaN.\r\nconst hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\r\nconst invokeArrayFns = (fns, arg) => {\r\n    for (let i = 0; i < fns.length; i++) {\r\n        fns[i](arg);\r\n    }\r\n};\r\nconst def = (obj, key, value) => {\r\n    Object.defineProperty(obj, key, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        value\r\n    });\r\n};\r\nconst toNumber = (val) => {\r\n    const n = parseFloat(val);\r\n    return isNaN(n) ? val : n;\r\n};\r\nlet _globalThis;\r\nconst getGlobalThis = () => {\r\n    return (_globalThis ||\r\n        (_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof __webpack_require__.g !== 'undefined'\r\n                            ? __webpack_require__.g\r\n                            : {}));\r\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQHZ1ZStzaGFyZWRAMy4xLjUvbm9kZV9tb2R1bGVzL0B2dWUvc2hhcmVkL2Rpc3Qvc2hhcmVkLmVzbS1idW5kbGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsK0JBQStCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLLEVBQUUsaURBQWlELEtBQUssU0FBUztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBTTtBQUN2Qyw4QkFBOEIscUJBQU07QUFDcEMsZ0NBQWdDO0FBQ2hDOztBQUVvdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW5wcmlzZS1mcm9udGVuZC10b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B2dWUrc2hhcmVkQDMuMS41L25vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qcz9kZWNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcclxuICogaXMgaW4gdGhhdCBtYXAuXHJcbiAqIElNUE9SVEFOVDogYWxsIGNhbGxzIG9mIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBwcmVmaXhlZCB3aXRoXHJcbiAqIFxcL1xcKiNcXF9cXF9QVVJFXFxfXFxfXFwqXFwvXHJcbiAqIFNvIHRoYXQgcm9sbHVwIGNhbiB0cmVlLXNoYWtlIHRoZW0gaWYgbmVjZXNzYXJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZU1hcChzdHIsIGV4cGVjdHNMb3dlckNhc2UpIHtcclxuICAgIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICBjb25zdCBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2UgPyB2YWwgPT4gISFtYXBbdmFsLnRvTG93ZXJDYXNlKCldIDogdmFsID0+ICEhbWFwW3ZhbF07XHJcbn1cblxuLyoqXHJcbiAqIGRldiBvbmx5IGZsYWcgLT4gbmFtZSBtYXBwaW5nXHJcbiAqL1xyXG5jb25zdCBQYXRjaEZsYWdOYW1lcyA9IHtcclxuICAgIFsxIC8qIFRFWFQgKi9dOiBgVEVYVGAsXHJcbiAgICBbMiAvKiBDTEFTUyAqL106IGBDTEFTU2AsXHJcbiAgICBbNCAvKiBTVFlMRSAqL106IGBTVFlMRWAsXHJcbiAgICBbOCAvKiBQUk9QUyAqL106IGBQUk9QU2AsXHJcbiAgICBbMTYgLyogRlVMTF9QUk9QUyAqL106IGBGVUxMX1BST1BTYCxcclxuICAgIFszMiAvKiBIWURSQVRFX0VWRU5UUyAqL106IGBIWURSQVRFX0VWRU5UU2AsXHJcbiAgICBbNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovXTogYFNUQUJMRV9GUkFHTUVOVGAsXHJcbiAgICBbMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovXTogYEtFWUVEX0ZSQUdNRU5UYCxcclxuICAgIFsyNTYgLyogVU5LRVlFRF9GUkFHTUVOVCAqL106IGBVTktFWUVEX0ZSQUdNRU5UYCxcclxuICAgIFs1MTIgLyogTkVFRF9QQVRDSCAqL106IGBORUVEX1BBVENIYCxcclxuICAgIFsxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi9dOiBgRFlOQU1JQ19TTE9UU2AsXHJcbiAgICBbMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqL106IGBERVZfUk9PVF9GUkFHTUVOVGAsXHJcbiAgICBbLTEgLyogSE9JU1RFRCAqL106IGBIT0lTVEVEYCxcclxuICAgIFstMiAvKiBCQUlMICovXTogYEJBSUxgXHJcbn07XG5cbi8qKlxyXG4gKiBEZXYgb25seVxyXG4gKi9cclxuY29uc3Qgc2xvdEZsYWdzVGV4dCA9IHtcclxuICAgIFsxIC8qIFNUQUJMRSAqL106ICdTVEFCTEUnLFxyXG4gICAgWzIgLyogRFlOQU1JQyAqL106ICdEWU5BTUlDJyxcclxuICAgIFszIC8qIEZPUldBUkRFRCAqL106ICdGT1JXQVJERUQnXHJcbn07XG5cbmNvbnN0IEdMT0JBTFNfV0hJVEVfTElTVEVEID0gJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksJyArXHJcbiAgICAnZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSwnICtcclxuICAgICdPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludCc7XHJcbmNvbnN0IGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChHTE9CQUxTX1dISVRFX0xJU1RFRCk7XG5cbmNvbnN0IHJhbmdlID0gMjtcclxuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUoc291cmNlLCBzdGFydCA9IDAsIGVuZCA9IHNvdXJjZS5sZW5ndGgpIHtcclxuICAgIC8vIFNwbGl0IHRoZSBjb250ZW50IGludG8gaW5kaXZpZHVhbCBsaW5lcyBidXQgY2FwdHVyZSB0aGUgbmV3bGluZSBzZXF1ZW5jZVxyXG4gICAgLy8gdGhhdCBzZXBhcmF0ZWQgZWFjaCBsaW5lLiBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSBhY3R1YWwgc2VxdWVuY2UgaXNcclxuICAgIC8vIG5lZWRlZCB0byBwcm9wZXJseSB0YWtlIGludG8gYWNjb3VudCB0aGUgZnVsbCBsaW5lIGxlbmd0aCBmb3Igb2Zmc2V0XHJcbiAgICAvLyBjb21wYXJpc29uXHJcbiAgICBsZXQgbGluZXMgPSBzb3VyY2Uuc3BsaXQoLyhcXHI/XFxuKS8pO1xyXG4gICAgLy8gU2VwYXJhdGUgdGhlIGxpbmVzIGFuZCBuZXdsaW5lIHNlcXVlbmNlcyBpbnRvIHNlcGFyYXRlIGFycmF5cyBmb3IgZWFzaWVyIHJlZmVyZW5jaW5nXHJcbiAgICBjb25zdCBuZXdsaW5lU2VxdWVuY2VzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDEpO1xyXG4gICAgbGluZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMCk7XHJcbiAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgY29uc3QgcmVzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY291bnQgKz1cclxuICAgICAgICAgICAgbGluZXNbaV0ubGVuZ3RoICtcclxuICAgICAgICAgICAgICAgICgobmV3bGluZVNlcXVlbmNlc1tpXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2ldLmxlbmd0aCkgfHwgMCk7XHJcbiAgICAgICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBqICsgMTtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAke2xpbmV9JHsnICcucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcobGluZSkubGVuZ3RoLCAwKSl9fCAgJHtsaW5lc1tqXX1gKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdMaW5lU2VxTGVuZ3RoID0gKG5ld2xpbmVTZXF1ZW5jZXNbal0gJiYgbmV3bGluZVNlcXVlbmNlc1tqXS5sZW5ndGgpIHx8IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSAobGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heCgxLCBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyAnICcucmVwZWF0KHBhZCkgKyAnXicucmVwZWF0KGxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaiA+IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyAnXicucmVwZWF0KGxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzLmpvaW4oJ1xcbicpO1xyXG59XG5cbi8qKlxyXG4gKiBPbiB0aGUgY2xpZW50IHdlIG9ubHkgbmVlZCB0byBvZmZlciBzcGVjaWFsIGNhc2VzIGZvciBib29sZWFuIGF0dHJpYnV0ZXMgdGhhdFxyXG4gKiBoYXZlIGRpZmZlcmVudCBuYW1lcyBmcm9tIHRoZWlyIGNvcnJlc3BvbmRpbmcgZG9tIHByb3BlcnRpZXM6XHJcbiAqIC0gaXRlbXNjb3BlIC0+IE4vQVxyXG4gKiAtIGFsbG93ZnVsbHNjcmVlbiAtPiBhbGxvd0Z1bGxzY3JlZW5cclxuICogLSBmb3Jtbm92YWxpZGF0ZSAtPiBmb3JtTm9WYWxpZGF0ZVxyXG4gKiAtIGlzbWFwIC0+IGlzTWFwXHJcbiAqIC0gbm9tb2R1bGUgLT4gbm9Nb2R1bGVcclxuICogLSBub3ZhbGlkYXRlIC0+IG5vVmFsaWRhdGVcclxuICogLSByZWFkb25seSAtPiByZWFkT25seVxyXG4gKi9cclxuY29uc3Qgc3BlY2lhbEJvb2xlYW5BdHRycyA9IGBpdGVtc2NvcGUsYWxsb3dmdWxsc2NyZWVuLGZvcm1ub3ZhbGlkYXRlLGlzbWFwLG5vbW9kdWxlLG5vdmFsaWRhdGUscmVhZG9ubHlgO1xyXG5jb25zdCBpc1NwZWNpYWxCb29sZWFuQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzKTtcclxuLyoqXHJcbiAqIFRoZSBmdWxsIGxpc3QgaXMgbmVlZGVkIGR1cmluZyBTU1IgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBpbml0aWFsIG1hcmt1cC5cclxuICovXHJcbmNvbnN0IGlzQm9vbGVhbkF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyArXHJcbiAgICBgLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjb250cm9scyxkZWZhdWx0LGRlZmVyLGRpc2FibGVkLGhpZGRlbixgICtcclxuICAgIGBsb29wLG9wZW4scmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLGAgK1xyXG4gICAgYGNoZWNrZWQsbXV0ZWQsbXVsdGlwbGUsc2VsZWN0ZWRgKTtcclxuY29uc3QgdW5zYWZlQXR0ckNoYXJSRSA9IC9bPi89XCInXFx1MDAwOVxcdTAwMGFcXHUwMDBjXFx1MDAyMF0vO1xyXG5jb25zdCBhdHRyVmFsaWRhdGlvbkNhY2hlID0ge307XHJcbmZ1bmN0aW9uIGlzU1NSU2FmZUF0dHJOYW1lKG5hbWUpIHtcclxuICAgIGlmIChhdHRyVmFsaWRhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV07XHJcbiAgICB9XHJcbiAgICBjb25zdCBpc1Vuc2FmZSA9IHVuc2FmZUF0dHJDaGFyUkUudGVzdChuYW1lKTtcclxuICAgIGlmIChpc1Vuc2FmZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYHVuc2FmZSBhdHRyaWJ1dGUgbmFtZTogJHtuYW1lfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdID0gIWlzVW5zYWZlKTtcclxufVxyXG5jb25zdCBwcm9wc1RvQXR0ck1hcCA9IHtcclxuICAgIGFjY2VwdENoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXHJcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXHJcbiAgICBodG1sRm9yOiAnZm9yJyxcclxuICAgIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnXHJcbn07XHJcbi8qKlxyXG4gKiBDU1MgcHJvcGVydGllcyB0aGF0IGFjY2VwdCBwbGFpbiBudW1iZXJzXHJcbiAqL1xyXG5jb25zdCBpc05vVW5pdE51bWVyaWNTdHlsZVByb3AgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQsYm9yZGVyLWltYWdlLW91dHNldCxib3JkZXItaW1hZ2Utc2xpY2UsYCArXHJcbiAgICBgYm9yZGVyLWltYWdlLXdpZHRoLGJveC1mbGV4LGJveC1mbGV4LWdyb3VwLGJveC1vcmRpbmFsLWdyb3VwLGNvbHVtbi1jb3VudCxgICtcclxuICAgIGBjb2x1bW5zLGZsZXgsZmxleC1ncm93LGZsZXgtcG9zaXRpdmUsZmxleC1zaHJpbmssZmxleC1uZWdhdGl2ZSxmbGV4LW9yZGVyLGAgK1xyXG4gICAgYGdyaWQtcm93LGdyaWQtcm93LWVuZCxncmlkLXJvdy1zcGFuLGdyaWQtcm93LXN0YXJ0LGdyaWQtY29sdW1uLGAgK1xyXG4gICAgYGdyaWQtY29sdW1uLWVuZCxncmlkLWNvbHVtbi1zcGFuLGdyaWQtY29sdW1uLXN0YXJ0LGZvbnQtd2VpZ2h0LGxpbmUtY2xhbXAsYCArXHJcbiAgICBgbGluZS1oZWlnaHQsb3BhY2l0eSxvcmRlcixvcnBoYW5zLHRhYi1zaXplLHdpZG93cyx6LWluZGV4LHpvb20sYCArXHJcbiAgICAvLyBTVkdcclxuICAgIGBmaWxsLW9wYWNpdHksZmxvb2Qtb3BhY2l0eSxzdG9wLW9wYWNpdHksc3Ryb2tlLWRhc2hhcnJheSxzdHJva2UtZGFzaG9mZnNldCxgICtcclxuICAgIGBzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSxzdHJva2Utd2lkdGhgKTtcclxuLyoqXHJcbiAqIEtub3duIGF0dHJpYnV0ZXMsIHRoaXMgaXMgdXNlZCBmb3Igc3RyaW5naWZpY2F0aW9uIG9mIHJ1bnRpbWUgc3RhdGljIG5vZGVzXHJcbiAqIHNvIHRoYXQgd2UgZG9uJ3Qgc3RyaW5naWZ5IGJpbmRpbmdzIHRoYXQgY2Fubm90IGJlIHNldCBmcm9tIEhUTUwuXHJcbiAqIERvbid0IGFsc28gZm9yZ2V0IHRvIGFsbG93IGBkYXRhLSpgIGFuZCBgYXJpYS0qYCFcclxuICogR2VuZXJhdGVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9BdHRyaWJ1dGVzXHJcbiAqL1xyXG5jb25zdCBpc0tub3duQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgYWNjZXB0LGFjY2VwdC1jaGFyc2V0LGFjY2Vzc2tleSxhY3Rpb24sYWxpZ24sYWxsb3csYWx0LGFzeW5jLGAgK1xyXG4gICAgYGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSxhdXRvZm9jdXMsYXV0b3BsYXksYmFja2dyb3VuZCxiZ2NvbG9yLGAgK1xyXG4gICAgYGJvcmRlcixidWZmZXJlZCxjYXB0dXJlLGNoYWxsZW5nZSxjaGFyc2V0LGNoZWNrZWQsY2l0ZSxjbGFzcyxjb2RlLGAgK1xyXG4gICAgYGNvZGViYXNlLGNvbG9yLGNvbHMsY29sc3Bhbixjb250ZW50LGNvbnRlbnRlZGl0YWJsZSxjb250ZXh0bWVudSxjb250cm9scyxgICtcclxuICAgIGBjb29yZHMsY3Jvc3NvcmlnaW4sY3NwLGRhdGEsZGF0ZXRpbWUsZGVjb2RpbmcsZGVmYXVsdCxkZWZlcixkaXIsZGlybmFtZSxgICtcclxuICAgIGBkaXNhYmxlZCxkb3dubG9hZCxkcmFnZ2FibGUsZHJvcHpvbmUsZW5jdHlwZSxlbnRlcmtleWhpbnQsZm9yLGZvcm0sYCArXHJcbiAgICBgZm9ybWFjdGlvbixmb3JtZW5jdHlwZSxmb3JtbWV0aG9kLGZvcm1ub3ZhbGlkYXRlLGZvcm10YXJnZXQsaGVhZGVycyxgICtcclxuICAgIGBoZWlnaHQsaGlkZGVuLGhpZ2gsaHJlZixocmVmbGFuZyxodHRwLWVxdWl2LGljb24saWQsaW1wb3J0YW5jZSxpbnRlZ3JpdHksYCArXHJcbiAgICBgaXNtYXAsaXRlbXByb3Asa2V5dHlwZSxraW5kLGxhYmVsLGxhbmcsbGFuZ3VhZ2UsbG9hZGluZyxsaXN0LGxvb3AsbG93LGAgK1xyXG4gICAgYG1hbmlmZXN0LG1heCxtYXhsZW5ndGgsbWlubGVuZ3RoLG1lZGlhLG1pbixtdWx0aXBsZSxtdXRlZCxuYW1lLG5vdmFsaWRhdGUsYCArXHJcbiAgICBgb3BlbixvcHRpbXVtLHBhdHRlcm4scGluZyxwbGFjZWhvbGRlcixwb3N0ZXIscHJlbG9hZCxyYWRpb2dyb3VwLHJlYWRvbmx5LGAgK1xyXG4gICAgYHJlZmVycmVycG9saWN5LHJlbCxyZXF1aXJlZCxyZXZlcnNlZCxyb3dzLHJvd3NwYW4sc2FuZGJveCxzY29wZSxzY29wZWQsYCArXHJcbiAgICBgc2VsZWN0ZWQsc2hhcGUsc2l6ZSxzaXplcyxzbG90LHNwYW4sc3BlbGxjaGVjayxzcmMsc3JjZG9jLHNyY2xhbmcsc3Jjc2V0LGAgK1xyXG4gICAgYHN0YXJ0LHN0ZXAsc3R5bGUsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLGAgK1xyXG4gICAgYHZhbHVlLHdpZHRoLHdyYXBgKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUodmFsdWUpIHtcclxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU3R5bGUoaXNTdHJpbmcoaXRlbSkgPyBwYXJzZVN0cmluZ1N0eWxlKGl0ZW0pIDogaXRlbSk7XHJcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBub3JtYWxpemVkW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxufVxyXG5jb25zdCBsaXN0RGVsaW1pdGVyUkUgPSAvOyg/IVteKF0qXFwpKS9nO1xyXG5jb25zdCBwcm9wZXJ0eURlbGltaXRlclJFID0gLzooLispLztcclxuZnVuY3Rpb24gcGFyc2VTdHJpbmdTdHlsZShjc3NUZXh0KSB7XHJcbiAgICBjb25zdCByZXQgPSB7fTtcclxuICAgIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlclJFKS5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgIGlmIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XHJcbiAgICAgICAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXRbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGUoc3R5bGVzKSB7XHJcbiAgICBsZXQgcmV0ID0gJyc7XHJcbiAgICBpZiAoIXN0eWxlcykge1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZXMpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1trZXldO1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBrZXkuc3RhcnRzV2l0aChgLS1gKSA/IGtleSA6IGh5cGhlbmF0ZShrZXkpO1xyXG4gICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgfHxcclxuICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOb1VuaXROdW1lcmljU3R5bGVQcm9wKG5vcm1hbGl6ZWRLZXkpKSkge1xyXG4gICAgICAgICAgICAvLyBvbmx5IHJlbmRlciB2YWxpZCB2YWx1ZXNcclxuICAgICAgICAgICAgcmV0ICs9IGAke25vcm1hbGl6ZWRLZXl9OiR7dmFsdWV9O2A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVDbGFzcyh2YWx1ZSkge1xyXG4gICAgbGV0IHJlcyA9ICcnO1xyXG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHJlcyA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVDbGFzcyh2YWx1ZVtpXSk7XHJcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gbm9ybWFsaXplZCArICcgJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWVbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIHJlcyArPSBuYW1lICsgJyAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcy50cmltKCk7XHJcbn1cblxuLy8gVGhlc2UgdGFnIGNvbmZpZ3MgYXJlIHNoYXJlZCBiZXR3ZWVuIGNvbXBpbGVyLWRvbSBhbmQgcnVudGltZS1kb20sIHNvIHRoZXlcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50XHJcbmNvbnN0IEhUTUxfVEFHUyA9ICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSxhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLCcgK1xyXG4gICAgJ2hlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sJyArXHJcbiAgICAnZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsJyArXHJcbiAgICAnZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LHMsc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLCcgK1xyXG4gICAgJ3RpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLGVtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsJyArXHJcbiAgICAnY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLGNhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLCcgK1xyXG4gICAgJ3RoLHRyLGJ1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCwnICtcclxuICAgICdvcHRpb24sb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSxkZXRhaWxzLGRpYWxvZyxtZW51LCcgK1xyXG4gICAgJ3N1bW1hcnksdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnO1xyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvRWxlbWVudFxyXG5jb25zdCBTVkdfVEFHUyA9ICdzdmcsYW5pbWF0ZSxhbmltYXRlTW90aW9uLGFuaW1hdGVUcmFuc2Zvcm0sY2lyY2xlLGNsaXBQYXRoLGNvbG9yLXByb2ZpbGUsJyArXHJcbiAgICAnZGVmcyxkZXNjLGRpc2NhcmQsZWxsaXBzZSxmZUJsZW5kLGZlQ29sb3JNYXRyaXgsZmVDb21wb25lbnRUcmFuc2ZlciwnICtcclxuICAgICdmZUNvbXBvc2l0ZSxmZUNvbnZvbHZlTWF0cml4LGZlRGlmZnVzZUxpZ2h0aW5nLGZlRGlzcGxhY2VtZW50TWFwLCcgK1xyXG4gICAgJ2ZlRGlzdGFuY2VMaWdodCxmZURyb3BTaGFkb3csZmVGbG9vZCxmZUZ1bmNBLGZlRnVuY0IsZmVGdW5jRyxmZUZ1bmNSLCcgK1xyXG4gICAgJ2ZlR2F1c3NpYW5CbHVyLGZlSW1hZ2UsZmVNZXJnZSxmZU1lcmdlTm9kZSxmZU1vcnBob2xvZ3ksZmVPZmZzZXQsJyArXHJcbiAgICAnZmVQb2ludExpZ2h0LGZlU3BlY3VsYXJMaWdodGluZyxmZVNwb3RMaWdodCxmZVRpbGUsZmVUdXJidWxlbmNlLGZpbHRlciwnICtcclxuICAgICdmb3JlaWduT2JqZWN0LGcsaGF0Y2gsaGF0Y2hwYXRoLGltYWdlLGxpbmUsbGluZWFyR3JhZGllbnQsbWFya2VyLG1hc2ssJyArXHJcbiAgICAnbWVzaCxtZXNoZ3JhZGllbnQsbWVzaHBhdGNoLG1lc2hyb3csbWV0YWRhdGEsbXBhdGgscGF0aCxwYXR0ZXJuLCcgK1xyXG4gICAgJ3BvbHlnb24scG9seWxpbmUscmFkaWFsR3JhZGllbnQscmVjdCxzZXQsc29saWRjb2xvcixzdG9wLHN3aXRjaCxzeW1ib2wsJyArXHJcbiAgICAndGV4dCx0ZXh0UGF0aCx0aXRsZSx0c3Bhbix1bmtub3duLHVzZSx2aWV3JztcclxuY29uc3QgVk9JRF9UQUdTID0gJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsaHIsaW1nLGlucHV0LGxpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJztcclxuY29uc3QgaXNIVE1MVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKEhUTUxfVEFHUyk7XHJcbmNvbnN0IGlzU1ZHVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFNWR19UQUdTKTtcclxuY29uc3QgaXNWb2lkVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFZPSURfVEFHUyk7XG5cbmNvbnN0IGVzY2FwZVJFID0gL1tcIicmPD5dLztcclxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcclxuICAgIGNvbnN0IHN0ciA9ICcnICsgc3RyaW5nO1xyXG4gICAgY29uc3QgbWF0Y2ggPSBlc2NhcGVSRS5leGVjKHN0cik7XHJcbiAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuICAgIGxldCBodG1sID0gJyc7XHJcbiAgICBsZXQgZXNjYXBlZDtcclxuICAgIGxldCBpbmRleDtcclxuICAgIGxldCBsYXN0SW5kZXggPSAwO1xyXG4gICAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xyXG4gICAgICAgICAgICBjYXNlIDM0OiAvLyBcIlxyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmcXVvdDsnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzg6IC8vICZcclxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJmFtcDsnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzk6IC8vICdcclxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJiMzOTsnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNjA6IC8vIDxcclxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJmx0Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA2MjogLy8gPlxyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmZ3Q7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYXN0SW5kZXggIT09IGluZGV4KSB7XHJcbiAgICAgICAgICAgIGh0bWwgKz0gc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xyXG4gICAgICAgIGh0bWwgKz0gZXNjYXBlZDtcclxuICAgIH1cclxuICAgIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xyXG59XHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTIvc3ludGF4Lmh0bWwjY29tbWVudHNcclxuY29uc3QgY29tbWVudFN0cmlwUkUgPSAvXi0/Pnw8IS0tfC0tPnwtLSE+fDwhLSQvZztcclxuZnVuY3Rpb24gZXNjYXBlSHRtbENvbW1lbnQoc3JjKSB7XHJcbiAgICByZXR1cm4gc3JjLnJlcGxhY2UoY29tbWVudFN0cmlwUkUsICcnKTtcclxufVxuXG5mdW5jdGlvbiBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikge1xyXG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBsZXQgZXF1YWwgPSB0cnVlO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGVxdWFsICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZXF1YWwgPSBsb29zZUVxdWFsKGFbaV0sIGJbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVxdWFsO1xyXG59XHJcbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xyXG4gICAgaWYgKGEgPT09IGIpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBsZXQgYVZhbGlkVHlwZSA9IGlzRGF0ZShhKTtcclxuICAgIGxldCBiVmFsaWRUeXBlID0gaXNEYXRlKGIpO1xyXG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xyXG4gICAgICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCkgOiBmYWxzZTtcclxuICAgIH1cclxuICAgIGFWYWxpZFR5cGUgPSBpc0FycmF5KGEpO1xyXG4gICAgYlZhbGlkVHlwZSA9IGlzQXJyYXkoYik7XHJcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgYVZhbGlkVHlwZSA9IGlzT2JqZWN0KGEpO1xyXG4gICAgYlZhbGlkVHlwZSA9IGlzT2JqZWN0KGIpO1xyXG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogdGhpcyBpZiB3aWxsIHByb2JhYmx5IG5ldmVyIGJlIGNhbGxlZCAqL1xyXG4gICAgICAgIGlmICghYVZhbGlkVHlwZSB8fCAhYlZhbGlkVHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhhKS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgYktleXNDb3VudCA9IE9iamVjdC5rZXlzKGIpLmxlbmd0aDtcclxuICAgICAgICBpZiAoYUtleXNDb3VudCAhPT0gYktleXNDb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcclxuICAgICAgICAgICAgY29uc3QgYUhhc0tleSA9IGEuaGFzT3duUHJvcGVydHkoa2V5KTtcclxuICAgICAgICAgICAgY29uc3QgYkhhc0tleSA9IGIuaGFzT3duUHJvcGVydHkoa2V5KTtcclxuICAgICAgICAgICAgaWYgKChhSGFzS2V5ICYmICFiSGFzS2V5KSB8fFxyXG4gICAgICAgICAgICAgICAgKCFhSGFzS2V5ICYmIGJIYXNLZXkpIHx8XHJcbiAgICAgICAgICAgICAgICAhbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcclxufVxyXG5mdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcclxuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGl0ZW0gPT4gbG9vc2VFcXVhbChpdGVtLCB2YWwpKTtcclxufVxuXG4vKipcclxuICogRm9yIGNvbnZlcnRpbmcge3sgaW50ZXJwb2xhdGlvbiB9fSB2YWx1ZXMgdG8gZGlzcGxheWVkIHN0cmluZ3MuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB0b0Rpc3BsYXlTdHJpbmcgPSAodmFsKSA9PiB7XHJcbiAgICByZXR1cm4gdmFsID09IG51bGxcclxuICAgICAgICA/ICcnXHJcbiAgICAgICAgOiBpc09iamVjdCh2YWwpXHJcbiAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCByZXBsYWNlciwgMilcclxuICAgICAgICAgICAgOiBTdHJpbmcodmFsKTtcclxufTtcclxuY29uc3QgcmVwbGFjZXIgPSAoX2tleSwgdmFsKSA9PiB7XHJcbiAgICBpZiAoaXNNYXAodmFsKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIFtgTWFwKCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLmVudHJpZXMoKV0ucmVkdWNlKChlbnRyaWVzLCBba2V5LCB2YWxdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlbnRyaWVzW2Ake2tleX0gPT5gXSA9IHZhbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xyXG4gICAgICAgICAgICB9LCB7fSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTZXQodmFsKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIFtgU2V0KCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLnZhbHVlcygpXVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWwpICYmICFpc0FycmF5KHZhbCkgJiYgIWlzUGxhaW5PYmplY3QodmFsKSkge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcodmFsKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWw7XHJcbn07XG5cbi8qKlxyXG4gKiBMaXN0IG9mIEBiYWJlbC9wYXJzZXIgcGx1Z2lucyB0aGF0IGFyZSB1c2VkIGZvciB0ZW1wbGF0ZSBleHByZXNzaW9uXHJcbiAqIHRyYW5zZm9ybXMgYW5kIFNGQyBzY3JpcHQgdHJhbnNmb3Jtcy4gQnkgZGVmYXVsdCB3ZSBlbmFibGUgcHJvcG9zYWxzIHNsYXRlZFxyXG4gKiBmb3IgRVMyMDIwLiBUaGlzIHdpbGwgbmVlZCB0byBiZSB1cGRhdGVkIGFzIHRoZSBzcGVjIG1vdmVzIGZvcndhcmQuXHJcbiAqIEZ1bGwgbGlzdCBhdCBodHRwczovL2JhYmVsanMuaW8vZG9jcy9lbi9uZXh0L2JhYmVsLXBhcnNlciNwbHVnaW5zXHJcbiAqL1xyXG5jb25zdCBiYWJlbFBhcnNlckRlZmF1bHRQbHVnaW5zID0gW1xyXG4gICAgJ2JpZ0ludCcsXHJcbiAgICAnb3B0aW9uYWxDaGFpbmluZycsXHJcbiAgICAnbnVsbGlzaENvYWxlc2NpbmdPcGVyYXRvcidcclxuXTtcclxuY29uc3QgRU1QVFlfT0JKID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICA/IE9iamVjdC5mcmVlemUoe30pXHJcbiAgICA6IHt9O1xyXG5jb25zdCBFTVBUWV9BUlIgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBPYmplY3QuZnJlZXplKFtdKSA6IFtdO1xyXG5jb25zdCBOT09QID0gKCkgPT4geyB9O1xyXG4vKipcclxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cclxuICovXHJcbmNvbnN0IE5PID0gKCkgPT4gZmFsc2U7XHJcbmNvbnN0IG9uUkUgPSAvXm9uW15hLXpdLztcclxuY29uc3QgaXNPbiA9IChrZXkpID0+IG9uUkUudGVzdChrZXkpO1xyXG5jb25zdCBpc01vZGVsTGlzdGVuZXIgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aCgnb25VcGRhdGU6Jyk7XHJcbmNvbnN0IGV4dGVuZCA9IE9iamVjdC5hc3NpZ247XHJcbmNvbnN0IHJlbW92ZSA9IChhcnIsIGVsKSA9PiB7XHJcbiAgICBjb25zdCBpID0gYXJyLmluZGV4T2YoZWwpO1xyXG4gICAgaWYgKGkgPiAtMSkge1xyXG4gICAgICAgIGFyci5zcGxpY2UoaSwgMSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuY29uc3QgaGFzT3duID0gKHZhbCwga2V5KSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbCwga2V5KTtcclxuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XHJcbmNvbnN0IGlzTWFwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IE1hcF0nO1xyXG5jb25zdCBpc1NldCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBTZXRdJztcclxuY29uc3QgaXNEYXRlID0gKHZhbCkgPT4gdmFsIGluc3RhbmNlb2YgRGF0ZTtcclxuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XHJcbmNvbnN0IGlzU3RyaW5nID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XHJcbmNvbnN0IGlzU3ltYm9sID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N5bWJvbCc7XHJcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xyXG5jb25zdCBpc1Byb21pc2UgPSAodmFsKSA9PiB7XHJcbiAgICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XHJcbn07XHJcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuY29uc3QgdG9UeXBlU3RyaW5nID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcclxuY29uc3QgdG9SYXdUeXBlID0gKHZhbHVlKSA9PiB7XHJcbiAgICAvLyBleHRyYWN0IFwiUmF3VHlwZVwiIGZyb20gc3RyaW5ncyBsaWtlIFwiW29iamVjdCBSYXdUeXBlXVwiXHJcbiAgICByZXR1cm4gdG9UeXBlU3RyaW5nKHZhbHVlKS5zbGljZSg4LCAtMSk7XHJcbn07XHJcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XHJcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiZcclxuICAgIGtleSAhPT0gJ05hTicgJiZcclxuICAgIGtleVswXSAhPT0gJy0nICYmXHJcbiAgICAnJyArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XHJcbmNvbnN0IGlzUmVzZXJ2ZWRQcm9wID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFxyXG4vLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXHJcbicsa2V5LHJlZiwnICtcclxuICAgICdvblZub2RlQmVmb3JlTW91bnQsb25Wbm9kZU1vdW50ZWQsJyArXHJcbiAgICAnb25Wbm9kZUJlZm9yZVVwZGF0ZSxvblZub2RlVXBkYXRlZCwnICtcclxuICAgICdvblZub2RlQmVmb3JlVW5tb3VudCxvblZub2RlVW5tb3VudGVkJyk7XHJcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcclxuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHJldHVybiAoKHN0cikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XHJcbiAgICAgICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xyXG4gICAgfSk7XHJcbn07XHJcbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcclxuICAgIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gKGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJykpO1xyXG59KTtcclxuY29uc3QgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpKTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBjYXBpdGFsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSkpO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHRvSGFuZGxlcktleSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gKHN0ciA/IGBvbiR7Y2FwaXRhbGl6ZShzdHIpfWAgOiBgYCkpO1xyXG4vLyBjb21wYXJlIHdoZXRoZXIgYSB2YWx1ZSBoYXMgY2hhbmdlZCwgYWNjb3VudGluZyBmb3IgTmFOLlxyXG5jb25zdCBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gdmFsdWUgIT09IG9sZFZhbHVlICYmICh2YWx1ZSA9PT0gdmFsdWUgfHwgb2xkVmFsdWUgPT09IG9sZFZhbHVlKTtcclxuY29uc3QgaW52b2tlQXJyYXlGbnMgPSAoZm5zLCBhcmcpID0+IHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZm5zW2ldKGFyZyk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGRlZiA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICB2YWx1ZVxyXG4gICAgfSk7XHJcbn07XHJcbmNvbnN0IHRvTnVtYmVyID0gKHZhbCkgPT4ge1xyXG4gICAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcclxuICAgIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XHJcbn07XHJcbmxldCBfZ2xvYmFsVGhpcztcclxuY29uc3QgZ2V0R2xvYmFsVGhpcyA9ICgpID0+IHtcclxuICAgIHJldHVybiAoX2dsb2JhbFRoaXMgfHxcclxuICAgICAgICAoX2dsb2JhbFRoaXMgPVxyXG4gICAgICAgICAgICB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgICAgID8gZ2xvYmFsVGhpc1xyXG4gICAgICAgICAgICAgICAgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgICAgICAgICA/IHNlbGZcclxuICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gd2luZG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZ2xvYmFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSk7XHJcbn07XG5cbmV4cG9ydCB7IEVNUFRZX0FSUiwgRU1QVFlfT0JKLCBOTywgTk9PUCwgUGF0Y2hGbGFnTmFtZXMsIGJhYmVsUGFyc2VyRGVmYXVsdFBsdWdpbnMsIGNhbWVsaXplLCBjYXBpdGFsaXplLCBkZWYsIGVzY2FwZUh0bWwsIGVzY2FwZUh0bWxDb21tZW50LCBleHRlbmQsIGdlbmVyYXRlQ29kZUZyYW1lLCBnZXRHbG9iYWxUaGlzLCBoYXNDaGFuZ2VkLCBoYXNPd24sIGh5cGhlbmF0ZSwgaW52b2tlQXJyYXlGbnMsIGlzQXJyYXksIGlzQm9vbGVhbkF0dHIsIGlzRGF0ZSwgaXNGdW5jdGlvbiwgaXNHbG9iYWxseVdoaXRlbGlzdGVkLCBpc0hUTUxUYWcsIGlzSW50ZWdlcktleSwgaXNLbm93bkF0dHIsIGlzTWFwLCBpc01vZGVsTGlzdGVuZXIsIGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcCwgaXNPYmplY3QsIGlzT24sIGlzUGxhaW5PYmplY3QsIGlzUHJvbWlzZSwgaXNSZXNlcnZlZFByb3AsIGlzU1NSU2FmZUF0dHJOYW1lLCBpc1NWR1RhZywgaXNTZXQsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpc1N0cmluZywgaXNTeW1ib2wsIGlzVm9pZFRhZywgbG9vc2VFcXVhbCwgbG9vc2VJbmRleE9mLCBtYWtlTWFwLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplU3R5bGUsIG9iamVjdFRvU3RyaW5nLCBwYXJzZVN0cmluZ1N0eWxlLCBwcm9wc1RvQXR0ck1hcCwgcmVtb3ZlLCBzbG90RmxhZ3NUZXh0LCBzdHJpbmdpZnlTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCB0b1Jhd1R5cGUsIHRvVHlwZVN0cmluZyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@vue+shared@3.1.5/node_modules/@vue/shared/dist/shared.esm-bundler.js\n");

/***/ }),

/***/ "./node_modules/.pnpm/alpinejs@3.12.1/node_modules/alpinejs/dist/module.esm.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/alpinejs@3.12.1/node_modules/alpinejs/dist/module.esm.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ module_default; }\n/* harmony export */ });\n/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/reactivity */ \"./node_modules/.pnpm/@vue+reactivity@3.1.5/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\");\n// packages/alpinejs/src/scheduler.js\nvar flushPending = false;\nvar flushing = false;\nvar queue = [];\nvar lastFlushedIndex = -1;\nfunction scheduler(callback) {\n  queueJob(callback);\n}\nfunction queueJob(job) {\n  if (!queue.includes(job))\n    queue.push(job);\n  queueFlush();\n}\nfunction dequeueJob(job) {\n  let index = queue.indexOf(job);\n  if (index !== -1 && index > lastFlushedIndex)\n    queue.splice(index, 1);\n}\nfunction queueFlush() {\n  if (!flushing && !flushPending) {\n    flushPending = true;\n    queueMicrotask(flushJobs);\n  }\n}\nfunction flushJobs() {\n  flushPending = false;\n  flushing = true;\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n    lastFlushedIndex = i;\n  }\n  queue.length = 0;\n  lastFlushedIndex = -1;\n  flushing = false;\n}\n\n// packages/alpinejs/src/reactivity.js\nvar reactive;\nvar effect;\nvar release;\nvar raw;\nvar shouldSchedule = true;\nfunction disableEffectScheduling(callback) {\n  shouldSchedule = false;\n  callback();\n  shouldSchedule = true;\n}\nfunction setReactivityEngine(engine) {\n  reactive = engine.reactive;\n  release = engine.release;\n  effect = (callback) => engine.effect(callback, { scheduler: (task) => {\n    if (shouldSchedule) {\n      scheduler(task);\n    } else {\n      task();\n    }\n  } });\n  raw = engine.raw;\n}\nfunction overrideEffect(override) {\n  effect = override;\n}\nfunction elementBoundEffect(el) {\n  let cleanup = () => {\n  };\n  let wrappedEffect = (callback) => {\n    let effectReference = effect(callback);\n    if (!el._x_effects) {\n      el._x_effects = /* @__PURE__ */ new Set();\n      el._x_runEffects = () => {\n        el._x_effects.forEach((i) => i());\n      };\n    }\n    el._x_effects.add(effectReference);\n    cleanup = () => {\n      if (effectReference === void 0)\n        return;\n      el._x_effects.delete(effectReference);\n      release(effectReference);\n    };\n    return effectReference;\n  };\n  return [wrappedEffect, () => {\n    cleanup();\n  }];\n}\n\n// packages/alpinejs/src/mutation.js\nvar onAttributeAddeds = [];\nvar onElRemoveds = [];\nvar onElAddeds = [];\nfunction onElAdded(callback) {\n  onElAddeds.push(callback);\n}\nfunction onElRemoved(el, callback) {\n  if (typeof callback === \"function\") {\n    if (!el._x_cleanups)\n      el._x_cleanups = [];\n    el._x_cleanups.push(callback);\n  } else {\n    callback = el;\n    onElRemoveds.push(callback);\n  }\n}\nfunction onAttributesAdded(callback) {\n  onAttributeAddeds.push(callback);\n}\nfunction onAttributeRemoved(el, name, callback) {\n  if (!el._x_attributeCleanups)\n    el._x_attributeCleanups = {};\n  if (!el._x_attributeCleanups[name])\n    el._x_attributeCleanups[name] = [];\n  el._x_attributeCleanups[name].push(callback);\n}\nfunction cleanupAttributes(el, names) {\n  if (!el._x_attributeCleanups)\n    return;\n  Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {\n    if (names === void 0 || names.includes(name)) {\n      value.forEach((i) => i());\n      delete el._x_attributeCleanups[name];\n    }\n  });\n}\nvar observer = new MutationObserver(onMutate);\nvar currentlyObserving = false;\nfunction startObservingMutations() {\n  observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });\n  currentlyObserving = true;\n}\nfunction stopObservingMutations() {\n  flushObserver();\n  observer.disconnect();\n  currentlyObserving = false;\n}\nvar recordQueue = [];\nvar willProcessRecordQueue = false;\nfunction flushObserver() {\n  recordQueue = recordQueue.concat(observer.takeRecords());\n  if (recordQueue.length && !willProcessRecordQueue) {\n    willProcessRecordQueue = true;\n    queueMicrotask(() => {\n      processRecordQueue();\n      willProcessRecordQueue = false;\n    });\n  }\n}\nfunction processRecordQueue() {\n  onMutate(recordQueue);\n  recordQueue.length = 0;\n}\nfunction mutateDom(callback) {\n  if (!currentlyObserving)\n    return callback();\n  stopObservingMutations();\n  let result = callback();\n  startObservingMutations();\n  return result;\n}\nvar isCollecting = false;\nvar deferredMutations = [];\nfunction deferMutations() {\n  isCollecting = true;\n}\nfunction flushAndStopDeferringMutations() {\n  isCollecting = false;\n  onMutate(deferredMutations);\n  deferredMutations = [];\n}\nfunction onMutate(mutations) {\n  if (isCollecting) {\n    deferredMutations = deferredMutations.concat(mutations);\n    return;\n  }\n  let addedNodes = [];\n  let removedNodes = [];\n  let addedAttributes = /* @__PURE__ */ new Map();\n  let removedAttributes = /* @__PURE__ */ new Map();\n  for (let i = 0; i < mutations.length; i++) {\n    if (mutations[i].target._x_ignoreMutationObserver)\n      continue;\n    if (mutations[i].type === \"childList\") {\n      mutations[i].addedNodes.forEach((node) => node.nodeType === 1 && addedNodes.push(node));\n      mutations[i].removedNodes.forEach((node) => node.nodeType === 1 && removedNodes.push(node));\n    }\n    if (mutations[i].type === \"attributes\") {\n      let el = mutations[i].target;\n      let name = mutations[i].attributeName;\n      let oldValue = mutations[i].oldValue;\n      let add = () => {\n        if (!addedAttributes.has(el))\n          addedAttributes.set(el, []);\n        addedAttributes.get(el).push({ name, value: el.getAttribute(name) });\n      };\n      let remove = () => {\n        if (!removedAttributes.has(el))\n          removedAttributes.set(el, []);\n        removedAttributes.get(el).push(name);\n      };\n      if (el.hasAttribute(name) && oldValue === null) {\n        add();\n      } else if (el.hasAttribute(name)) {\n        remove();\n        add();\n      } else {\n        remove();\n      }\n    }\n  }\n  removedAttributes.forEach((attrs, el) => {\n    cleanupAttributes(el, attrs);\n  });\n  addedAttributes.forEach((attrs, el) => {\n    onAttributeAddeds.forEach((i) => i(el, attrs));\n  });\n  for (let node of removedNodes) {\n    if (addedNodes.includes(node))\n      continue;\n    onElRemoveds.forEach((i) => i(node));\n    if (node._x_cleanups) {\n      while (node._x_cleanups.length)\n        node._x_cleanups.pop()();\n    }\n  }\n  addedNodes.forEach((node) => {\n    node._x_ignoreSelf = true;\n    node._x_ignore = true;\n  });\n  for (let node of addedNodes) {\n    if (removedNodes.includes(node))\n      continue;\n    if (!node.isConnected)\n      continue;\n    delete node._x_ignoreSelf;\n    delete node._x_ignore;\n    onElAddeds.forEach((i) => i(node));\n    node._x_ignore = true;\n    node._x_ignoreSelf = true;\n  }\n  addedNodes.forEach((node) => {\n    delete node._x_ignoreSelf;\n    delete node._x_ignore;\n  });\n  addedNodes = null;\n  removedNodes = null;\n  addedAttributes = null;\n  removedAttributes = null;\n}\n\n// packages/alpinejs/src/scope.js\nfunction scope(node) {\n  return mergeProxies(closestDataStack(node));\n}\nfunction addScopeToNode(node, data2, referenceNode) {\n  node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];\n  return () => {\n    node._x_dataStack = node._x_dataStack.filter((i) => i !== data2);\n  };\n}\nfunction closestDataStack(node) {\n  if (node._x_dataStack)\n    return node._x_dataStack;\n  if (typeof ShadowRoot === \"function\" && node instanceof ShadowRoot) {\n    return closestDataStack(node.host);\n  }\n  if (!node.parentNode) {\n    return [];\n  }\n  return closestDataStack(node.parentNode);\n}\nfunction mergeProxies(objects) {\n  let thisProxy = new Proxy({}, {\n    ownKeys: () => {\n      return Array.from(new Set(objects.flatMap((i) => Object.keys(i))));\n    },\n    has: (target, name) => {\n      return objects.some((obj) => obj.hasOwnProperty(name));\n    },\n    get: (target, name) => {\n      return (objects.find((obj) => {\n        if (obj.hasOwnProperty(name)) {\n          let descriptor = Object.getOwnPropertyDescriptor(obj, name);\n          if (descriptor.get && descriptor.get._x_alreadyBound || descriptor.set && descriptor.set._x_alreadyBound) {\n            return true;\n          }\n          if ((descriptor.get || descriptor.set) && descriptor.enumerable) {\n            let getter = descriptor.get;\n            let setter = descriptor.set;\n            let property = descriptor;\n            getter = getter && getter.bind(thisProxy);\n            setter = setter && setter.bind(thisProxy);\n            if (getter)\n              getter._x_alreadyBound = true;\n            if (setter)\n              setter._x_alreadyBound = true;\n            Object.defineProperty(obj, name, {\n              ...property,\n              get: getter,\n              set: setter\n            });\n          }\n          return true;\n        }\n        return false;\n      }) || {})[name];\n    },\n    set: (target, name, value) => {\n      let closestObjectWithKey = objects.find((obj) => obj.hasOwnProperty(name));\n      if (closestObjectWithKey) {\n        closestObjectWithKey[name] = value;\n      } else {\n        objects[objects.length - 1][name] = value;\n      }\n      return true;\n    }\n  });\n  return thisProxy;\n}\n\n// packages/alpinejs/src/interceptor.js\nfunction initInterceptors(data2) {\n  let isObject = (val) => typeof val === \"object\" && !Array.isArray(val) && val !== null;\n  let recurse = (obj, basePath = \"\") => {\n    Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {\n      if (enumerable === false || value === void 0)\n        return;\n      let path = basePath === \"\" ? key : `${basePath}.${key}`;\n      if (typeof value === \"object\" && value !== null && value._x_interceptor) {\n        obj[key] = value.initialize(data2, path, key);\n      } else {\n        if (isObject(value) && value !== obj && !(value instanceof Element)) {\n          recurse(value, path);\n        }\n      }\n    });\n  };\n  return recurse(data2);\n}\nfunction interceptor(callback, mutateObj = () => {\n}) {\n  let obj = {\n    initialValue: void 0,\n    _x_interceptor: true,\n    initialize(data2, path, key) {\n      return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);\n    }\n  };\n  mutateObj(obj);\n  return (initialValue) => {\n    if (typeof initialValue === \"object\" && initialValue !== null && initialValue._x_interceptor) {\n      let initialize = obj.initialize.bind(obj);\n      obj.initialize = (data2, path, key) => {\n        let innerValue = initialValue.initialize(data2, path, key);\n        obj.initialValue = innerValue;\n        return initialize(data2, path, key);\n      };\n    } else {\n      obj.initialValue = initialValue;\n    }\n    return obj;\n  };\n}\nfunction get(obj, path) {\n  return path.split(\".\").reduce((carry, segment) => carry[segment], obj);\n}\nfunction set(obj, path, value) {\n  if (typeof path === \"string\")\n    path = path.split(\".\");\n  if (path.length === 1)\n    obj[path[0]] = value;\n  else if (path.length === 0)\n    throw error;\n  else {\n    if (obj[path[0]])\n      return set(obj[path[0]], path.slice(1), value);\n    else {\n      obj[path[0]] = {};\n      return set(obj[path[0]], path.slice(1), value);\n    }\n  }\n}\n\n// packages/alpinejs/src/magics.js\nvar magics = {};\nfunction magic(name, callback) {\n  magics[name] = callback;\n}\nfunction injectMagics(obj, el) {\n  Object.entries(magics).forEach(([name, callback]) => {\n    let memoizedUtilities = null;\n    function getUtilities() {\n      if (memoizedUtilities) {\n        return memoizedUtilities;\n      } else {\n        let [utilities, cleanup] = getElementBoundUtilities(el);\n        memoizedUtilities = { interceptor, ...utilities };\n        onElRemoved(el, cleanup);\n        return memoizedUtilities;\n      }\n    }\n    Object.defineProperty(obj, `$${name}`, {\n      get() {\n        return callback(el, getUtilities());\n      },\n      enumerable: false\n    });\n  });\n  return obj;\n}\n\n// packages/alpinejs/src/utils/error.js\nfunction tryCatch(el, expression, callback, ...args) {\n  try {\n    return callback(...args);\n  } catch (e) {\n    handleError(e, el, expression);\n  }\n}\nfunction handleError(error2, el, expression = void 0) {\n  Object.assign(error2, { el, expression });\n  console.warn(`Alpine Expression Error: ${error2.message}\n\n${expression ? 'Expression: \"' + expression + '\"\\n\\n' : \"\"}`, el);\n  setTimeout(() => {\n    throw error2;\n  }, 0);\n}\n\n// packages/alpinejs/src/evaluator.js\nvar shouldAutoEvaluateFunctions = true;\nfunction dontAutoEvaluateFunctions(callback) {\n  let cache = shouldAutoEvaluateFunctions;\n  shouldAutoEvaluateFunctions = false;\n  callback();\n  shouldAutoEvaluateFunctions = cache;\n}\nfunction evaluate(el, expression, extras = {}) {\n  let result;\n  evaluateLater(el, expression)((value) => result = value, extras);\n  return result;\n}\nfunction evaluateLater(...args) {\n  return theEvaluatorFunction(...args);\n}\nvar theEvaluatorFunction = normalEvaluator;\nfunction setEvaluator(newEvaluator) {\n  theEvaluatorFunction = newEvaluator;\n}\nfunction normalEvaluator(el, expression) {\n  let overriddenMagics = {};\n  injectMagics(overriddenMagics, el);\n  let dataStack = [overriddenMagics, ...closestDataStack(el)];\n  let evaluator = typeof expression === \"function\" ? generateEvaluatorFromFunction(dataStack, expression) : generateEvaluatorFromString(dataStack, expression, el);\n  return tryCatch.bind(null, el, expression, evaluator);\n}\nfunction generateEvaluatorFromFunction(dataStack, func) {\n  return (receiver = () => {\n  }, { scope: scope2 = {}, params = [] } = {}) => {\n    let result = func.apply(mergeProxies([scope2, ...dataStack]), params);\n    runIfTypeOfFunction(receiver, result);\n  };\n}\nvar evaluatorMemo = {};\nfunction generateFunctionFromString(expression, el) {\n  if (evaluatorMemo[expression]) {\n    return evaluatorMemo[expression];\n  }\n  let AsyncFunction = Object.getPrototypeOf(async function() {\n  }).constructor;\n  let rightSideSafeExpression = /^[\\n\\s]*if.*\\(.*\\)/.test(expression) || /^(let|const)\\s/.test(expression) ? `(async()=>{ ${expression} })()` : expression;\n  const safeAsyncFunction = () => {\n    try {\n      return new AsyncFunction([\"__self\", \"scope\"], `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`);\n    } catch (error2) {\n      handleError(error2, el, expression);\n      return Promise.resolve();\n    }\n  };\n  let func = safeAsyncFunction();\n  evaluatorMemo[expression] = func;\n  return func;\n}\nfunction generateEvaluatorFromString(dataStack, expression, el) {\n  let func = generateFunctionFromString(expression, el);\n  return (receiver = () => {\n  }, { scope: scope2 = {}, params = [] } = {}) => {\n    func.result = void 0;\n    func.finished = false;\n    let completeScope = mergeProxies([scope2, ...dataStack]);\n    if (typeof func === \"function\") {\n      let promise = func(func, completeScope).catch((error2) => handleError(error2, el, expression));\n      if (func.finished) {\n        runIfTypeOfFunction(receiver, func.result, completeScope, params, el);\n        func.result = void 0;\n      } else {\n        promise.then((result) => {\n          runIfTypeOfFunction(receiver, result, completeScope, params, el);\n        }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);\n      }\n    }\n  };\n}\nfunction runIfTypeOfFunction(receiver, value, scope2, params, el) {\n  if (shouldAutoEvaluateFunctions && typeof value === \"function\") {\n    let result = value.apply(scope2, params);\n    if (result instanceof Promise) {\n      result.then((i) => runIfTypeOfFunction(receiver, i, scope2, params)).catch((error2) => handleError(error2, el, value));\n    } else {\n      receiver(result);\n    }\n  } else if (typeof value === \"object\" && value instanceof Promise) {\n    value.then((i) => receiver(i));\n  } else {\n    receiver(value);\n  }\n}\n\n// packages/alpinejs/src/directives.js\nvar prefixAsString = \"x-\";\nfunction prefix(subject = \"\") {\n  return prefixAsString + subject;\n}\nfunction setPrefix(newPrefix) {\n  prefixAsString = newPrefix;\n}\nvar directiveHandlers = {};\nfunction directive(name, callback) {\n  directiveHandlers[name] = callback;\n  return {\n    before(directive2) {\n      if (!directiveHandlers[directive2]) {\n        console.warn(\n          \"Cannot find directive `${directive}`. `${name}` will use the default order of execution\"\n        );\n        return;\n      }\n      const pos = directiveOrder.indexOf(directive2);\n      directiveOrder.splice(pos >= 0 ? pos : directiveOrder.indexOf(\"DEFAULT\"), 0, name);\n    }\n  };\n}\nfunction directives(el, attributes, originalAttributeOverride) {\n  attributes = Array.from(attributes);\n  if (el._x_virtualDirectives) {\n    let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }));\n    let staticAttributes = attributesOnly(vAttributes);\n    vAttributes = vAttributes.map((attribute) => {\n      if (staticAttributes.find((attr) => attr.name === attribute.name)) {\n        return {\n          name: `x-bind:${attribute.name}`,\n          value: `\"${attribute.value}\"`\n        };\n      }\n      return attribute;\n    });\n    attributes = attributes.concat(vAttributes);\n  }\n  let transformedAttributeMap = {};\n  let directives2 = attributes.map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);\n  return directives2.map((directive2) => {\n    return getDirectiveHandler(el, directive2);\n  });\n}\nfunction attributesOnly(attributes) {\n  return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));\n}\nvar isDeferringHandlers = false;\nvar directiveHandlerStacks = /* @__PURE__ */ new Map();\nvar currentHandlerStackKey = Symbol();\nfunction deferHandlingDirectives(callback) {\n  isDeferringHandlers = true;\n  let key = Symbol();\n  currentHandlerStackKey = key;\n  directiveHandlerStacks.set(key, []);\n  let flushHandlers = () => {\n    while (directiveHandlerStacks.get(key).length)\n      directiveHandlerStacks.get(key).shift()();\n    directiveHandlerStacks.delete(key);\n  };\n  let stopDeferring = () => {\n    isDeferringHandlers = false;\n    flushHandlers();\n  };\n  callback(flushHandlers);\n  stopDeferring();\n}\nfunction getElementBoundUtilities(el) {\n  let cleanups = [];\n  let cleanup = (callback) => cleanups.push(callback);\n  let [effect3, cleanupEffect] = elementBoundEffect(el);\n  cleanups.push(cleanupEffect);\n  let utilities = {\n    Alpine: alpine_default,\n    effect: effect3,\n    cleanup,\n    evaluateLater: evaluateLater.bind(evaluateLater, el),\n    evaluate: evaluate.bind(evaluate, el)\n  };\n  let doCleanup = () => cleanups.forEach((i) => i());\n  return [utilities, doCleanup];\n}\nfunction getDirectiveHandler(el, directive2) {\n  let noop = () => {\n  };\n  let handler3 = directiveHandlers[directive2.type] || noop;\n  let [utilities, cleanup] = getElementBoundUtilities(el);\n  onAttributeRemoved(el, directive2.original, cleanup);\n  let fullHandler = () => {\n    if (el._x_ignore || el._x_ignoreSelf)\n      return;\n    handler3.inline && handler3.inline(el, directive2, utilities);\n    handler3 = handler3.bind(handler3, el, directive2, utilities);\n    isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler3) : handler3();\n  };\n  fullHandler.runCleanups = cleanup;\n  return fullHandler;\n}\nvar startingWith = (subject, replacement) => ({ name, value }) => {\n  if (name.startsWith(subject))\n    name = name.replace(subject, replacement);\n  return { name, value };\n};\nvar into = (i) => i;\nfunction toTransformedAttributes(callback = () => {\n}) {\n  return ({ name, value }) => {\n    let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {\n      return transform(carry);\n    }, { name, value });\n    if (newName !== name)\n      callback(newName, name);\n    return { name: newName, value: newValue };\n  };\n}\nvar attributeTransformers = [];\nfunction mapAttributes(callback) {\n  attributeTransformers.push(callback);\n}\nfunction outNonAlpineAttributes({ name }) {\n  return alpineAttributeRegex().test(name);\n}\nvar alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\\\b`);\nfunction toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {\n  return ({ name, value }) => {\n    let typeMatch = name.match(alpineAttributeRegex());\n    let valueMatch = name.match(/:([a-zA-Z0-9\\-:]+)/);\n    let modifiers = name.match(/\\.[^.\\]]+(?=[^\\]]*$)/g) || [];\n    let original = originalAttributeOverride || transformedAttributeMap[name] || name;\n    return {\n      type: typeMatch ? typeMatch[1] : null,\n      value: valueMatch ? valueMatch[1] : null,\n      modifiers: modifiers.map((i) => i.replace(\".\", \"\")),\n      expression: value,\n      original\n    };\n  };\n}\nvar DEFAULT = \"DEFAULT\";\nvar directiveOrder = [\n  \"ignore\",\n  \"ref\",\n  \"data\",\n  \"id\",\n  \"bind\",\n  \"init\",\n  \"for\",\n  \"model\",\n  \"modelable\",\n  \"transition\",\n  \"show\",\n  \"if\",\n  DEFAULT,\n  \"teleport\"\n];\nfunction byPriority(a, b) {\n  let typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type;\n  let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;\n  return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);\n}\n\n// packages/alpinejs/src/utils/dispatch.js\nfunction dispatch(el, name, detail = {}) {\n  el.dispatchEvent(\n    new CustomEvent(name, {\n      detail,\n      bubbles: true,\n      // Allows events to pass the shadow DOM barrier.\n      composed: true,\n      cancelable: true\n    })\n  );\n}\n\n// packages/alpinejs/src/utils/walk.js\nfunction walk(el, callback) {\n  if (typeof ShadowRoot === \"function\" && el instanceof ShadowRoot) {\n    Array.from(el.children).forEach((el2) => walk(el2, callback));\n    return;\n  }\n  let skip = false;\n  callback(el, () => skip = true);\n  if (skip)\n    return;\n  let node = el.firstElementChild;\n  while (node) {\n    walk(node, callback, false);\n    node = node.nextElementSibling;\n  }\n}\n\n// packages/alpinejs/src/utils/warn.js\nfunction warn(message, ...args) {\n  console.warn(`Alpine Warning: ${message}`, ...args);\n}\n\n// packages/alpinejs/src/lifecycle.js\nvar started = false;\nfunction start() {\n  if (started)\n    warn(\"Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems.\");\n  started = true;\n  if (!document.body)\n    warn(\"Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?\");\n  dispatch(document, \"alpine:init\");\n  dispatch(document, \"alpine:initializing\");\n  startObservingMutations();\n  onElAdded((el) => initTree(el, walk));\n  onElRemoved((el) => destroyTree(el));\n  onAttributesAdded((el, attrs) => {\n    directives(el, attrs).forEach((handle) => handle());\n  });\n  let outNestedComponents = (el) => !closestRoot(el.parentElement, true);\n  Array.from(document.querySelectorAll(allSelectors())).filter(outNestedComponents).forEach((el) => {\n    initTree(el);\n  });\n  dispatch(document, \"alpine:initialized\");\n}\nvar rootSelectorCallbacks = [];\nvar initSelectorCallbacks = [];\nfunction rootSelectors() {\n  return rootSelectorCallbacks.map((fn) => fn());\n}\nfunction allSelectors() {\n  return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());\n}\nfunction addRootSelector(selectorCallback) {\n  rootSelectorCallbacks.push(selectorCallback);\n}\nfunction addInitSelector(selectorCallback) {\n  initSelectorCallbacks.push(selectorCallback);\n}\nfunction closestRoot(el, includeInitSelectors = false) {\n  return findClosest(el, (element) => {\n    const selectors = includeInitSelectors ? allSelectors() : rootSelectors();\n    if (selectors.some((selector) => element.matches(selector)))\n      return true;\n  });\n}\nfunction findClosest(el, callback) {\n  if (!el)\n    return;\n  if (callback(el))\n    return el;\n  if (el._x_teleportBack)\n    el = el._x_teleportBack;\n  if (!el.parentElement)\n    return;\n  return findClosest(el.parentElement, callback);\n}\nfunction isRoot(el) {\n  return rootSelectors().some((selector) => el.matches(selector));\n}\nvar initInterceptors2 = [];\nfunction interceptInit(callback) {\n  initInterceptors2.push(callback);\n}\nfunction initTree(el, walker = walk, intercept = () => {\n}) {\n  deferHandlingDirectives(() => {\n    walker(el, (el2, skip) => {\n      intercept(el2, skip);\n      initInterceptors2.forEach((i) => i(el2, skip));\n      directives(el2, el2.attributes).forEach((handle) => handle());\n      el2._x_ignore && skip();\n    });\n  });\n}\nfunction destroyTree(root) {\n  walk(root, (el) => cleanupAttributes(el));\n}\n\n// packages/alpinejs/src/nextTick.js\nvar tickStack = [];\nvar isHolding = false;\nfunction nextTick(callback = () => {\n}) {\n  queueMicrotask(() => {\n    isHolding || setTimeout(() => {\n      releaseNextTicks();\n    });\n  });\n  return new Promise((res) => {\n    tickStack.push(() => {\n      callback();\n      res();\n    });\n  });\n}\nfunction releaseNextTicks() {\n  isHolding = false;\n  while (tickStack.length)\n    tickStack.shift()();\n}\nfunction holdNextTicks() {\n  isHolding = true;\n}\n\n// packages/alpinejs/src/utils/classes.js\nfunction setClasses(el, value) {\n  if (Array.isArray(value)) {\n    return setClassesFromString(el, value.join(\" \"));\n  } else if (typeof value === \"object\" && value !== null) {\n    return setClassesFromObject(el, value);\n  } else if (typeof value === \"function\") {\n    return setClasses(el, value());\n  }\n  return setClassesFromString(el, value);\n}\nfunction setClassesFromString(el, classString) {\n  let split = (classString2) => classString2.split(\" \").filter(Boolean);\n  let missingClasses = (classString2) => classString2.split(\" \").filter((i) => !el.classList.contains(i)).filter(Boolean);\n  let addClassesAndReturnUndo = (classes) => {\n    el.classList.add(...classes);\n    return () => {\n      el.classList.remove(...classes);\n    };\n  };\n  classString = classString === true ? classString = \"\" : classString || \"\";\n  return addClassesAndReturnUndo(missingClasses(classString));\n}\nfunction setClassesFromObject(el, classObject) {\n  let split = (classString) => classString.split(\" \").filter(Boolean);\n  let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);\n  let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);\n  let added = [];\n  let removed = [];\n  forRemove.forEach((i) => {\n    if (el.classList.contains(i)) {\n      el.classList.remove(i);\n      removed.push(i);\n    }\n  });\n  forAdd.forEach((i) => {\n    if (!el.classList.contains(i)) {\n      el.classList.add(i);\n      added.push(i);\n    }\n  });\n  return () => {\n    removed.forEach((i) => el.classList.add(i));\n    added.forEach((i) => el.classList.remove(i));\n  };\n}\n\n// packages/alpinejs/src/utils/styles.js\nfunction setStyles(el, value) {\n  if (typeof value === \"object\" && value !== null) {\n    return setStylesFromObject(el, value);\n  }\n  return setStylesFromString(el, value);\n}\nfunction setStylesFromObject(el, value) {\n  let previousStyles = {};\n  Object.entries(value).forEach(([key, value2]) => {\n    previousStyles[key] = el.style[key];\n    if (!key.startsWith(\"--\")) {\n      key = kebabCase(key);\n    }\n    el.style.setProperty(key, value2);\n  });\n  setTimeout(() => {\n    if (el.style.length === 0) {\n      el.removeAttribute(\"style\");\n    }\n  });\n  return () => {\n    setStyles(el, previousStyles);\n  };\n}\nfunction setStylesFromString(el, value) {\n  let cache = el.getAttribute(\"style\", value);\n  el.setAttribute(\"style\", value);\n  return () => {\n    el.setAttribute(\"style\", cache || \"\");\n  };\n}\nfunction kebabCase(subject) {\n  return subject.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n\n// packages/alpinejs/src/utils/once.js\nfunction once(callback, fallback = () => {\n}) {\n  let called = false;\n  return function() {\n    if (!called) {\n      called = true;\n      callback.apply(this, arguments);\n    } else {\n      fallback.apply(this, arguments);\n    }\n  };\n}\n\n// packages/alpinejs/src/directives/x-transition.js\ndirective(\"transition\", (el, { value, modifiers, expression }, { evaluate: evaluate2 }) => {\n  if (typeof expression === \"function\")\n    expression = evaluate2(expression);\n  if (expression === false)\n    return;\n  if (!expression || typeof expression === \"boolean\") {\n    registerTransitionsFromHelper(el, modifiers, value);\n  } else {\n    registerTransitionsFromClassString(el, expression, value);\n  }\n});\nfunction registerTransitionsFromClassString(el, classString, stage) {\n  registerTransitionObject(el, setClasses, \"\");\n  let directiveStorageMap = {\n    \"enter\": (classes) => {\n      el._x_transition.enter.during = classes;\n    },\n    \"enter-start\": (classes) => {\n      el._x_transition.enter.start = classes;\n    },\n    \"enter-end\": (classes) => {\n      el._x_transition.enter.end = classes;\n    },\n    \"leave\": (classes) => {\n      el._x_transition.leave.during = classes;\n    },\n    \"leave-start\": (classes) => {\n      el._x_transition.leave.start = classes;\n    },\n    \"leave-end\": (classes) => {\n      el._x_transition.leave.end = classes;\n    }\n  };\n  directiveStorageMap[stage](classString);\n}\nfunction registerTransitionsFromHelper(el, modifiers, stage) {\n  registerTransitionObject(el, setStyles);\n  let doesntSpecify = !modifiers.includes(\"in\") && !modifiers.includes(\"out\") && !stage;\n  let transitioningIn = doesntSpecify || modifiers.includes(\"in\") || [\"enter\"].includes(stage);\n  let transitioningOut = doesntSpecify || modifiers.includes(\"out\") || [\"leave\"].includes(stage);\n  if (modifiers.includes(\"in\") && !doesntSpecify) {\n    modifiers = modifiers.filter((i, index) => index < modifiers.indexOf(\"out\"));\n  }\n  if (modifiers.includes(\"out\") && !doesntSpecify) {\n    modifiers = modifiers.filter((i, index) => index > modifiers.indexOf(\"out\"));\n  }\n  let wantsAll = !modifiers.includes(\"opacity\") && !modifiers.includes(\"scale\");\n  let wantsOpacity = wantsAll || modifiers.includes(\"opacity\");\n  let wantsScale = wantsAll || modifiers.includes(\"scale\");\n  let opacityValue = wantsOpacity ? 0 : 1;\n  let scaleValue = wantsScale ? modifierValue(modifiers, \"scale\", 95) / 100 : 1;\n  let delay = modifierValue(modifiers, \"delay\", 0) / 1e3;\n  let origin = modifierValue(modifiers, \"origin\", \"center\");\n  let property = \"opacity, transform\";\n  let durationIn = modifierValue(modifiers, \"duration\", 150) / 1e3;\n  let durationOut = modifierValue(modifiers, \"duration\", 75) / 1e3;\n  let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;\n  if (transitioningIn) {\n    el._x_transition.enter.during = {\n      transformOrigin: origin,\n      transitionDelay: `${delay}s`,\n      transitionProperty: property,\n      transitionDuration: `${durationIn}s`,\n      transitionTimingFunction: easing\n    };\n    el._x_transition.enter.start = {\n      opacity: opacityValue,\n      transform: `scale(${scaleValue})`\n    };\n    el._x_transition.enter.end = {\n      opacity: 1,\n      transform: `scale(1)`\n    };\n  }\n  if (transitioningOut) {\n    el._x_transition.leave.during = {\n      transformOrigin: origin,\n      transitionDelay: `${delay}s`,\n      transitionProperty: property,\n      transitionDuration: `${durationOut}s`,\n      transitionTimingFunction: easing\n    };\n    el._x_transition.leave.start = {\n      opacity: 1,\n      transform: `scale(1)`\n    };\n    el._x_transition.leave.end = {\n      opacity: opacityValue,\n      transform: `scale(${scaleValue})`\n    };\n  }\n}\nfunction registerTransitionObject(el, setFunction, defaultValue = {}) {\n  if (!el._x_transition)\n    el._x_transition = {\n      enter: { during: defaultValue, start: defaultValue, end: defaultValue },\n      leave: { during: defaultValue, start: defaultValue, end: defaultValue },\n      in(before = () => {\n      }, after = () => {\n      }) {\n        transition(el, setFunction, {\n          during: this.enter.during,\n          start: this.enter.start,\n          end: this.enter.end\n        }, before, after);\n      },\n      out(before = () => {\n      }, after = () => {\n      }) {\n        transition(el, setFunction, {\n          during: this.leave.during,\n          start: this.leave.start,\n          end: this.leave.end\n        }, before, after);\n      }\n    };\n}\nwindow.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {\n  const nextTick2 = document.visibilityState === \"visible\" ? requestAnimationFrame : setTimeout;\n  let clickAwayCompatibleShow = () => nextTick2(show);\n  if (value) {\n    if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {\n      el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();\n    } else {\n      el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();\n    }\n    return;\n  }\n  el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {\n    el._x_transition.out(() => {\n    }, () => resolve(hide));\n    el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));\n  }) : Promise.resolve(hide);\n  queueMicrotask(() => {\n    let closest = closestHide(el);\n    if (closest) {\n      if (!closest._x_hideChildren)\n        closest._x_hideChildren = [];\n      closest._x_hideChildren.push(el);\n    } else {\n      nextTick2(() => {\n        let hideAfterChildren = (el2) => {\n          let carry = Promise.all([\n            el2._x_hidePromise,\n            ...(el2._x_hideChildren || []).map(hideAfterChildren)\n          ]).then(([i]) => i());\n          delete el2._x_hidePromise;\n          delete el2._x_hideChildren;\n          return carry;\n        };\n        hideAfterChildren(el).catch((e) => {\n          if (!e.isFromCancelledTransition)\n            throw e;\n        });\n      });\n    }\n  });\n};\nfunction closestHide(el) {\n  let parent = el.parentNode;\n  if (!parent)\n    return;\n  return parent._x_hidePromise ? parent : closestHide(parent);\n}\nfunction transition(el, setFunction, { during, start: start2, end } = {}, before = () => {\n}, after = () => {\n}) {\n  if (el._x_transitioning)\n    el._x_transitioning.cancel();\n  if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {\n    before();\n    after();\n    return;\n  }\n  let undoStart, undoDuring, undoEnd;\n  performTransition(el, {\n    start() {\n      undoStart = setFunction(el, start2);\n    },\n    during() {\n      undoDuring = setFunction(el, during);\n    },\n    before,\n    end() {\n      undoStart();\n      undoEnd = setFunction(el, end);\n    },\n    after,\n    cleanup() {\n      undoDuring();\n      undoEnd();\n    }\n  });\n}\nfunction performTransition(el, stages) {\n  let interrupted, reachedBefore, reachedEnd;\n  let finish = once(() => {\n    mutateDom(() => {\n      interrupted = true;\n      if (!reachedBefore)\n        stages.before();\n      if (!reachedEnd) {\n        stages.end();\n        releaseNextTicks();\n      }\n      stages.after();\n      if (el.isConnected)\n        stages.cleanup();\n      delete el._x_transitioning;\n    });\n  });\n  el._x_transitioning = {\n    beforeCancels: [],\n    beforeCancel(callback) {\n      this.beforeCancels.push(callback);\n    },\n    cancel: once(function() {\n      while (this.beforeCancels.length) {\n        this.beforeCancels.shift()();\n      }\n      ;\n      finish();\n    }),\n    finish\n  };\n  mutateDom(() => {\n    stages.start();\n    stages.during();\n  });\n  holdNextTicks();\n  requestAnimationFrame(() => {\n    if (interrupted)\n      return;\n    let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, \"\").replace(\"s\", \"\")) * 1e3;\n    let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, \"\").replace(\"s\", \"\")) * 1e3;\n    if (duration === 0)\n      duration = Number(getComputedStyle(el).animationDuration.replace(\"s\", \"\")) * 1e3;\n    mutateDom(() => {\n      stages.before();\n    });\n    reachedBefore = true;\n    requestAnimationFrame(() => {\n      if (interrupted)\n        return;\n      mutateDom(() => {\n        stages.end();\n      });\n      releaseNextTicks();\n      setTimeout(el._x_transitioning.finish, duration + delay);\n      reachedEnd = true;\n    });\n  });\n}\nfunction modifierValue(modifiers, key, fallback) {\n  if (modifiers.indexOf(key) === -1)\n    return fallback;\n  const rawValue = modifiers[modifiers.indexOf(key) + 1];\n  if (!rawValue)\n    return fallback;\n  if (key === \"scale\") {\n    if (isNaN(rawValue))\n      return fallback;\n  }\n  if (key === \"duration\" || key === \"delay\") {\n    let match = rawValue.match(/([0-9]+)ms/);\n    if (match)\n      return match[1];\n  }\n  if (key === \"origin\") {\n    if ([\"top\", \"right\", \"left\", \"center\", \"bottom\"].includes(modifiers[modifiers.indexOf(key) + 2])) {\n      return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(\" \");\n    }\n  }\n  return rawValue;\n}\n\n// packages/alpinejs/src/clone.js\nvar isCloning = false;\nfunction skipDuringClone(callback, fallback = () => {\n}) {\n  return (...args) => isCloning ? fallback(...args) : callback(...args);\n}\nfunction onlyDuringClone(callback) {\n  return (...args) => isCloning && callback(...args);\n}\nfunction clone(oldEl, newEl) {\n  if (!newEl._x_dataStack)\n    newEl._x_dataStack = oldEl._x_dataStack;\n  isCloning = true;\n  dontRegisterReactiveSideEffects(() => {\n    cloneTree(newEl);\n  });\n  isCloning = false;\n}\nfunction cloneTree(el) {\n  let hasRunThroughFirstEl = false;\n  let shallowWalker = (el2, callback) => {\n    walk(el2, (el3, skip) => {\n      if (hasRunThroughFirstEl && isRoot(el3))\n        return skip();\n      hasRunThroughFirstEl = true;\n      callback(el3, skip);\n    });\n  };\n  initTree(el, shallowWalker);\n}\nfunction dontRegisterReactiveSideEffects(callback) {\n  let cache = effect;\n  overrideEffect((callback2, el) => {\n    let storedEffect = cache(callback2);\n    release(storedEffect);\n    return () => {\n    };\n  });\n  callback();\n  overrideEffect(cache);\n}\n\n// packages/alpinejs/src/utils/bind.js\nfunction bind(el, name, value, modifiers = []) {\n  if (!el._x_bindings)\n    el._x_bindings = reactive({});\n  el._x_bindings[name] = value;\n  name = modifiers.includes(\"camel\") ? camelCase(name) : name;\n  switch (name) {\n    case \"value\":\n      bindInputValue(el, value);\n      break;\n    case \"style\":\n      bindStyles(el, value);\n      break;\n    case \"class\":\n      bindClasses(el, value);\n      break;\n    case \"selected\":\n    case \"checked\":\n      bindAttributeAndProperty(el, name, value);\n      break;\n    default:\n      bindAttribute(el, name, value);\n      break;\n  }\n}\nfunction bindInputValue(el, value) {\n  if (el.type === \"radio\") {\n    if (el.attributes.value === void 0) {\n      el.value = value;\n    }\n    if (window.fromModel) {\n      el.checked = checkedAttrLooseCompare(el.value, value);\n    }\n  } else if (el.type === \"checkbox\") {\n    if (Number.isInteger(value)) {\n      el.value = value;\n    } else if (!Number.isInteger(value) && !Array.isArray(value) && typeof value !== \"boolean\" && ![null, void 0].includes(value)) {\n      el.value = String(value);\n    } else {\n      if (Array.isArray(value)) {\n        el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));\n      } else {\n        el.checked = !!value;\n      }\n    }\n  } else if (el.tagName === \"SELECT\") {\n    updateSelect(el, value);\n  } else {\n    if (el.value === value)\n      return;\n    el.value = value;\n  }\n}\nfunction bindClasses(el, value) {\n  if (el._x_undoAddedClasses)\n    el._x_undoAddedClasses();\n  el._x_undoAddedClasses = setClasses(el, value);\n}\nfunction bindStyles(el, value) {\n  if (el._x_undoAddedStyles)\n    el._x_undoAddedStyles();\n  el._x_undoAddedStyles = setStyles(el, value);\n}\nfunction bindAttributeAndProperty(el, name, value) {\n  bindAttribute(el, name, value);\n  setPropertyIfChanged(el, name, value);\n}\nfunction bindAttribute(el, name, value) {\n  if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {\n    el.removeAttribute(name);\n  } else {\n    if (isBooleanAttr(name))\n      value = name;\n    setIfChanged(el, name, value);\n  }\n}\nfunction setIfChanged(el, attrName, value) {\n  if (el.getAttribute(attrName) != value) {\n    el.setAttribute(attrName, value);\n  }\n}\nfunction setPropertyIfChanged(el, propName, value) {\n  if (el[propName] !== value) {\n    el[propName] = value;\n  }\n}\nfunction updateSelect(el, value) {\n  const arrayWrappedValue = [].concat(value).map((value2) => {\n    return value2 + \"\";\n  });\n  Array.from(el.options).forEach((option) => {\n    option.selected = arrayWrappedValue.includes(option.value);\n  });\n}\nfunction camelCase(subject) {\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n}\nfunction checkedAttrLooseCompare(valueA, valueB) {\n  return valueA == valueB;\n}\nfunction isBooleanAttr(attrName) {\n  const booleanAttributes = [\n    \"disabled\",\n    \"checked\",\n    \"required\",\n    \"readonly\",\n    \"hidden\",\n    \"open\",\n    \"selected\",\n    \"autofocus\",\n    \"itemscope\",\n    \"multiple\",\n    \"novalidate\",\n    \"allowfullscreen\",\n    \"allowpaymentrequest\",\n    \"formnovalidate\",\n    \"autoplay\",\n    \"controls\",\n    \"loop\",\n    \"muted\",\n    \"playsinline\",\n    \"default\",\n    \"ismap\",\n    \"reversed\",\n    \"async\",\n    \"defer\",\n    \"nomodule\"\n  ];\n  return booleanAttributes.includes(attrName);\n}\nfunction attributeShouldntBePreservedIfFalsy(name) {\n  return ![\"aria-pressed\", \"aria-checked\", \"aria-expanded\", \"aria-selected\"].includes(name);\n}\nfunction getBinding(el, name, fallback) {\n  if (el._x_bindings && el._x_bindings[name] !== void 0)\n    return el._x_bindings[name];\n  let attr = el.getAttribute(name);\n  if (attr === null)\n    return typeof fallback === \"function\" ? fallback() : fallback;\n  if (attr === \"\")\n    return true;\n  if (isBooleanAttr(name)) {\n    return !![name, \"true\"].includes(attr);\n  }\n  return attr;\n}\n\n// packages/alpinejs/src/utils/debounce.js\nfunction debounce(func, wait) {\n  var timeout;\n  return function() {\n    var context = this, args = arguments;\n    var later = function() {\n      timeout = null;\n      func.apply(context, args);\n    };\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n// packages/alpinejs/src/utils/throttle.js\nfunction throttle(func, limit) {\n  let inThrottle;\n  return function() {\n    let context = this, args = arguments;\n    if (!inThrottle) {\n      func.apply(context, args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\n// packages/alpinejs/src/plugin.js\nfunction plugin(callback) {\n  let callbacks = Array.isArray(callback) ? callback : [callback];\n  callbacks.forEach((i) => i(alpine_default));\n}\n\n// packages/alpinejs/src/store.js\nvar stores = {};\nvar isReactive = false;\nfunction store(name, value) {\n  if (!isReactive) {\n    stores = reactive(stores);\n    isReactive = true;\n  }\n  if (value === void 0) {\n    return stores[name];\n  }\n  stores[name] = value;\n  if (typeof value === \"object\" && value !== null && value.hasOwnProperty(\"init\") && typeof value.init === \"function\") {\n    stores[name].init();\n  }\n  initInterceptors(stores[name]);\n}\nfunction getStores() {\n  return stores;\n}\n\n// packages/alpinejs/src/binds.js\nvar binds = {};\nfunction bind2(name, bindings) {\n  let getBindings = typeof bindings !== \"function\" ? () => bindings : bindings;\n  if (name instanceof Element) {\n    applyBindingsObject(name, getBindings());\n  } else {\n    binds[name] = getBindings;\n  }\n}\nfunction injectBindingProviders(obj) {\n  Object.entries(binds).forEach(([name, callback]) => {\n    Object.defineProperty(obj, name, {\n      get() {\n        return (...args) => {\n          return callback(...args);\n        };\n      }\n    });\n  });\n  return obj;\n}\nfunction applyBindingsObject(el, obj, original) {\n  let cleanupRunners = [];\n  while (cleanupRunners.length)\n    cleanupRunners.pop()();\n  let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }));\n  let staticAttributes = attributesOnly(attributes);\n  attributes = attributes.map((attribute) => {\n    if (staticAttributes.find((attr) => attr.name === attribute.name)) {\n      return {\n        name: `x-bind:${attribute.name}`,\n        value: `\"${attribute.value}\"`\n      };\n    }\n    return attribute;\n  });\n  directives(el, attributes, original).map((handle) => {\n    cleanupRunners.push(handle.runCleanups);\n    handle();\n  });\n}\n\n// packages/alpinejs/src/datas.js\nvar datas = {};\nfunction data(name, callback) {\n  datas[name] = callback;\n}\nfunction injectDataProviders(obj, context) {\n  Object.entries(datas).forEach(([name, callback]) => {\n    Object.defineProperty(obj, name, {\n      get() {\n        return (...args) => {\n          return callback.bind(context)(...args);\n        };\n      },\n      enumerable: false\n    });\n  });\n  return obj;\n}\n\n// packages/alpinejs/src/alpine.js\nvar Alpine = {\n  get reactive() {\n    return reactive;\n  },\n  get release() {\n    return release;\n  },\n  get effect() {\n    return effect;\n  },\n  get raw() {\n    return raw;\n  },\n  version: \"3.12.1\",\n  flushAndStopDeferringMutations,\n  dontAutoEvaluateFunctions,\n  disableEffectScheduling,\n  startObservingMutations,\n  stopObservingMutations,\n  setReactivityEngine,\n  closestDataStack,\n  skipDuringClone,\n  onlyDuringClone,\n  addRootSelector,\n  addInitSelector,\n  addScopeToNode,\n  deferMutations,\n  mapAttributes,\n  evaluateLater,\n  interceptInit,\n  setEvaluator,\n  mergeProxies,\n  findClosest,\n  closestRoot,\n  destroyTree,\n  interceptor,\n  // INTERNAL: not public API and is subject to change without major release.\n  transition,\n  // INTERNAL\n  setStyles,\n  // INTERNAL\n  mutateDom,\n  directive,\n  throttle,\n  debounce,\n  evaluate,\n  initTree,\n  nextTick,\n  prefixed: prefix,\n  prefix: setPrefix,\n  plugin,\n  magic,\n  store,\n  start,\n  clone,\n  bound: getBinding,\n  $data: scope,\n  walk,\n  data,\n  bind: bind2\n};\nvar alpine_default = Alpine;\n\n// packages/alpinejs/src/index.js\n\n\n// packages/alpinejs/src/magics/$nextTick.js\nmagic(\"nextTick\", () => nextTick);\n\n// packages/alpinejs/src/magics/$dispatch.js\nmagic(\"dispatch\", (el) => dispatch.bind(dispatch, el));\n\n// packages/alpinejs/src/magics/$watch.js\nmagic(\"watch\", (el, { evaluateLater: evaluateLater2, effect: effect3 }) => (key, callback) => {\n  let evaluate2 = evaluateLater2(key);\n  let firstTime = true;\n  let oldValue;\n  let effectReference = effect3(() => evaluate2((value) => {\n    JSON.stringify(value);\n    if (!firstTime) {\n      queueMicrotask(() => {\n        callback(value, oldValue);\n        oldValue = value;\n      });\n    } else {\n      oldValue = value;\n    }\n    firstTime = false;\n  }));\n  el._x_effects.delete(effectReference);\n});\n\n// packages/alpinejs/src/magics/$store.js\nmagic(\"store\", getStores);\n\n// packages/alpinejs/src/magics/$data.js\nmagic(\"data\", (el) => scope(el));\n\n// packages/alpinejs/src/magics/$root.js\nmagic(\"root\", (el) => closestRoot(el));\n\n// packages/alpinejs/src/magics/$refs.js\nmagic(\"refs\", (el) => {\n  if (el._x_refs_proxy)\n    return el._x_refs_proxy;\n  el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));\n  return el._x_refs_proxy;\n});\nfunction getArrayOfRefObject(el) {\n  let refObjects = [];\n  let currentEl = el;\n  while (currentEl) {\n    if (currentEl._x_refs)\n      refObjects.push(currentEl._x_refs);\n    currentEl = currentEl.parentNode;\n  }\n  return refObjects;\n}\n\n// packages/alpinejs/src/ids.js\nvar globalIdMemo = {};\nfunction findAndIncrementId(name) {\n  if (!globalIdMemo[name])\n    globalIdMemo[name] = 0;\n  return ++globalIdMemo[name];\n}\nfunction closestIdRoot(el, name) {\n  return findClosest(el, (element) => {\n    if (element._x_ids && element._x_ids[name])\n      return true;\n  });\n}\nfunction setIdRoot(el, name) {\n  if (!el._x_ids)\n    el._x_ids = {};\n  if (!el._x_ids[name])\n    el._x_ids[name] = findAndIncrementId(name);\n}\n\n// packages/alpinejs/src/magics/$id.js\nmagic(\"id\", (el) => (name, key = null) => {\n  let root = closestIdRoot(el, name);\n  let id = root ? root._x_ids[name] : findAndIncrementId(name);\n  return key ? `${name}-${id}-${key}` : `${name}-${id}`;\n});\n\n// packages/alpinejs/src/magics/$el.js\nmagic(\"el\", (el) => el);\n\n// packages/alpinejs/src/magics/index.js\nwarnMissingPluginMagic(\"Focus\", \"focus\", \"focus\");\nwarnMissingPluginMagic(\"Persist\", \"persist\", \"persist\");\nfunction warnMissingPluginMagic(name, magicName, slug) {\n  magic(magicName, (el) => warn(`You can't use [$${directiveName}] without first installing the \"${name}\" plugin here: https://alpinejs.dev/plugins/${slug}`, el));\n}\n\n// packages/alpinejs/src/entangle.js\nfunction entangle({ get: outerGet, set: outerSet }, { get: innerGet, set: innerSet }) {\n  let firstRun = true;\n  let outerHash, innerHash, outerHashLatest, innerHashLatest;\n  let reference = effect(() => {\n    let outer, inner;\n    if (firstRun) {\n      outer = outerGet();\n      innerSet(outer);\n      inner = innerGet();\n      firstRun = false;\n    } else {\n      outer = outerGet();\n      inner = innerGet();\n      outerHashLatest = JSON.stringify(outer);\n      innerHashLatest = JSON.stringify(inner);\n      if (outerHashLatest !== outerHash) {\n        inner = innerGet();\n        innerSet(outer);\n        inner = outer;\n      } else {\n        outerSet(inner);\n        outer = inner;\n      }\n    }\n    outerHash = JSON.stringify(outer);\n    innerHash = JSON.stringify(inner);\n  });\n  return () => {\n    release(reference);\n  };\n}\n\n// packages/alpinejs/src/directives/x-modelable.js\ndirective(\"modelable\", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2, cleanup }) => {\n  let func = evaluateLater2(expression);\n  let innerGet = () => {\n    let result;\n    func((i) => result = i);\n    return result;\n  };\n  let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);\n  let innerSet = (val) => evaluateInnerSet(() => {\n  }, { scope: { \"__placeholder\": val } });\n  let initialValue = innerGet();\n  innerSet(initialValue);\n  queueMicrotask(() => {\n    if (!el._x_model)\n      return;\n    el._x_removeModelListeners[\"default\"]();\n    let outerGet = el._x_model.get;\n    let outerSet = el._x_model.set;\n    let releaseEntanglement = entangle(\n      {\n        get() {\n          return outerGet();\n        },\n        set(value) {\n          outerSet(value);\n        }\n      },\n      {\n        get() {\n          return innerGet();\n        },\n        set(value) {\n          innerSet(value);\n        }\n      }\n    );\n    cleanup(releaseEntanglement);\n  });\n});\n\n// packages/alpinejs/src/directives/x-teleport.js\nvar teleportContainerDuringClone = document.createElement(\"div\");\ndirective(\"teleport\", (el, { modifiers, expression }, { cleanup }) => {\n  if (el.tagName.toLowerCase() !== \"template\")\n    warn(\"x-teleport can only be used on a <template> tag\", el);\n  let target = skipDuringClone(() => {\n    return document.querySelector(expression);\n  }, () => {\n    return teleportContainerDuringClone;\n  })();\n  if (!target)\n    warn(`Cannot find x-teleport element for selector: \"${expression}\"`);\n  let clone2 = el.content.cloneNode(true).firstElementChild;\n  el._x_teleport = clone2;\n  clone2._x_teleportBack = el;\n  if (el._x_forwardEvents) {\n    el._x_forwardEvents.forEach((eventName) => {\n      clone2.addEventListener(eventName, (e) => {\n        e.stopPropagation();\n        el.dispatchEvent(new e.constructor(e.type, e));\n      });\n    });\n  }\n  addScopeToNode(clone2, {}, el);\n  mutateDom(() => {\n    if (modifiers.includes(\"prepend\")) {\n      target.parentNode.insertBefore(clone2, target);\n    } else if (modifiers.includes(\"append\")) {\n      target.parentNode.insertBefore(clone2, target.nextSibling);\n    } else {\n      target.appendChild(clone2);\n    }\n    initTree(clone2);\n    clone2._x_ignore = true;\n  });\n  cleanup(() => clone2.remove());\n});\n\n// packages/alpinejs/src/directives/x-ignore.js\nvar handler = () => {\n};\nhandler.inline = (el, { modifiers }, { cleanup }) => {\n  modifiers.includes(\"self\") ? el._x_ignoreSelf = true : el._x_ignore = true;\n  cleanup(() => {\n    modifiers.includes(\"self\") ? delete el._x_ignoreSelf : delete el._x_ignore;\n  });\n};\ndirective(\"ignore\", handler);\n\n// packages/alpinejs/src/directives/x-effect.js\ndirective(\"effect\", (el, { expression }, { effect: effect3 }) => effect3(evaluateLater(el, expression)));\n\n// packages/alpinejs/src/utils/on.js\nfunction on(el, event, modifiers, callback) {\n  let listenerTarget = el;\n  let handler3 = (e) => callback(e);\n  let options = {};\n  let wrapHandler = (callback2, wrapper) => (e) => wrapper(callback2, e);\n  if (modifiers.includes(\"dot\"))\n    event = dotSyntax(event);\n  if (modifiers.includes(\"camel\"))\n    event = camelCase2(event);\n  if (modifiers.includes(\"passive\"))\n    options.passive = true;\n  if (modifiers.includes(\"capture\"))\n    options.capture = true;\n  if (modifiers.includes(\"window\"))\n    listenerTarget = window;\n  if (modifiers.includes(\"document\"))\n    listenerTarget = document;\n  if (modifiers.includes(\"debounce\")) {\n    let nextModifier = modifiers[modifiers.indexOf(\"debounce\") + 1] || \"invalid-wait\";\n    let wait = isNumeric(nextModifier.split(\"ms\")[0]) ? Number(nextModifier.split(\"ms\")[0]) : 250;\n    handler3 = debounce(handler3, wait);\n  }\n  if (modifiers.includes(\"throttle\")) {\n    let nextModifier = modifiers[modifiers.indexOf(\"throttle\") + 1] || \"invalid-wait\";\n    let wait = isNumeric(nextModifier.split(\"ms\")[0]) ? Number(nextModifier.split(\"ms\")[0]) : 250;\n    handler3 = throttle(handler3, wait);\n  }\n  if (modifiers.includes(\"prevent\"))\n    handler3 = wrapHandler(handler3, (next, e) => {\n      e.preventDefault();\n      next(e);\n    });\n  if (modifiers.includes(\"stop\"))\n    handler3 = wrapHandler(handler3, (next, e) => {\n      e.stopPropagation();\n      next(e);\n    });\n  if (modifiers.includes(\"self\"))\n    handler3 = wrapHandler(handler3, (next, e) => {\n      e.target === el && next(e);\n    });\n  if (modifiers.includes(\"away\") || modifiers.includes(\"outside\")) {\n    listenerTarget = document;\n    handler3 = wrapHandler(handler3, (next, e) => {\n      if (el.contains(e.target))\n        return;\n      if (e.target.isConnected === false)\n        return;\n      if (el.offsetWidth < 1 && el.offsetHeight < 1)\n        return;\n      if (el._x_isShown === false)\n        return;\n      next(e);\n    });\n  }\n  if (modifiers.includes(\"once\")) {\n    handler3 = wrapHandler(handler3, (next, e) => {\n      next(e);\n      listenerTarget.removeEventListener(event, handler3, options);\n    });\n  }\n  handler3 = wrapHandler(handler3, (next, e) => {\n    if (isKeyEvent(event)) {\n      if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {\n        return;\n      }\n    }\n    next(e);\n  });\n  listenerTarget.addEventListener(event, handler3, options);\n  return () => {\n    listenerTarget.removeEventListener(event, handler3, options);\n  };\n}\nfunction dotSyntax(subject) {\n  return subject.replace(/-/g, \".\");\n}\nfunction camelCase2(subject) {\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n}\nfunction isNumeric(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\nfunction kebabCase2(subject) {\n  if ([\" \", \"_\"].includes(\n    subject\n  ))\n    return subject;\n  return subject.replace(/([a-z])([A-Z])/g, \"$1-$2\").replace(/[_\\s]/, \"-\").toLowerCase();\n}\nfunction isKeyEvent(event) {\n  return [\"keydown\", \"keyup\"].includes(event);\n}\nfunction isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {\n  let keyModifiers = modifiers.filter((i) => {\n    return ![\"window\", \"document\", \"prevent\", \"stop\", \"once\", \"capture\"].includes(i);\n  });\n  if (keyModifiers.includes(\"debounce\")) {\n    let debounceIndex = keyModifiers.indexOf(\"debounce\");\n    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || \"invalid-wait\").split(\"ms\")[0]) ? 2 : 1);\n  }\n  if (keyModifiers.includes(\"throttle\")) {\n    let debounceIndex = keyModifiers.indexOf(\"throttle\");\n    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || \"invalid-wait\").split(\"ms\")[0]) ? 2 : 1);\n  }\n  if (keyModifiers.length === 0)\n    return false;\n  if (keyModifiers.length === 1 && keyToModifiers(e.key).includes(keyModifiers[0]))\n    return false;\n  const systemKeyModifiers = [\"ctrl\", \"shift\", \"alt\", \"meta\", \"cmd\", \"super\"];\n  const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));\n  keyModifiers = keyModifiers.filter((i) => !selectedSystemKeyModifiers.includes(i));\n  if (selectedSystemKeyModifiers.length > 0) {\n    const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {\n      if (modifier === \"cmd\" || modifier === \"super\")\n        modifier = \"meta\";\n      return e[`${modifier}Key`];\n    });\n    if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {\n      if (keyToModifiers(e.key).includes(keyModifiers[0]))\n        return false;\n    }\n  }\n  return true;\n}\nfunction keyToModifiers(key) {\n  if (!key)\n    return [];\n  key = kebabCase2(key);\n  let modifierToKeyMap = {\n    \"ctrl\": \"control\",\n    \"slash\": \"/\",\n    \"space\": \" \",\n    \"spacebar\": \" \",\n    \"cmd\": \"meta\",\n    \"esc\": \"escape\",\n    \"up\": \"arrow-up\",\n    \"down\": \"arrow-down\",\n    \"left\": \"arrow-left\",\n    \"right\": \"arrow-right\",\n    \"period\": \".\",\n    \"equal\": \"=\",\n    \"minus\": \"-\",\n    \"underscore\": \"_\"\n  };\n  modifierToKeyMap[key] = key;\n  return Object.keys(modifierToKeyMap).map((modifier) => {\n    if (modifierToKeyMap[modifier] === key)\n      return modifier;\n  }).filter((modifier) => modifier);\n}\n\n// packages/alpinejs/src/directives/x-model.js\ndirective(\"model\", (el, { modifiers, expression }, { effect: effect3, cleanup }) => {\n  let scopeTarget = el;\n  if (modifiers.includes(\"parent\")) {\n    scopeTarget = el.parentNode;\n  }\n  let evaluateGet = evaluateLater(scopeTarget, expression);\n  let evaluateSet;\n  if (typeof expression === \"string\") {\n    evaluateSet = evaluateLater(scopeTarget, `${expression} = __placeholder`);\n  } else if (typeof expression === \"function\" && typeof expression() === \"string\") {\n    evaluateSet = evaluateLater(scopeTarget, `${expression()} = __placeholder`);\n  } else {\n    evaluateSet = () => {\n    };\n  }\n  let getValue = () => {\n    let result;\n    evaluateGet((value) => result = value);\n    return isGetterSetter(result) ? result.get() : result;\n  };\n  let setValue = (value) => {\n    let result;\n    evaluateGet((value2) => result = value2);\n    if (isGetterSetter(result)) {\n      result.set(value);\n    } else {\n      evaluateSet(() => {\n      }, {\n        scope: { \"__placeholder\": value }\n      });\n    }\n  };\n  if (typeof expression === \"string\" && el.type === \"radio\") {\n    mutateDom(() => {\n      if (!el.hasAttribute(\"name\"))\n        el.setAttribute(\"name\", expression);\n    });\n  }\n  var event = el.tagName.toLowerCase() === \"select\" || [\"checkbox\", \"radio\"].includes(el.type) || modifiers.includes(\"lazy\") ? \"change\" : \"input\";\n  let removeListener = isCloning ? () => {\n  } : on(el, event, modifiers, (e) => {\n    setValue(getInputValue(el, modifiers, e, getValue()));\n  });\n  if (modifiers.includes(\"fill\") && [null, \"\"].includes(getValue())) {\n    el.dispatchEvent(new Event(event, {}));\n  }\n  if (!el._x_removeModelListeners)\n    el._x_removeModelListeners = {};\n  el._x_removeModelListeners[\"default\"] = removeListener;\n  cleanup(() => el._x_removeModelListeners[\"default\"]());\n  if (el.form) {\n    let removeResetListener = on(el.form, \"reset\", [], (e) => {\n      nextTick(() => el._x_model && el._x_model.set(el.value));\n    });\n    cleanup(() => removeResetListener());\n  }\n  el._x_model = {\n    get() {\n      return getValue();\n    },\n    set(value) {\n      setValue(value);\n    }\n  };\n  el._x_forceModelUpdate = (value) => {\n    value = value === void 0 ? getValue() : value;\n    if (value === void 0 && typeof expression === \"string\" && expression.match(/\\./))\n      value = \"\";\n    window.fromModel = true;\n    mutateDom(() => bind(el, \"value\", value));\n    delete window.fromModel;\n  };\n  effect3(() => {\n    let value = getValue();\n    if (modifiers.includes(\"unintrusive\") && document.activeElement.isSameNode(el))\n      return;\n    el._x_forceModelUpdate(value);\n  });\n});\nfunction getInputValue(el, modifiers, event, currentValue) {\n  return mutateDom(() => {\n    if (event instanceof CustomEvent && event.detail !== void 0)\n      return event.detail ?? event.target.value;\n    else if (el.type === \"checkbox\") {\n      if (Array.isArray(currentValue)) {\n        let newValue = modifiers.includes(\"number\") ? safeParseNumber(event.target.value) : event.target.value;\n        return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));\n      } else {\n        return event.target.checked;\n      }\n    } else if (el.tagName.toLowerCase() === \"select\" && el.multiple) {\n      return modifiers.includes(\"number\") ? Array.from(event.target.selectedOptions).map((option) => {\n        let rawValue = option.value || option.text;\n        return safeParseNumber(rawValue);\n      }) : Array.from(event.target.selectedOptions).map((option) => {\n        return option.value || option.text;\n      });\n    } else {\n      let rawValue = event.target.value;\n      return modifiers.includes(\"number\") ? safeParseNumber(rawValue) : modifiers.includes(\"trim\") ? rawValue.trim() : rawValue;\n    }\n  });\n}\nfunction safeParseNumber(rawValue) {\n  let number = rawValue ? parseFloat(rawValue) : null;\n  return isNumeric2(number) ? number : rawValue;\n}\nfunction checkedAttrLooseCompare2(valueA, valueB) {\n  return valueA == valueB;\n}\nfunction isNumeric2(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\nfunction isGetterSetter(value) {\n  return value !== null && typeof value === \"object\" && typeof value.get === \"function\" && typeof value.set === \"function\";\n}\n\n// packages/alpinejs/src/directives/x-cloak.js\ndirective(\"cloak\", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix(\"cloak\")))));\n\n// packages/alpinejs/src/directives/x-init.js\naddInitSelector(() => `[${prefix(\"init\")}]`);\ndirective(\"init\", skipDuringClone((el, { expression }, { evaluate: evaluate2 }) => {\n  if (typeof expression === \"string\") {\n    return !!expression.trim() && evaluate2(expression, {}, false);\n  }\n  return evaluate2(expression, {}, false);\n}));\n\n// packages/alpinejs/src/directives/x-text.js\ndirective(\"text\", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {\n  let evaluate2 = evaluateLater2(expression);\n  effect3(() => {\n    evaluate2((value) => {\n      mutateDom(() => {\n        el.textContent = value;\n      });\n    });\n  });\n});\n\n// packages/alpinejs/src/directives/x-html.js\ndirective(\"html\", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {\n  let evaluate2 = evaluateLater2(expression);\n  effect3(() => {\n    evaluate2((value) => {\n      mutateDom(() => {\n        el.innerHTML = value;\n        el._x_ignoreSelf = true;\n        initTree(el);\n        delete el._x_ignoreSelf;\n      });\n    });\n  });\n});\n\n// packages/alpinejs/src/directives/x-bind.js\nmapAttributes(startingWith(\":\", into(prefix(\"bind:\"))));\ndirective(\"bind\", (el, { value, modifiers, expression, original }, { effect: effect3 }) => {\n  if (!value) {\n    let bindingProviders = {};\n    injectBindingProviders(bindingProviders);\n    let getBindings = evaluateLater(el, expression);\n    getBindings((bindings) => {\n      applyBindingsObject(el, bindings, original);\n    }, { scope: bindingProviders });\n    return;\n  }\n  if (value === \"key\")\n    return storeKeyForXFor(el, expression);\n  let evaluate2 = evaluateLater(el, expression);\n  effect3(() => evaluate2((result) => {\n    if (result === void 0 && typeof expression === \"string\" && expression.match(/\\./)) {\n      result = \"\";\n    }\n    mutateDom(() => bind(el, value, result, modifiers));\n  }));\n});\nfunction storeKeyForXFor(el, expression) {\n  el._x_keyExpression = expression;\n}\n\n// packages/alpinejs/src/directives/x-data.js\naddRootSelector(() => `[${prefix(\"data\")}]`);\ndirective(\"data\", skipDuringClone((el, { expression }, { cleanup }) => {\n  expression = expression === \"\" ? \"{}\" : expression;\n  let magicContext = {};\n  injectMagics(magicContext, el);\n  let dataProviderContext = {};\n  injectDataProviders(dataProviderContext, magicContext);\n  let data2 = evaluate(el, expression, { scope: dataProviderContext });\n  if (data2 === void 0 || data2 === true)\n    data2 = {};\n  injectMagics(data2, el);\n  let reactiveData = reactive(data2);\n  initInterceptors(reactiveData);\n  let undo = addScopeToNode(el, reactiveData);\n  reactiveData[\"init\"] && evaluate(el, reactiveData[\"init\"]);\n  cleanup(() => {\n    reactiveData[\"destroy\"] && evaluate(el, reactiveData[\"destroy\"]);\n    undo();\n  });\n}));\n\n// packages/alpinejs/src/directives/x-show.js\ndirective(\"show\", (el, { modifiers, expression }, { effect: effect3 }) => {\n  let evaluate2 = evaluateLater(el, expression);\n  if (!el._x_doHide)\n    el._x_doHide = () => {\n      mutateDom(() => {\n        el.style.setProperty(\"display\", \"none\", modifiers.includes(\"important\") ? \"important\" : void 0);\n      });\n    };\n  if (!el._x_doShow)\n    el._x_doShow = () => {\n      mutateDom(() => {\n        if (el.style.length === 1 && el.style.display === \"none\") {\n          el.removeAttribute(\"style\");\n        } else {\n          el.style.removeProperty(\"display\");\n        }\n      });\n    };\n  let hide = () => {\n    el._x_doHide();\n    el._x_isShown = false;\n  };\n  let show = () => {\n    el._x_doShow();\n    el._x_isShown = true;\n  };\n  let clickAwayCompatibleShow = () => setTimeout(show);\n  let toggle = once(\n    (value) => value ? show() : hide(),\n    (value) => {\n      if (typeof el._x_toggleAndCascadeWithTransitions === \"function\") {\n        el._x_toggleAndCascadeWithTransitions(el, value, show, hide);\n      } else {\n        value ? clickAwayCompatibleShow() : hide();\n      }\n    }\n  );\n  let oldValue;\n  let firstTime = true;\n  effect3(() => evaluate2((value) => {\n    if (!firstTime && value === oldValue)\n      return;\n    if (modifiers.includes(\"immediate\"))\n      value ? clickAwayCompatibleShow() : hide();\n    toggle(value);\n    oldValue = value;\n    firstTime = false;\n  }));\n});\n\n// packages/alpinejs/src/directives/x-for.js\ndirective(\"for\", (el, { expression }, { effect: effect3, cleanup }) => {\n  let iteratorNames = parseForExpression(expression);\n  let evaluateItems = evaluateLater(el, iteratorNames.items);\n  let evaluateKey = evaluateLater(\n    el,\n    // the x-bind:key expression is stored for our use instead of evaluated.\n    el._x_keyExpression || \"index\"\n  );\n  el._x_prevKeys = [];\n  el._x_lookup = {};\n  effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));\n  cleanup(() => {\n    Object.values(el._x_lookup).forEach((el2) => el2.remove());\n    delete el._x_prevKeys;\n    delete el._x_lookup;\n  });\n});\nfunction loop(el, iteratorNames, evaluateItems, evaluateKey) {\n  let isObject = (i) => typeof i === \"object\" && !Array.isArray(i);\n  let templateEl = el;\n  evaluateItems((items) => {\n    if (isNumeric3(items) && items >= 0) {\n      items = Array.from(Array(items).keys(), (i) => i + 1);\n    }\n    if (items === void 0)\n      items = [];\n    let lookup = el._x_lookup;\n    let prevKeys = el._x_prevKeys;\n    let scopes = [];\n    let keys = [];\n    if (isObject(items)) {\n      items = Object.entries(items).map(([key, value]) => {\n        let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);\n        evaluateKey((value2) => keys.push(value2), { scope: { index: key, ...scope2 } });\n        scopes.push(scope2);\n      });\n    } else {\n      for (let i = 0; i < items.length; i++) {\n        let scope2 = getIterationScopeVariables(iteratorNames, items[i], i, items);\n        evaluateKey((value) => keys.push(value), { scope: { index: i, ...scope2 } });\n        scopes.push(scope2);\n      }\n    }\n    let adds = [];\n    let moves = [];\n    let removes = [];\n    let sames = [];\n    for (let i = 0; i < prevKeys.length; i++) {\n      let key = prevKeys[i];\n      if (keys.indexOf(key) === -1)\n        removes.push(key);\n    }\n    prevKeys = prevKeys.filter((key) => !removes.includes(key));\n    let lastKey = \"template\";\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i];\n      let prevIndex = prevKeys.indexOf(key);\n      if (prevIndex === -1) {\n        prevKeys.splice(i, 0, key);\n        adds.push([lastKey, i]);\n      } else if (prevIndex !== i) {\n        let keyInSpot = prevKeys.splice(i, 1)[0];\n        let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];\n        prevKeys.splice(i, 0, keyForSpot);\n        prevKeys.splice(prevIndex, 0, keyInSpot);\n        moves.push([keyInSpot, keyForSpot]);\n      } else {\n        sames.push(key);\n      }\n      lastKey = key;\n    }\n    for (let i = 0; i < removes.length; i++) {\n      let key = removes[i];\n      if (!!lookup[key]._x_effects) {\n        lookup[key]._x_effects.forEach(dequeueJob);\n      }\n      lookup[key].remove();\n      lookup[key] = null;\n      delete lookup[key];\n    }\n    for (let i = 0; i < moves.length; i++) {\n      let [keyInSpot, keyForSpot] = moves[i];\n      let elInSpot = lookup[keyInSpot];\n      let elForSpot = lookup[keyForSpot];\n      let marker = document.createElement(\"div\");\n      mutateDom(() => {\n        if (!elForSpot)\n          warn(`x-for \":key\" is undefined or invalid`, templateEl);\n        elForSpot.after(marker);\n        elInSpot.after(elForSpot);\n        elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);\n        marker.before(elInSpot);\n        elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);\n        marker.remove();\n      });\n      elForSpot._x_refreshXForScope(scopes[keys.indexOf(keyForSpot)]);\n    }\n    for (let i = 0; i < adds.length; i++) {\n      let [lastKey2, index] = adds[i];\n      let lastEl = lastKey2 === \"template\" ? templateEl : lookup[lastKey2];\n      if (lastEl._x_currentIfEl)\n        lastEl = lastEl._x_currentIfEl;\n      let scope2 = scopes[index];\n      let key = keys[index];\n      let clone2 = document.importNode(templateEl.content, true).firstElementChild;\n      let reactiveScope = reactive(scope2);\n      addScopeToNode(clone2, reactiveScope, templateEl);\n      clone2._x_refreshXForScope = (newScope) => {\n        Object.entries(newScope).forEach(([key2, value]) => {\n          reactiveScope[key2] = value;\n        });\n      };\n      mutateDom(() => {\n        lastEl.after(clone2);\n        initTree(clone2);\n      });\n      if (typeof key === \"object\") {\n        warn(\"x-for key cannot be an object, it must be a string or an integer\", templateEl);\n      }\n      lookup[key] = clone2;\n    }\n    for (let i = 0; i < sames.length; i++) {\n      lookup[sames[i]]._x_refreshXForScope(scopes[keys.indexOf(sames[i])]);\n    }\n    templateEl._x_prevKeys = keys;\n  });\n}\nfunction parseForExpression(expression) {\n  let forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  let stripParensRE = /^\\s*\\(|\\)\\s*$/g;\n  let forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  let inMatch = expression.match(forAliasRE);\n  if (!inMatch)\n    return;\n  let res = {};\n  res.items = inMatch[2].trim();\n  let item = inMatch[1].replace(stripParensRE, \"\").trim();\n  let iteratorMatch = item.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.item = item.replace(forIteratorRE, \"\").trim();\n    res.index = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.collection = iteratorMatch[2].trim();\n    }\n  } else {\n    res.item = item;\n  }\n  return res;\n}\nfunction getIterationScopeVariables(iteratorNames, item, index, items) {\n  let scopeVariables = {};\n  if (/^\\[.*\\]$/.test(iteratorNames.item) && Array.isArray(item)) {\n    let names = iteratorNames.item.replace(\"[\", \"\").replace(\"]\", \"\").split(\",\").map((i) => i.trim());\n    names.forEach((name, i) => {\n      scopeVariables[name] = item[i];\n    });\n  } else if (/^\\{.*\\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === \"object\") {\n    let names = iteratorNames.item.replace(\"{\", \"\").replace(\"}\", \"\").split(\",\").map((i) => i.trim());\n    names.forEach((name) => {\n      scopeVariables[name] = item[name];\n    });\n  } else {\n    scopeVariables[iteratorNames.item] = item;\n  }\n  if (iteratorNames.index)\n    scopeVariables[iteratorNames.index] = index;\n  if (iteratorNames.collection)\n    scopeVariables[iteratorNames.collection] = items;\n  return scopeVariables;\n}\nfunction isNumeric3(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\n\n// packages/alpinejs/src/directives/x-ref.js\nfunction handler2() {\n}\nhandler2.inline = (el, { expression }, { cleanup }) => {\n  let root = closestRoot(el);\n  if (!root._x_refs)\n    root._x_refs = {};\n  root._x_refs[expression] = el;\n  cleanup(() => delete root._x_refs[expression]);\n};\ndirective(\"ref\", handler2);\n\n// packages/alpinejs/src/directives/x-if.js\ndirective(\"if\", (el, { expression }, { effect: effect3, cleanup }) => {\n  let evaluate2 = evaluateLater(el, expression);\n  let show = () => {\n    if (el._x_currentIfEl)\n      return el._x_currentIfEl;\n    let clone2 = el.content.cloneNode(true).firstElementChild;\n    addScopeToNode(clone2, {}, el);\n    mutateDom(() => {\n      el.after(clone2);\n      initTree(clone2);\n    });\n    el._x_currentIfEl = clone2;\n    el._x_undoIf = () => {\n      walk(clone2, (node) => {\n        if (!!node._x_effects) {\n          node._x_effects.forEach(dequeueJob);\n        }\n      });\n      clone2.remove();\n      delete el._x_currentIfEl;\n    };\n    return clone2;\n  };\n  let hide = () => {\n    if (!el._x_undoIf)\n      return;\n    el._x_undoIf();\n    delete el._x_undoIf;\n  };\n  effect3(() => evaluate2((value) => {\n    value ? show() : hide();\n  }));\n  cleanup(() => el._x_undoIf && el._x_undoIf());\n});\n\n// packages/alpinejs/src/directives/x-id.js\ndirective(\"id\", (el, { expression }, { evaluate: evaluate2 }) => {\n  let names = evaluate2(expression);\n  names.forEach((name) => setIdRoot(el, name));\n});\n\n// packages/alpinejs/src/directives/x-on.js\nmapAttributes(startingWith(\"@\", into(prefix(\"on:\"))));\ndirective(\"on\", skipDuringClone((el, { value, modifiers, expression }, { cleanup }) => {\n  let evaluate2 = expression ? evaluateLater(el, expression) : () => {\n  };\n  if (el.tagName.toLowerCase() === \"template\") {\n    if (!el._x_forwardEvents)\n      el._x_forwardEvents = [];\n    if (!el._x_forwardEvents.includes(value))\n      el._x_forwardEvents.push(value);\n  }\n  let removeListener = on(el, value, modifiers, (e) => {\n    evaluate2(() => {\n    }, { scope: { \"$event\": e }, params: [e] });\n  });\n  cleanup(() => removeListener());\n}));\n\n// packages/alpinejs/src/directives/index.js\nwarnMissingPluginDirective(\"Collapse\", \"collapse\", \"collapse\");\nwarnMissingPluginDirective(\"Intersect\", \"intersect\", \"intersect\");\nwarnMissingPluginDirective(\"Focus\", \"trap\", \"focus\");\nwarnMissingPluginDirective(\"Mask\", \"mask\", \"mask\");\nfunction warnMissingPluginDirective(name, directiveName2, slug) {\n  directive(directiveName2, (el) => warn(`You can't use [x-${directiveName2}] without first installing the \"${name}\" plugin here: https://alpinejs.dev/plugins/${slug}`, el));\n}\n\n// packages/alpinejs/src/index.js\nalpine_default.setEvaluator(normalEvaluator);\nalpine_default.setReactivityEngine({ reactive: _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive, effect: _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect, release: _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop, raw: _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw });\nvar src_default = alpine_default;\n\n// packages/alpinejs/builds/module.js\nvar module_default = src_default;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vYWxwaW5lanNAMy4xMi4xL25vZGVfbW9kdWxlcy9hbHBpbmVqcy9kaXN0L21vZHVsZS5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkVBQTJFO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLDhCQUE4QixJQUFJLHFCQUFxQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQSxlQUFlLDhEQUE4RDtBQUM3RSxlQUFlLDhEQUE4RDtBQUM3RTtBQUNBLE9BQU87QUFDUCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9EQUFvRCxpQ0FBaUM7QUFDckYsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNkJBQTZCLElBQUk7QUFDeEUsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSx1QkFBdUIsWUFBWSxJQUFJLHFCQUFxQjtBQUM1RDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsdUNBQXVDLDhCQUE4QixJQUFJLFNBQVM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUksU0FBUyxhQUFhLGVBQWU7QUFDOUMsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZUFBZSxrQ0FBa0MsS0FBSyw4Q0FBOEMsS0FBSztBQUN0Szs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLFVBQVUscURBQVMsVUFBVSxtREFBTyxXQUFXLGlEQUFJLE9BQU8sa0RBQUssRUFBRTtBQUN0Rzs7QUFFQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW5wcmlzZS1mcm9udGVuZC10b29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2FscGluZWpzQDMuMTIuMS9ub2RlX21vZHVsZXMvYWxwaW5lanMvZGlzdC9tb2R1bGUuZXNtLmpzP2YzYjYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3NjaGVkdWxlci5qc1xudmFyIGZsdXNoUGVuZGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgcXVldWUgPSBbXTtcbnZhciBsYXN0Rmx1c2hlZEluZGV4ID0gLTE7XG5mdW5jdGlvbiBzY2hlZHVsZXIoY2FsbGJhY2spIHtcbiAgcXVldWVKb2IoY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gcXVldWVKb2Ioam9iKSB7XG4gIGlmICghcXVldWUuaW5jbHVkZXMoam9iKSlcbiAgICBxdWV1ZS5wdXNoKGpvYik7XG4gIHF1ZXVlRmx1c2goKTtcbn1cbmZ1bmN0aW9uIGRlcXVldWVKb2Ioam9iKSB7XG4gIGxldCBpbmRleCA9IHF1ZXVlLmluZGV4T2Yoam9iKTtcbiAgaWYgKGluZGV4ICE9PSAtMSAmJiBpbmRleCA+IGxhc3RGbHVzaGVkSW5kZXgpXG4gICAgcXVldWUuc3BsaWNlKGluZGV4LCAxKTtcbn1cbmZ1bmN0aW9uIHF1ZXVlRmx1c2goKSB7XG4gIGlmICghZmx1c2hpbmcgJiYgIWZsdXNoUGVuZGluZykge1xuICAgIGZsdXNoUGVuZGluZyA9IHRydWU7XG4gICAgcXVldWVNaWNyb3Rhc2soZmx1c2hKb2JzKTtcbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hKb2JzKCkge1xuICBmbHVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0oKTtcbiAgICBsYXN0Rmx1c2hlZEluZGV4ID0gaTtcbiAgfVxuICBxdWV1ZS5sZW5ndGggPSAwO1xuICBsYXN0Rmx1c2hlZEluZGV4ID0gLTE7XG4gIGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9yZWFjdGl2aXR5LmpzXG52YXIgcmVhY3RpdmU7XG52YXIgZWZmZWN0O1xudmFyIHJlbGVhc2U7XG52YXIgcmF3O1xudmFyIHNob3VsZFNjaGVkdWxlID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVFZmZlY3RTY2hlZHVsaW5nKGNhbGxiYWNrKSB7XG4gIHNob3VsZFNjaGVkdWxlID0gZmFsc2U7XG4gIGNhbGxiYWNrKCk7XG4gIHNob3VsZFNjaGVkdWxlID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNldFJlYWN0aXZpdHlFbmdpbmUoZW5naW5lKSB7XG4gIHJlYWN0aXZlID0gZW5naW5lLnJlYWN0aXZlO1xuICByZWxlYXNlID0gZW5naW5lLnJlbGVhc2U7XG4gIGVmZmVjdCA9IChjYWxsYmFjaykgPT4gZW5naW5lLmVmZmVjdChjYWxsYmFjaywgeyBzY2hlZHVsZXI6ICh0YXNrKSA9PiB7XG4gICAgaWYgKHNob3VsZFNjaGVkdWxlKSB7XG4gICAgICBzY2hlZHVsZXIodGFzayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhc2soKTtcbiAgICB9XG4gIH0gfSk7XG4gIHJhdyA9IGVuZ2luZS5yYXc7XG59XG5mdW5jdGlvbiBvdmVycmlkZUVmZmVjdChvdmVycmlkZSkge1xuICBlZmZlY3QgPSBvdmVycmlkZTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRCb3VuZEVmZmVjdChlbCkge1xuICBsZXQgY2xlYW51cCA9ICgpID0+IHtcbiAgfTtcbiAgbGV0IHdyYXBwZWRFZmZlY3QgPSAoY2FsbGJhY2spID0+IHtcbiAgICBsZXQgZWZmZWN0UmVmZXJlbmNlID0gZWZmZWN0KGNhbGxiYWNrKTtcbiAgICBpZiAoIWVsLl94X2VmZmVjdHMpIHtcbiAgICAgIGVsLl94X2VmZmVjdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgZWwuX3hfcnVuRWZmZWN0cyA9ICgpID0+IHtcbiAgICAgICAgZWwuX3hfZWZmZWN0cy5mb3JFYWNoKChpKSA9PiBpKCkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZWwuX3hfZWZmZWN0cy5hZGQoZWZmZWN0UmVmZXJlbmNlKTtcbiAgICBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgaWYgKGVmZmVjdFJlZmVyZW5jZSA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBlbC5feF9lZmZlY3RzLmRlbGV0ZShlZmZlY3RSZWZlcmVuY2UpO1xuICAgICAgcmVsZWFzZShlZmZlY3RSZWZlcmVuY2UpO1xuICAgIH07XG4gICAgcmV0dXJuIGVmZmVjdFJlZmVyZW5jZTtcbiAgfTtcbiAgcmV0dXJuIFt3cmFwcGVkRWZmZWN0LCAoKSA9PiB7XG4gICAgY2xlYW51cCgpO1xuICB9XTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL211dGF0aW9uLmpzXG52YXIgb25BdHRyaWJ1dGVBZGRlZHMgPSBbXTtcbnZhciBvbkVsUmVtb3ZlZHMgPSBbXTtcbnZhciBvbkVsQWRkZWRzID0gW107XG5mdW5jdGlvbiBvbkVsQWRkZWQoY2FsbGJhY2spIHtcbiAgb25FbEFkZGVkcy5wdXNoKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIG9uRWxSZW1vdmVkKGVsLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpZiAoIWVsLl94X2NsZWFudXBzKVxuICAgICAgZWwuX3hfY2xlYW51cHMgPSBbXTtcbiAgICBlbC5feF9jbGVhbnVwcy5wdXNoKGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjayA9IGVsO1xuICAgIG9uRWxSZW1vdmVkcy5wdXNoKGNhbGxiYWNrKTtcbiAgfVxufVxuZnVuY3Rpb24gb25BdHRyaWJ1dGVzQWRkZWQoY2FsbGJhY2spIHtcbiAgb25BdHRyaWJ1dGVBZGRlZHMucHVzaChjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBvbkF0dHJpYnV0ZVJlbW92ZWQoZWwsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIGlmICghZWwuX3hfYXR0cmlidXRlQ2xlYW51cHMpXG4gICAgZWwuX3hfYXR0cmlidXRlQ2xlYW51cHMgPSB7fTtcbiAgaWYgKCFlbC5feF9hdHRyaWJ1dGVDbGVhbnVwc1tuYW1lXSlcbiAgICBlbC5feF9hdHRyaWJ1dGVDbGVhbnVwc1tuYW1lXSA9IFtdO1xuICBlbC5feF9hdHRyaWJ1dGVDbGVhbnVwc1tuYW1lXS5wdXNoKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGNsZWFudXBBdHRyaWJ1dGVzKGVsLCBuYW1lcykge1xuICBpZiAoIWVsLl94X2F0dHJpYnV0ZUNsZWFudXBzKVxuICAgIHJldHVybjtcbiAgT2JqZWN0LmVudHJpZXMoZWwuX3hfYXR0cmlidXRlQ2xlYW51cHMpLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICBpZiAobmFtZXMgPT09IHZvaWQgMCB8fCBuYW1lcy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgdmFsdWUuZm9yRWFjaCgoaSkgPT4gaSgpKTtcbiAgICAgIGRlbGV0ZSBlbC5feF9hdHRyaWJ1dGVDbGVhbnVwc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufVxudmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIob25NdXRhdGUpO1xudmFyIGN1cnJlbnRseU9ic2VydmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gc3RhcnRPYnNlcnZpbmdNdXRhdGlvbnMoKSB7XG4gIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHsgc3VidHJlZTogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBhdHRyaWJ1dGVzOiB0cnVlLCBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSB9KTtcbiAgY3VycmVudGx5T2JzZXJ2aW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHN0b3BPYnNlcnZpbmdNdXRhdGlvbnMoKSB7XG4gIGZsdXNoT2JzZXJ2ZXIoKTtcbiAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICBjdXJyZW50bHlPYnNlcnZpbmcgPSBmYWxzZTtcbn1cbnZhciByZWNvcmRRdWV1ZSA9IFtdO1xudmFyIHdpbGxQcm9jZXNzUmVjb3JkUXVldWUgPSBmYWxzZTtcbmZ1bmN0aW9uIGZsdXNoT2JzZXJ2ZXIoKSB7XG4gIHJlY29yZFF1ZXVlID0gcmVjb3JkUXVldWUuY29uY2F0KG9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICBpZiAocmVjb3JkUXVldWUubGVuZ3RoICYmICF3aWxsUHJvY2Vzc1JlY29yZFF1ZXVlKSB7XG4gICAgd2lsbFByb2Nlc3NSZWNvcmRRdWV1ZSA9IHRydWU7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgcHJvY2Vzc1JlY29yZFF1ZXVlKCk7XG4gICAgICB3aWxsUHJvY2Vzc1JlY29yZFF1ZXVlID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NSZWNvcmRRdWV1ZSgpIHtcbiAgb25NdXRhdGUocmVjb3JkUXVldWUpO1xuICByZWNvcmRRdWV1ZS5sZW5ndGggPSAwO1xufVxuZnVuY3Rpb24gbXV0YXRlRG9tKGNhbGxiYWNrKSB7XG4gIGlmICghY3VycmVudGx5T2JzZXJ2aW5nKVxuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICBzdG9wT2JzZXJ2aW5nTXV0YXRpb25zKCk7XG4gIGxldCByZXN1bHQgPSBjYWxsYmFjaygpO1xuICBzdGFydE9ic2VydmluZ011dGF0aW9ucygpO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIGlzQ29sbGVjdGluZyA9IGZhbHNlO1xudmFyIGRlZmVycmVkTXV0YXRpb25zID0gW107XG5mdW5jdGlvbiBkZWZlck11dGF0aW9ucygpIHtcbiAgaXNDb2xsZWN0aW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGZsdXNoQW5kU3RvcERlZmVycmluZ011dGF0aW9ucygpIHtcbiAgaXNDb2xsZWN0aW5nID0gZmFsc2U7XG4gIG9uTXV0YXRlKGRlZmVycmVkTXV0YXRpb25zKTtcbiAgZGVmZXJyZWRNdXRhdGlvbnMgPSBbXTtcbn1cbmZ1bmN0aW9uIG9uTXV0YXRlKG11dGF0aW9ucykge1xuICBpZiAoaXNDb2xsZWN0aW5nKSB7XG4gICAgZGVmZXJyZWRNdXRhdGlvbnMgPSBkZWZlcnJlZE11dGF0aW9ucy5jb25jYXQobXV0YXRpb25zKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGFkZGVkTm9kZXMgPSBbXTtcbiAgbGV0IHJlbW92ZWROb2RlcyA9IFtdO1xuICBsZXQgYWRkZWRBdHRyaWJ1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IHJlbW92ZWRBdHRyaWJ1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobXV0YXRpb25zW2ldLnRhcmdldC5feF9pZ25vcmVNdXRhdGlvbk9ic2VydmVyKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKG11dGF0aW9uc1tpXS50eXBlID09PSBcImNoaWxkTGlzdFwiKSB7XG4gICAgICBtdXRhdGlvbnNbaV0uYWRkZWROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSAxICYmIGFkZGVkTm9kZXMucHVzaChub2RlKSk7XG4gICAgICBtdXRhdGlvbnNbaV0ucmVtb3ZlZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDEgJiYgcmVtb3ZlZE5vZGVzLnB1c2gobm9kZSkpO1xuICAgIH1cbiAgICBpZiAobXV0YXRpb25zW2ldLnR5cGUgPT09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICBsZXQgZWwgPSBtdXRhdGlvbnNbaV0udGFyZ2V0O1xuICAgICAgbGV0IG5hbWUgPSBtdXRhdGlvbnNbaV0uYXR0cmlidXRlTmFtZTtcbiAgICAgIGxldCBvbGRWYWx1ZSA9IG11dGF0aW9uc1tpXS5vbGRWYWx1ZTtcbiAgICAgIGxldCBhZGQgPSAoKSA9PiB7XG4gICAgICAgIGlmICghYWRkZWRBdHRyaWJ1dGVzLmhhcyhlbCkpXG4gICAgICAgICAgYWRkZWRBdHRyaWJ1dGVzLnNldChlbCwgW10pO1xuICAgICAgICBhZGRlZEF0dHJpYnV0ZXMuZ2V0KGVsKS5wdXNoKHsgbmFtZSwgdmFsdWU6IGVsLmdldEF0dHJpYnV0ZShuYW1lKSB9KTtcbiAgICAgIH07XG4gICAgICBsZXQgcmVtb3ZlID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXJlbW92ZWRBdHRyaWJ1dGVzLmhhcyhlbCkpXG4gICAgICAgICAgcmVtb3ZlZEF0dHJpYnV0ZXMuc2V0KGVsLCBbXSk7XG4gICAgICAgIHJlbW92ZWRBdHRyaWJ1dGVzLmdldChlbCkucHVzaChuYW1lKTtcbiAgICAgIH07XG4gICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKG5hbWUpICYmIG9sZFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGFkZCgpO1xuICAgICAgfSBlbHNlIGlmIChlbC5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgIGFkZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlbW92ZWRBdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJzLCBlbCkgPT4ge1xuICAgIGNsZWFudXBBdHRyaWJ1dGVzKGVsLCBhdHRycyk7XG4gIH0pO1xuICBhZGRlZEF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cnMsIGVsKSA9PiB7XG4gICAgb25BdHRyaWJ1dGVBZGRlZHMuZm9yRWFjaCgoaSkgPT4gaShlbCwgYXR0cnMpKTtcbiAgfSk7XG4gIGZvciAobGV0IG5vZGUgb2YgcmVtb3ZlZE5vZGVzKSB7XG4gICAgaWYgKGFkZGVkTm9kZXMuaW5jbHVkZXMobm9kZSkpXG4gICAgICBjb250aW51ZTtcbiAgICBvbkVsUmVtb3ZlZHMuZm9yRWFjaCgoaSkgPT4gaShub2RlKSk7XG4gICAgaWYgKG5vZGUuX3hfY2xlYW51cHMpIHtcbiAgICAgIHdoaWxlIChub2RlLl94X2NsZWFudXBzLmxlbmd0aClcbiAgICAgICAgbm9kZS5feF9jbGVhbnVwcy5wb3AoKSgpO1xuICAgIH1cbiAgfVxuICBhZGRlZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICBub2RlLl94X2lnbm9yZVNlbGYgPSB0cnVlO1xuICAgIG5vZGUuX3hfaWdub3JlID0gdHJ1ZTtcbiAgfSk7XG4gIGZvciAobGV0IG5vZGUgb2YgYWRkZWROb2Rlcykge1xuICAgIGlmIChyZW1vdmVkTm9kZXMuaW5jbHVkZXMobm9kZSkpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoIW5vZGUuaXNDb25uZWN0ZWQpXG4gICAgICBjb250aW51ZTtcbiAgICBkZWxldGUgbm9kZS5feF9pZ25vcmVTZWxmO1xuICAgIGRlbGV0ZSBub2RlLl94X2lnbm9yZTtcbiAgICBvbkVsQWRkZWRzLmZvckVhY2goKGkpID0+IGkobm9kZSkpO1xuICAgIG5vZGUuX3hfaWdub3JlID0gdHJ1ZTtcbiAgICBub2RlLl94X2lnbm9yZVNlbGYgPSB0cnVlO1xuICB9XG4gIGFkZGVkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgIGRlbGV0ZSBub2RlLl94X2lnbm9yZVNlbGY7XG4gICAgZGVsZXRlIG5vZGUuX3hfaWdub3JlO1xuICB9KTtcbiAgYWRkZWROb2RlcyA9IG51bGw7XG4gIHJlbW92ZWROb2RlcyA9IG51bGw7XG4gIGFkZGVkQXR0cmlidXRlcyA9IG51bGw7XG4gIHJlbW92ZWRBdHRyaWJ1dGVzID0gbnVsbDtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3Njb3BlLmpzXG5mdW5jdGlvbiBzY29wZShub2RlKSB7XG4gIHJldHVybiBtZXJnZVByb3hpZXMoY2xvc2VzdERhdGFTdGFjayhub2RlKSk7XG59XG5mdW5jdGlvbiBhZGRTY29wZVRvTm9kZShub2RlLCBkYXRhMiwgcmVmZXJlbmNlTm9kZSkge1xuICBub2RlLl94X2RhdGFTdGFjayA9IFtkYXRhMiwgLi4uY2xvc2VzdERhdGFTdGFjayhyZWZlcmVuY2VOb2RlIHx8IG5vZGUpXTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBub2RlLl94X2RhdGFTdGFjayA9IG5vZGUuX3hfZGF0YVN0YWNrLmZpbHRlcigoaSkgPT4gaSAhPT0gZGF0YTIpO1xuICB9O1xufVxuZnVuY3Rpb24gY2xvc2VzdERhdGFTdGFjayhub2RlKSB7XG4gIGlmIChub2RlLl94X2RhdGFTdGFjaylcbiAgICByZXR1cm4gbm9kZS5feF9kYXRhU3RhY2s7XG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gXCJmdW5jdGlvblwiICYmIG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgcmV0dXJuIGNsb3Nlc3REYXRhU3RhY2sobm9kZS5ob3N0KTtcbiAgfVxuICBpZiAoIW5vZGUucGFyZW50Tm9kZSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gY2xvc2VzdERhdGFTdGFjayhub2RlLnBhcmVudE5vZGUpO1xufVxuZnVuY3Rpb24gbWVyZ2VQcm94aWVzKG9iamVjdHMpIHtcbiAgbGV0IHRoaXNQcm94eSA9IG5ldyBQcm94eSh7fSwge1xuICAgIG93bktleXM6ICgpID0+IHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQob2JqZWN0cy5mbGF0TWFwKChpKSA9PiBPYmplY3Qua2V5cyhpKSkpKTtcbiAgICB9LFxuICAgIGhhczogKHRhcmdldCwgbmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIG9iamVjdHMuc29tZSgob2JqKSA9PiBvYmouaGFzT3duUHJvcGVydHkobmFtZSkpO1xuICAgIH0sXG4gICAgZ2V0OiAodGFyZ2V0LCBuYW1lKSA9PiB7XG4gICAgICByZXR1cm4gKG9iamVjdHMuZmluZCgob2JqKSA9PiB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBsZXQgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBuYW1lKTtcbiAgICAgICAgICBpZiAoZGVzY3JpcHRvci5nZXQgJiYgZGVzY3JpcHRvci5nZXQuX3hfYWxyZWFkeUJvdW5kIHx8IGRlc2NyaXB0b3Iuc2V0ICYmIGRlc2NyaXB0b3Iuc2V0Ll94X2FscmVhZHlCb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgoZGVzY3JpcHRvci5nZXQgfHwgZGVzY3JpcHRvci5zZXQpICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgICAgICAgbGV0IGdldHRlciA9IGRlc2NyaXB0b3IuZ2V0O1xuICAgICAgICAgICAgbGV0IHNldHRlciA9IGRlc2NyaXB0b3Iuc2V0O1xuICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gZGVzY3JpcHRvcjtcbiAgICAgICAgICAgIGdldHRlciA9IGdldHRlciAmJiBnZXR0ZXIuYmluZCh0aGlzUHJveHkpO1xuICAgICAgICAgICAgc2V0dGVyID0gc2V0dGVyICYmIHNldHRlci5iaW5kKHRoaXNQcm94eSk7XG4gICAgICAgICAgICBpZiAoZ2V0dGVyKVxuICAgICAgICAgICAgICBnZXR0ZXIuX3hfYWxyZWFkeUJvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChzZXR0ZXIpXG4gICAgICAgICAgICAgIHNldHRlci5feF9hbHJlYWR5Qm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwge1xuICAgICAgICAgICAgICAuLi5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICAgICAgICAgIHNldDogc2V0dGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSkgfHwge30pW25hbWVdO1xuICAgIH0sXG4gICAgc2V0OiAodGFyZ2V0LCBuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgbGV0IGNsb3Nlc3RPYmplY3RXaXRoS2V5ID0gb2JqZWN0cy5maW5kKChvYmopID0+IG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKSk7XG4gICAgICBpZiAoY2xvc2VzdE9iamVjdFdpdGhLZXkpIHtcbiAgICAgICAgY2xvc2VzdE9iamVjdFdpdGhLZXlbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdHNbb2JqZWN0cy5sZW5ndGggLSAxXVtuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRoaXNQcm94eTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2ludGVyY2VwdG9yLmpzXG5mdW5jdGlvbiBpbml0SW50ZXJjZXB0b3JzKGRhdGEyKSB7XG4gIGxldCBpc09iamVjdCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsKSAmJiB2YWwgIT09IG51bGw7XG4gIGxldCByZWN1cnNlID0gKG9iaiwgYmFzZVBhdGggPSBcIlwiKSA9PiB7XG4gICAgT2JqZWN0LmVudHJpZXMoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKSkuZm9yRWFjaCgoW2tleSwgeyB2YWx1ZSwgZW51bWVyYWJsZSB9XSkgPT4ge1xuICAgICAgaWYgKGVudW1lcmFibGUgPT09IGZhbHNlIHx8IHZhbHVlID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBwYXRoID0gYmFzZVBhdGggPT09IFwiXCIgPyBrZXkgOiBgJHtiYXNlUGF0aH0uJHtrZXl9YDtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUuX3hfaW50ZXJjZXB0b3IpIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZS5pbml0aWFsaXplKGRhdGEyLCBwYXRoLCBrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZSAhPT0gb2JqICYmICEodmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICAgIHJlY3Vyc2UodmFsdWUsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiByZWN1cnNlKGRhdGEyKTtcbn1cbmZ1bmN0aW9uIGludGVyY2VwdG9yKGNhbGxiYWNrLCBtdXRhdGVPYmogPSAoKSA9PiB7XG59KSB7XG4gIGxldCBvYmogPSB7XG4gICAgaW5pdGlhbFZhbHVlOiB2b2lkIDAsXG4gICAgX3hfaW50ZXJjZXB0b3I6IHRydWUsXG4gICAgaW5pdGlhbGl6ZShkYXRhMiwgcGF0aCwga2V5KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5pbml0aWFsVmFsdWUsICgpID0+IGdldChkYXRhMiwgcGF0aCksICh2YWx1ZSkgPT4gc2V0KGRhdGEyLCBwYXRoLCB2YWx1ZSksIHBhdGgsIGtleSk7XG4gICAgfVxuICB9O1xuICBtdXRhdGVPYmoob2JqKTtcbiAgcmV0dXJuIChpbml0aWFsVmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIGluaXRpYWxWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBpbml0aWFsVmFsdWUgIT09IG51bGwgJiYgaW5pdGlhbFZhbHVlLl94X2ludGVyY2VwdG9yKSB7XG4gICAgICBsZXQgaW5pdGlhbGl6ZSA9IG9iai5pbml0aWFsaXplLmJpbmQob2JqKTtcbiAgICAgIG9iai5pbml0aWFsaXplID0gKGRhdGEyLCBwYXRoLCBrZXkpID0+IHtcbiAgICAgICAgbGV0IGlubmVyVmFsdWUgPSBpbml0aWFsVmFsdWUuaW5pdGlhbGl6ZShkYXRhMiwgcGF0aCwga2V5KTtcbiAgICAgICAgb2JqLmluaXRpYWxWYWx1ZSA9IGlubmVyVmFsdWU7XG4gICAgICAgIHJldHVybiBpbml0aWFsaXplKGRhdGEyLCBwYXRoLCBrZXkpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqLmluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldChvYmosIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguc3BsaXQoXCIuXCIpLnJlZHVjZSgoY2FycnksIHNlZ21lbnQpID0+IGNhcnJ5W3NlZ21lbnRdLCBvYmopO1xufVxuZnVuY3Rpb24gc2V0KG9iaiwgcGF0aCwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiKVxuICAgIHBhdGggPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAxKVxuICAgIG9ialtwYXRoWzBdXSA9IHZhbHVlO1xuICBlbHNlIGlmIChwYXRoLmxlbmd0aCA9PT0gMClcbiAgICB0aHJvdyBlcnJvcjtcbiAgZWxzZSB7XG4gICAgaWYgKG9ialtwYXRoWzBdXSlcbiAgICAgIHJldHVybiBzZXQob2JqW3BhdGhbMF1dLCBwYXRoLnNsaWNlKDEpLCB2YWx1ZSk7XG4gICAgZWxzZSB7XG4gICAgICBvYmpbcGF0aFswXV0gPSB7fTtcbiAgICAgIHJldHVybiBzZXQob2JqW3BhdGhbMF1dLCBwYXRoLnNsaWNlKDEpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MuanNcbnZhciBtYWdpY3MgPSB7fTtcbmZ1bmN0aW9uIG1hZ2ljKG5hbWUsIGNhbGxiYWNrKSB7XG4gIG1hZ2ljc1tuYW1lXSA9IGNhbGxiYWNrO1xufVxuZnVuY3Rpb24gaW5qZWN0TWFnaWNzKG9iaiwgZWwpIHtcbiAgT2JqZWN0LmVudHJpZXMobWFnaWNzKS5mb3JFYWNoKChbbmFtZSwgY2FsbGJhY2tdKSA9PiB7XG4gICAgbGV0IG1lbW9pemVkVXRpbGl0aWVzID0gbnVsbDtcbiAgICBmdW5jdGlvbiBnZXRVdGlsaXRpZXMoKSB7XG4gICAgICBpZiAobWVtb2l6ZWRVdGlsaXRpZXMpIHtcbiAgICAgICAgcmV0dXJuIG1lbW9pemVkVXRpbGl0aWVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IFt1dGlsaXRpZXMsIGNsZWFudXBdID0gZ2V0RWxlbWVudEJvdW5kVXRpbGl0aWVzKGVsKTtcbiAgICAgICAgbWVtb2l6ZWRVdGlsaXRpZXMgPSB7IGludGVyY2VwdG9yLCAuLi51dGlsaXRpZXMgfTtcbiAgICAgICAgb25FbFJlbW92ZWQoZWwsIGNsZWFudXApO1xuICAgICAgICByZXR1cm4gbWVtb2l6ZWRVdGlsaXRpZXM7XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGAkJHtuYW1lfWAsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVsLCBnZXRVdGlsaXRpZXMoKSk7XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvYmo7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9lcnJvci5qc1xuZnVuY3Rpb24gdHJ5Q2F0Y2goZWwsIGV4cHJlc3Npb24sIGNhbGxiYWNrLCAuLi5hcmdzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgZWwsIGV4cHJlc3Npb24pO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvcjIsIGVsLCBleHByZXNzaW9uID0gdm9pZCAwKSB7XG4gIE9iamVjdC5hc3NpZ24oZXJyb3IyLCB7IGVsLCBleHByZXNzaW9uIH0pO1xuICBjb25zb2xlLndhcm4oYEFscGluZSBFeHByZXNzaW9uIEVycm9yOiAke2Vycm9yMi5tZXNzYWdlfVxuXG4ke2V4cHJlc3Npb24gPyAnRXhwcmVzc2lvbjogXCInICsgZXhwcmVzc2lvbiArICdcIlxcblxcbicgOiBcIlwifWAsIGVsKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdGhyb3cgZXJyb3IyO1xuICB9LCAwKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2V2YWx1YXRvci5qc1xudmFyIHNob3VsZEF1dG9FdmFsdWF0ZUZ1bmN0aW9ucyA9IHRydWU7XG5mdW5jdGlvbiBkb250QXV0b0V2YWx1YXRlRnVuY3Rpb25zKGNhbGxiYWNrKSB7XG4gIGxldCBjYWNoZSA9IHNob3VsZEF1dG9FdmFsdWF0ZUZ1bmN0aW9ucztcbiAgc2hvdWxkQXV0b0V2YWx1YXRlRnVuY3Rpb25zID0gZmFsc2U7XG4gIGNhbGxiYWNrKCk7XG4gIHNob3VsZEF1dG9FdmFsdWF0ZUZ1bmN0aW9ucyA9IGNhY2hlO1xufVxuZnVuY3Rpb24gZXZhbHVhdGUoZWwsIGV4cHJlc3Npb24sIGV4dHJhcyA9IHt9KSB7XG4gIGxldCByZXN1bHQ7XG4gIGV2YWx1YXRlTGF0ZXIoZWwsIGV4cHJlc3Npb24pKCh2YWx1ZSkgPT4gcmVzdWx0ID0gdmFsdWUsIGV4dHJhcyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBldmFsdWF0ZUxhdGVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIHRoZUV2YWx1YXRvckZ1bmN0aW9uKC4uLmFyZ3MpO1xufVxudmFyIHRoZUV2YWx1YXRvckZ1bmN0aW9uID0gbm9ybWFsRXZhbHVhdG9yO1xuZnVuY3Rpb24gc2V0RXZhbHVhdG9yKG5ld0V2YWx1YXRvcikge1xuICB0aGVFdmFsdWF0b3JGdW5jdGlvbiA9IG5ld0V2YWx1YXRvcjtcbn1cbmZ1bmN0aW9uIG5vcm1hbEV2YWx1YXRvcihlbCwgZXhwcmVzc2lvbikge1xuICBsZXQgb3ZlcnJpZGRlbk1hZ2ljcyA9IHt9O1xuICBpbmplY3RNYWdpY3Mob3ZlcnJpZGRlbk1hZ2ljcywgZWwpO1xuICBsZXQgZGF0YVN0YWNrID0gW292ZXJyaWRkZW5NYWdpY3MsIC4uLmNsb3Nlc3REYXRhU3RhY2soZWwpXTtcbiAgbGV0IGV2YWx1YXRvciA9IHR5cGVvZiBleHByZXNzaW9uID09PSBcImZ1bmN0aW9uXCIgPyBnZW5lcmF0ZUV2YWx1YXRvckZyb21GdW5jdGlvbihkYXRhU3RhY2ssIGV4cHJlc3Npb24pIDogZ2VuZXJhdGVFdmFsdWF0b3JGcm9tU3RyaW5nKGRhdGFTdGFjaywgZXhwcmVzc2lvbiwgZWwpO1xuICByZXR1cm4gdHJ5Q2F0Y2guYmluZChudWxsLCBlbCwgZXhwcmVzc2lvbiwgZXZhbHVhdG9yKTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlRXZhbHVhdG9yRnJvbUZ1bmN0aW9uKGRhdGFTdGFjaywgZnVuYykge1xuICByZXR1cm4gKHJlY2VpdmVyID0gKCkgPT4ge1xuICB9LCB7IHNjb3BlOiBzY29wZTIgPSB7fSwgcGFyYW1zID0gW10gfSA9IHt9KSA9PiB7XG4gICAgbGV0IHJlc3VsdCA9IGZ1bmMuYXBwbHkobWVyZ2VQcm94aWVzKFtzY29wZTIsIC4uLmRhdGFTdGFja10pLCBwYXJhbXMpO1xuICAgIHJ1bklmVHlwZU9mRnVuY3Rpb24ocmVjZWl2ZXIsIHJlc3VsdCk7XG4gIH07XG59XG52YXIgZXZhbHVhdG9yTWVtbyA9IHt9O1xuZnVuY3Rpb24gZ2VuZXJhdGVGdW5jdGlvbkZyb21TdHJpbmcoZXhwcmVzc2lvbiwgZWwpIHtcbiAgaWYgKGV2YWx1YXRvck1lbW9bZXhwcmVzc2lvbl0pIHtcbiAgICByZXR1cm4gZXZhbHVhdG9yTWVtb1tleHByZXNzaW9uXTtcbiAgfVxuICBsZXQgQXN5bmNGdW5jdGlvbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhc3luYyBmdW5jdGlvbigpIHtcbiAgfSkuY29uc3RydWN0b3I7XG4gIGxldCByaWdodFNpZGVTYWZlRXhwcmVzc2lvbiA9IC9eW1xcblxcc10qaWYuKlxcKC4qXFwpLy50ZXN0KGV4cHJlc3Npb24pIHx8IC9eKGxldHxjb25zdClcXHMvLnRlc3QoZXhwcmVzc2lvbikgPyBgKGFzeW5jKCk9PnsgJHtleHByZXNzaW9ufSB9KSgpYCA6IGV4cHJlc3Npb247XG4gIGNvbnN0IHNhZmVBc3luY0Z1bmN0aW9uID0gKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEFzeW5jRnVuY3Rpb24oW1wiX19zZWxmXCIsIFwic2NvcGVcIl0sIGB3aXRoIChzY29wZSkgeyBfX3NlbGYucmVzdWx0ID0gJHtyaWdodFNpZGVTYWZlRXhwcmVzc2lvbn0gfTsgX19zZWxmLmZpbmlzaGVkID0gdHJ1ZTsgcmV0dXJuIF9fc2VsZi5yZXN1bHQ7YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlcnJvcjIsIGVsLCBleHByZXNzaW9uKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH07XG4gIGxldCBmdW5jID0gc2FmZUFzeW5jRnVuY3Rpb24oKTtcbiAgZXZhbHVhdG9yTWVtb1tleHByZXNzaW9uXSA9IGZ1bmM7XG4gIHJldHVybiBmdW5jO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVFdmFsdWF0b3JGcm9tU3RyaW5nKGRhdGFTdGFjaywgZXhwcmVzc2lvbiwgZWwpIHtcbiAgbGV0IGZ1bmMgPSBnZW5lcmF0ZUZ1bmN0aW9uRnJvbVN0cmluZyhleHByZXNzaW9uLCBlbCk7XG4gIHJldHVybiAocmVjZWl2ZXIgPSAoKSA9PiB7XG4gIH0sIHsgc2NvcGU6IHNjb3BlMiA9IHt9LCBwYXJhbXMgPSBbXSB9ID0ge30pID0+IHtcbiAgICBmdW5jLnJlc3VsdCA9IHZvaWQgMDtcbiAgICBmdW5jLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgbGV0IGNvbXBsZXRlU2NvcGUgPSBtZXJnZVByb3hpZXMoW3Njb3BlMiwgLi4uZGF0YVN0YWNrXSk7XG4gICAgaWYgKHR5cGVvZiBmdW5jID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGxldCBwcm9taXNlID0gZnVuYyhmdW5jLCBjb21wbGV0ZVNjb3BlKS5jYXRjaCgoZXJyb3IyKSA9PiBoYW5kbGVFcnJvcihlcnJvcjIsIGVsLCBleHByZXNzaW9uKSk7XG4gICAgICBpZiAoZnVuYy5maW5pc2hlZCkge1xuICAgICAgICBydW5JZlR5cGVPZkZ1bmN0aW9uKHJlY2VpdmVyLCBmdW5jLnJlc3VsdCwgY29tcGxldGVTY29wZSwgcGFyYW1zLCBlbCk7XG4gICAgICAgIGZ1bmMucmVzdWx0ID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICBydW5JZlR5cGVPZkZ1bmN0aW9uKHJlY2VpdmVyLCByZXN1bHQsIGNvbXBsZXRlU2NvcGUsIHBhcmFtcywgZWwpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyb3IyKSA9PiBoYW5kbGVFcnJvcihlcnJvcjIsIGVsLCBleHByZXNzaW9uKSkuZmluYWxseSgoKSA9PiBmdW5jLnJlc3VsdCA9IHZvaWQgMCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gcnVuSWZUeXBlT2ZGdW5jdGlvbihyZWNlaXZlciwgdmFsdWUsIHNjb3BlMiwgcGFyYW1zLCBlbCkge1xuICBpZiAoc2hvdWxkQXV0b0V2YWx1YXRlRnVuY3Rpb25zICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLmFwcGx5KHNjb3BlMiwgcGFyYW1zKTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmVzdWx0LnRoZW4oKGkpID0+IHJ1bklmVHlwZU9mRnVuY3Rpb24ocmVjZWl2ZXIsIGksIHNjb3BlMiwgcGFyYW1zKSkuY2F0Y2goKGVycm9yMikgPT4gaGFuZGxlRXJyb3IoZXJyb3IyLCBlbCwgdmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjZWl2ZXIocmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgIHZhbHVlLnRoZW4oKGkpID0+IHJlY2VpdmVyKGkpKTtcbiAgfSBlbHNlIHtcbiAgICByZWNlaXZlcih2YWx1ZSk7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMuanNcbnZhciBwcmVmaXhBc1N0cmluZyA9IFwieC1cIjtcbmZ1bmN0aW9uIHByZWZpeChzdWJqZWN0ID0gXCJcIikge1xuICByZXR1cm4gcHJlZml4QXNTdHJpbmcgKyBzdWJqZWN0O1xufVxuZnVuY3Rpb24gc2V0UHJlZml4KG5ld1ByZWZpeCkge1xuICBwcmVmaXhBc1N0cmluZyA9IG5ld1ByZWZpeDtcbn1cbnZhciBkaXJlY3RpdmVIYW5kbGVycyA9IHt9O1xuZnVuY3Rpb24gZGlyZWN0aXZlKG5hbWUsIGNhbGxiYWNrKSB7XG4gIGRpcmVjdGl2ZUhhbmRsZXJzW25hbWVdID0gY2FsbGJhY2s7XG4gIHJldHVybiB7XG4gICAgYmVmb3JlKGRpcmVjdGl2ZTIpIHtcbiAgICAgIGlmICghZGlyZWN0aXZlSGFuZGxlcnNbZGlyZWN0aXZlMl0pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiQ2Fubm90IGZpbmQgZGlyZWN0aXZlIGAke2RpcmVjdGl2ZX1gLiBgJHtuYW1lfWAgd2lsbCB1c2UgdGhlIGRlZmF1bHQgb3JkZXIgb2YgZXhlY3V0aW9uXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9zID0gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZihkaXJlY3RpdmUyKTtcbiAgICAgIGRpcmVjdGl2ZU9yZGVyLnNwbGljZShwb3MgPj0gMCA/IHBvcyA6IGRpcmVjdGl2ZU9yZGVyLmluZGV4T2YoXCJERUZBVUxUXCIpLCAwLCBuYW1lKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkaXJlY3RpdmVzKGVsLCBhdHRyaWJ1dGVzLCBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlKSB7XG4gIGF0dHJpYnV0ZXMgPSBBcnJheS5mcm9tKGF0dHJpYnV0ZXMpO1xuICBpZiAoZWwuX3hfdmlydHVhbERpcmVjdGl2ZXMpIHtcbiAgICBsZXQgdkF0dHJpYnV0ZXMgPSBPYmplY3QuZW50cmllcyhlbC5feF92aXJ0dWFsRGlyZWN0aXZlcykubWFwKChbbmFtZSwgdmFsdWVdKSA9PiAoeyBuYW1lLCB2YWx1ZSB9KSk7XG4gICAgbGV0IHN0YXRpY0F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzT25seSh2QXR0cmlidXRlcyk7XG4gICAgdkF0dHJpYnV0ZXMgPSB2QXR0cmlidXRlcy5tYXAoKGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgaWYgKHN0YXRpY0F0dHJpYnV0ZXMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSBhdHRyaWJ1dGUubmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBgeC1iaW5kOiR7YXR0cmlidXRlLm5hbWV9YCxcbiAgICAgICAgICB2YWx1ZTogYFwiJHthdHRyaWJ1dGUudmFsdWV9XCJgXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgIH0pO1xuICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmNvbmNhdCh2QXR0cmlidXRlcyk7XG4gIH1cbiAgbGV0IHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwID0ge307XG4gIGxldCBkaXJlY3RpdmVzMiA9IGF0dHJpYnV0ZXMubWFwKHRvVHJhbnNmb3JtZWRBdHRyaWJ1dGVzKChuZXdOYW1lLCBvbGROYW1lKSA9PiB0cmFuc2Zvcm1lZEF0dHJpYnV0ZU1hcFtuZXdOYW1lXSA9IG9sZE5hbWUpKS5maWx0ZXIob3V0Tm9uQWxwaW5lQXR0cmlidXRlcykubWFwKHRvUGFyc2VkRGlyZWN0aXZlcyh0cmFuc2Zvcm1lZEF0dHJpYnV0ZU1hcCwgb3JpZ2luYWxBdHRyaWJ1dGVPdmVycmlkZSkpLnNvcnQoYnlQcmlvcml0eSk7XG4gIHJldHVybiBkaXJlY3RpdmVzMi5tYXAoKGRpcmVjdGl2ZTIpID0+IHtcbiAgICByZXR1cm4gZ2V0RGlyZWN0aXZlSGFuZGxlcihlbCwgZGlyZWN0aXZlMik7XG4gIH0pO1xufVxuZnVuY3Rpb24gYXR0cmlidXRlc09ubHkoYXR0cmlidXRlcykge1xuICByZXR1cm4gQXJyYXkuZnJvbShhdHRyaWJ1dGVzKS5tYXAodG9UcmFuc2Zvcm1lZEF0dHJpYnV0ZXMoKSkuZmlsdGVyKChhdHRyKSA9PiAhb3V0Tm9uQWxwaW5lQXR0cmlidXRlcyhhdHRyKSk7XG59XG52YXIgaXNEZWZlcnJpbmdIYW5kbGVycyA9IGZhbHNlO1xudmFyIGRpcmVjdGl2ZUhhbmRsZXJTdGFja3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xudmFyIGN1cnJlbnRIYW5kbGVyU3RhY2tLZXkgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIGRlZmVySGFuZGxpbmdEaXJlY3RpdmVzKGNhbGxiYWNrKSB7XG4gIGlzRGVmZXJyaW5nSGFuZGxlcnMgPSB0cnVlO1xuICBsZXQga2V5ID0gU3ltYm9sKCk7XG4gIGN1cnJlbnRIYW5kbGVyU3RhY2tLZXkgPSBrZXk7XG4gIGRpcmVjdGl2ZUhhbmRsZXJTdGFja3Muc2V0KGtleSwgW10pO1xuICBsZXQgZmx1c2hIYW5kbGVycyA9ICgpID0+IHtcbiAgICB3aGlsZSAoZGlyZWN0aXZlSGFuZGxlclN0YWNrcy5nZXQoa2V5KS5sZW5ndGgpXG4gICAgICBkaXJlY3RpdmVIYW5kbGVyU3RhY2tzLmdldChrZXkpLnNoaWZ0KCkoKTtcbiAgICBkaXJlY3RpdmVIYW5kbGVyU3RhY2tzLmRlbGV0ZShrZXkpO1xuICB9O1xuICBsZXQgc3RvcERlZmVycmluZyA9ICgpID0+IHtcbiAgICBpc0RlZmVycmluZ0hhbmRsZXJzID0gZmFsc2U7XG4gICAgZmx1c2hIYW5kbGVycygpO1xuICB9O1xuICBjYWxsYmFjayhmbHVzaEhhbmRsZXJzKTtcbiAgc3RvcERlZmVycmluZygpO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudEJvdW5kVXRpbGl0aWVzKGVsKSB7XG4gIGxldCBjbGVhbnVwcyA9IFtdO1xuICBsZXQgY2xlYW51cCA9IChjYWxsYmFjaykgPT4gY2xlYW51cHMucHVzaChjYWxsYmFjayk7XG4gIGxldCBbZWZmZWN0MywgY2xlYW51cEVmZmVjdF0gPSBlbGVtZW50Qm91bmRFZmZlY3QoZWwpO1xuICBjbGVhbnVwcy5wdXNoKGNsZWFudXBFZmZlY3QpO1xuICBsZXQgdXRpbGl0aWVzID0ge1xuICAgIEFscGluZTogYWxwaW5lX2RlZmF1bHQsXG4gICAgZWZmZWN0OiBlZmZlY3QzLFxuICAgIGNsZWFudXAsXG4gICAgZXZhbHVhdGVMYXRlcjogZXZhbHVhdGVMYXRlci5iaW5kKGV2YWx1YXRlTGF0ZXIsIGVsKSxcbiAgICBldmFsdWF0ZTogZXZhbHVhdGUuYmluZChldmFsdWF0ZSwgZWwpXG4gIH07XG4gIGxldCBkb0NsZWFudXAgPSAoKSA9PiBjbGVhbnVwcy5mb3JFYWNoKChpKSA9PiBpKCkpO1xuICByZXR1cm4gW3V0aWxpdGllcywgZG9DbGVhbnVwXTtcbn1cbmZ1bmN0aW9uIGdldERpcmVjdGl2ZUhhbmRsZXIoZWwsIGRpcmVjdGl2ZTIpIHtcbiAgbGV0IG5vb3AgPSAoKSA9PiB7XG4gIH07XG4gIGxldCBoYW5kbGVyMyA9IGRpcmVjdGl2ZUhhbmRsZXJzW2RpcmVjdGl2ZTIudHlwZV0gfHwgbm9vcDtcbiAgbGV0IFt1dGlsaXRpZXMsIGNsZWFudXBdID0gZ2V0RWxlbWVudEJvdW5kVXRpbGl0aWVzKGVsKTtcbiAgb25BdHRyaWJ1dGVSZW1vdmVkKGVsLCBkaXJlY3RpdmUyLm9yaWdpbmFsLCBjbGVhbnVwKTtcbiAgbGV0IGZ1bGxIYW5kbGVyID0gKCkgPT4ge1xuICAgIGlmIChlbC5feF9pZ25vcmUgfHwgZWwuX3hfaWdub3JlU2VsZilcbiAgICAgIHJldHVybjtcbiAgICBoYW5kbGVyMy5pbmxpbmUgJiYgaGFuZGxlcjMuaW5saW5lKGVsLCBkaXJlY3RpdmUyLCB1dGlsaXRpZXMpO1xuICAgIGhhbmRsZXIzID0gaGFuZGxlcjMuYmluZChoYW5kbGVyMywgZWwsIGRpcmVjdGl2ZTIsIHV0aWxpdGllcyk7XG4gICAgaXNEZWZlcnJpbmdIYW5kbGVycyA/IGRpcmVjdGl2ZUhhbmRsZXJTdGFja3MuZ2V0KGN1cnJlbnRIYW5kbGVyU3RhY2tLZXkpLnB1c2goaGFuZGxlcjMpIDogaGFuZGxlcjMoKTtcbiAgfTtcbiAgZnVsbEhhbmRsZXIucnVuQ2xlYW51cHMgPSBjbGVhbnVwO1xuICByZXR1cm4gZnVsbEhhbmRsZXI7XG59XG52YXIgc3RhcnRpbmdXaXRoID0gKHN1YmplY3QsIHJlcGxhY2VtZW50KSA9PiAoeyBuYW1lLCB2YWx1ZSB9KSA9PiB7XG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoc3ViamVjdCkpXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZShzdWJqZWN0LCByZXBsYWNlbWVudCk7XG4gIHJldHVybiB7IG5hbWUsIHZhbHVlIH07XG59O1xudmFyIGludG8gPSAoaSkgPT4gaTtcbmZ1bmN0aW9uIHRvVHJhbnNmb3JtZWRBdHRyaWJ1dGVzKGNhbGxiYWNrID0gKCkgPT4ge1xufSkge1xuICByZXR1cm4gKHsgbmFtZSwgdmFsdWUgfSkgPT4ge1xuICAgIGxldCB7IG5hbWU6IG5ld05hbWUsIHZhbHVlOiBuZXdWYWx1ZSB9ID0gYXR0cmlidXRlVHJhbnNmb3JtZXJzLnJlZHVjZSgoY2FycnksIHRyYW5zZm9ybSkgPT4ge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybShjYXJyeSk7XG4gICAgfSwgeyBuYW1lLCB2YWx1ZSB9KTtcbiAgICBpZiAobmV3TmFtZSAhPT0gbmFtZSlcbiAgICAgIGNhbGxiYWNrKG5ld05hbWUsIG5hbWUpO1xuICAgIHJldHVybiB7IG5hbWU6IG5ld05hbWUsIHZhbHVlOiBuZXdWYWx1ZSB9O1xuICB9O1xufVxudmFyIGF0dHJpYnV0ZVRyYW5zZm9ybWVycyA9IFtdO1xuZnVuY3Rpb24gbWFwQXR0cmlidXRlcyhjYWxsYmFjaykge1xuICBhdHRyaWJ1dGVUcmFuc2Zvcm1lcnMucHVzaChjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBvdXROb25BbHBpbmVBdHRyaWJ1dGVzKHsgbmFtZSB9KSB7XG4gIHJldHVybiBhbHBpbmVBdHRyaWJ1dGVSZWdleCgpLnRlc3QobmFtZSk7XG59XG52YXIgYWxwaW5lQXR0cmlidXRlUmVnZXggPSAoKSA9PiBuZXcgUmVnRXhwKGBeJHtwcmVmaXhBc1N0cmluZ30oW146Xi5dKylcXFxcYmApO1xuZnVuY3Rpb24gdG9QYXJzZWREaXJlY3RpdmVzKHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwLCBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlKSB7XG4gIHJldHVybiAoeyBuYW1lLCB2YWx1ZSB9KSA9PiB7XG4gICAgbGV0IHR5cGVNYXRjaCA9IG5hbWUubWF0Y2goYWxwaW5lQXR0cmlidXRlUmVnZXgoKSk7XG4gICAgbGV0IHZhbHVlTWF0Y2ggPSBuYW1lLm1hdGNoKC86KFthLXpBLVowLTlcXC06XSspLyk7XG4gICAgbGV0IG1vZGlmaWVycyA9IG5hbWUubWF0Y2goL1xcLlteLlxcXV0rKD89W15cXF1dKiQpL2cpIHx8IFtdO1xuICAgIGxldCBvcmlnaW5hbCA9IG9yaWdpbmFsQXR0cmlidXRlT3ZlcnJpZGUgfHwgdHJhbnNmb3JtZWRBdHRyaWJ1dGVNYXBbbmFtZV0gfHwgbmFtZTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdHlwZU1hdGNoID8gdHlwZU1hdGNoWzFdIDogbnVsbCxcbiAgICAgIHZhbHVlOiB2YWx1ZU1hdGNoID8gdmFsdWVNYXRjaFsxXSA6IG51bGwsXG4gICAgICBtb2RpZmllcnM6IG1vZGlmaWVycy5tYXAoKGkpID0+IGkucmVwbGFjZShcIi5cIiwgXCJcIikpLFxuICAgICAgZXhwcmVzc2lvbjogdmFsdWUsXG4gICAgICBvcmlnaW5hbFxuICAgIH07XG4gIH07XG59XG52YXIgREVGQVVMVCA9IFwiREVGQVVMVFwiO1xudmFyIGRpcmVjdGl2ZU9yZGVyID0gW1xuICBcImlnbm9yZVwiLFxuICBcInJlZlwiLFxuICBcImRhdGFcIixcbiAgXCJpZFwiLFxuICBcImJpbmRcIixcbiAgXCJpbml0XCIsXG4gIFwiZm9yXCIsXG4gIFwibW9kZWxcIixcbiAgXCJtb2RlbGFibGVcIixcbiAgXCJ0cmFuc2l0aW9uXCIsXG4gIFwic2hvd1wiLFxuICBcImlmXCIsXG4gIERFRkFVTFQsXG4gIFwidGVsZXBvcnRcIlxuXTtcbmZ1bmN0aW9uIGJ5UHJpb3JpdHkoYSwgYikge1xuICBsZXQgdHlwZUEgPSBkaXJlY3RpdmVPcmRlci5pbmRleE9mKGEudHlwZSkgPT09IC0xID8gREVGQVVMVCA6IGEudHlwZTtcbiAgbGV0IHR5cGVCID0gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZihiLnR5cGUpID09PSAtMSA/IERFRkFVTFQgOiBiLnR5cGU7XG4gIHJldHVybiBkaXJlY3RpdmVPcmRlci5pbmRleE9mKHR5cGVBKSAtIGRpcmVjdGl2ZU9yZGVyLmluZGV4T2YodHlwZUIpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvZGlzcGF0Y2guanNcbmZ1bmN0aW9uIGRpc3BhdGNoKGVsLCBuYW1lLCBkZXRhaWwgPSB7fSkge1xuICBlbC5kaXNwYXRjaEV2ZW50KFxuICAgIG5ldyBDdXN0b21FdmVudChuYW1lLCB7XG4gICAgICBkZXRhaWwsXG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgLy8gQWxsb3dzIGV2ZW50cyB0byBwYXNzIHRoZSBzaGFkb3cgRE9NIGJhcnJpZXIuXG4gICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KVxuICApO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvd2Fsay5qc1xuZnVuY3Rpb24gd2FsayhlbCwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSBcImZ1bmN0aW9uXCIgJiYgZWwgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgQXJyYXkuZnJvbShlbC5jaGlsZHJlbikuZm9yRWFjaCgoZWwyKSA9PiB3YWxrKGVsMiwgY2FsbGJhY2spKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHNraXAgPSBmYWxzZTtcbiAgY2FsbGJhY2soZWwsICgpID0+IHNraXAgPSB0cnVlKTtcbiAgaWYgKHNraXApXG4gICAgcmV0dXJuO1xuICBsZXQgbm9kZSA9IGVsLmZpcnN0RWxlbWVudENoaWxkO1xuICB3aGlsZSAobm9kZSkge1xuICAgIHdhbGsobm9kZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICBub2RlID0gbm9kZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL3dhcm4uanNcbmZ1bmN0aW9uIHdhcm4obWVzc2FnZSwgLi4uYXJncykge1xuICBjb25zb2xlLndhcm4oYEFscGluZSBXYXJuaW5nOiAke21lc3NhZ2V9YCwgLi4uYXJncyk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9saWZlY3ljbGUuanNcbnZhciBzdGFydGVkID0gZmFsc2U7XG5mdW5jdGlvbiBzdGFydCgpIHtcbiAgaWYgKHN0YXJ0ZWQpXG4gICAgd2FybihcIkFscGluZSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkIG9uIHRoaXMgcGFnZS4gQ2FsbGluZyBBbHBpbmUuc3RhcnQoKSBtb3JlIHRoYW4gb25jZSBjYW4gY2F1c2UgcHJvYmxlbXMuXCIpO1xuICBzdGFydGVkID0gdHJ1ZTtcbiAgaWYgKCFkb2N1bWVudC5ib2R5KVxuICAgIHdhcm4oXCJVbmFibGUgdG8gaW5pdGlhbGl6ZS4gVHJ5aW5nIHRvIGxvYWQgQWxwaW5lIGJlZm9yZSBgPGJvZHk+YCBpcyBhdmFpbGFibGUuIERpZCB5b3UgZm9yZ2V0IHRvIGFkZCBgZGVmZXJgIGluIEFscGluZSdzIGA8c2NyaXB0PmAgdGFnP1wiKTtcbiAgZGlzcGF0Y2goZG9jdW1lbnQsIFwiYWxwaW5lOmluaXRcIik7XG4gIGRpc3BhdGNoKGRvY3VtZW50LCBcImFscGluZTppbml0aWFsaXppbmdcIik7XG4gIHN0YXJ0T2JzZXJ2aW5nTXV0YXRpb25zKCk7XG4gIG9uRWxBZGRlZCgoZWwpID0+IGluaXRUcmVlKGVsLCB3YWxrKSk7XG4gIG9uRWxSZW1vdmVkKChlbCkgPT4gZGVzdHJveVRyZWUoZWwpKTtcbiAgb25BdHRyaWJ1dGVzQWRkZWQoKGVsLCBhdHRycykgPT4ge1xuICAgIGRpcmVjdGl2ZXMoZWwsIGF0dHJzKS5mb3JFYWNoKChoYW5kbGUpID0+IGhhbmRsZSgpKTtcbiAgfSk7XG4gIGxldCBvdXROZXN0ZWRDb21wb25lbnRzID0gKGVsKSA9PiAhY2xvc2VzdFJvb3QoZWwucGFyZW50RWxlbWVudCwgdHJ1ZSk7XG4gIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChhbGxTZWxlY3RvcnMoKSkpLmZpbHRlcihvdXROZXN0ZWRDb21wb25lbnRzKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgIGluaXRUcmVlKGVsKTtcbiAgfSk7XG4gIGRpc3BhdGNoKGRvY3VtZW50LCBcImFscGluZTppbml0aWFsaXplZFwiKTtcbn1cbnZhciByb290U2VsZWN0b3JDYWxsYmFja3MgPSBbXTtcbnZhciBpbml0U2VsZWN0b3JDYWxsYmFja3MgPSBbXTtcbmZ1bmN0aW9uIHJvb3RTZWxlY3RvcnMoKSB7XG4gIHJldHVybiByb290U2VsZWN0b3JDYWxsYmFja3MubWFwKChmbikgPT4gZm4oKSk7XG59XG5mdW5jdGlvbiBhbGxTZWxlY3RvcnMoKSB7XG4gIHJldHVybiByb290U2VsZWN0b3JDYWxsYmFja3MuY29uY2F0KGluaXRTZWxlY3RvckNhbGxiYWNrcykubWFwKChmbikgPT4gZm4oKSk7XG59XG5mdW5jdGlvbiBhZGRSb290U2VsZWN0b3Ioc2VsZWN0b3JDYWxsYmFjaykge1xuICByb290U2VsZWN0b3JDYWxsYmFja3MucHVzaChzZWxlY3RvckNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGFkZEluaXRTZWxlY3RvcihzZWxlY3RvckNhbGxiYWNrKSB7XG4gIGluaXRTZWxlY3RvckNhbGxiYWNrcy5wdXNoKHNlbGVjdG9yQ2FsbGJhY2spO1xufVxuZnVuY3Rpb24gY2xvc2VzdFJvb3QoZWwsIGluY2x1ZGVJbml0U2VsZWN0b3JzID0gZmFsc2UpIHtcbiAgcmV0dXJuIGZpbmRDbG9zZXN0KGVsLCAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9ycyA9IGluY2x1ZGVJbml0U2VsZWN0b3JzID8gYWxsU2VsZWN0b3JzKCkgOiByb290U2VsZWN0b3JzKCk7XG4gICAgaWYgKHNlbGVjdG9ycy5zb21lKChzZWxlY3RvcikgPT4gZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSkpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBmaW5kQ2xvc2VzdChlbCwgY2FsbGJhY2spIHtcbiAgaWYgKCFlbClcbiAgICByZXR1cm47XG4gIGlmIChjYWxsYmFjayhlbCkpXG4gICAgcmV0dXJuIGVsO1xuICBpZiAoZWwuX3hfdGVsZXBvcnRCYWNrKVxuICAgIGVsID0gZWwuX3hfdGVsZXBvcnRCYWNrO1xuICBpZiAoIWVsLnBhcmVudEVsZW1lbnQpXG4gICAgcmV0dXJuO1xuICByZXR1cm4gZmluZENsb3Nlc3QoZWwucGFyZW50RWxlbWVudCwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gaXNSb290KGVsKSB7XG4gIHJldHVybiByb290U2VsZWN0b3JzKCkuc29tZSgoc2VsZWN0b3IpID0+IGVsLm1hdGNoZXMoc2VsZWN0b3IpKTtcbn1cbnZhciBpbml0SW50ZXJjZXB0b3JzMiA9IFtdO1xuZnVuY3Rpb24gaW50ZXJjZXB0SW5pdChjYWxsYmFjaykge1xuICBpbml0SW50ZXJjZXB0b3JzMi5wdXNoKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGluaXRUcmVlKGVsLCB3YWxrZXIgPSB3YWxrLCBpbnRlcmNlcHQgPSAoKSA9PiB7XG59KSB7XG4gIGRlZmVySGFuZGxpbmdEaXJlY3RpdmVzKCgpID0+IHtcbiAgICB3YWxrZXIoZWwsIChlbDIsIHNraXApID0+IHtcbiAgICAgIGludGVyY2VwdChlbDIsIHNraXApO1xuICAgICAgaW5pdEludGVyY2VwdG9yczIuZm9yRWFjaCgoaSkgPT4gaShlbDIsIHNraXApKTtcbiAgICAgIGRpcmVjdGl2ZXMoZWwyLCBlbDIuYXR0cmlidXRlcykuZm9yRWFjaCgoaGFuZGxlKSA9PiBoYW5kbGUoKSk7XG4gICAgICBlbDIuX3hfaWdub3JlICYmIHNraXAoKTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBkZXN0cm95VHJlZShyb290KSB7XG4gIHdhbGsocm9vdCwgKGVsKSA9PiBjbGVhbnVwQXR0cmlidXRlcyhlbCkpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbmV4dFRpY2suanNcbnZhciB0aWNrU3RhY2sgPSBbXTtcbnZhciBpc0hvbGRpbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIG5leHRUaWNrKGNhbGxiYWNrID0gKCkgPT4ge1xufSkge1xuICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgaXNIb2xkaW5nIHx8IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVsZWFzZU5leHRUaWNrcygpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICB0aWNrU3RhY2sucHVzaCgoKSA9PiB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgcmVzKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVsZWFzZU5leHRUaWNrcygpIHtcbiAgaXNIb2xkaW5nID0gZmFsc2U7XG4gIHdoaWxlICh0aWNrU3RhY2subGVuZ3RoKVxuICAgIHRpY2tTdGFjay5zaGlmdCgpKCk7XG59XG5mdW5jdGlvbiBob2xkTmV4dFRpY2tzKCkge1xuICBpc0hvbGRpbmcgPSB0cnVlO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvY2xhc3Nlcy5qc1xuZnVuY3Rpb24gc2V0Q2xhc3NlcyhlbCwgdmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHNldENsYXNzZXNGcm9tU3RyaW5nKGVsLCB2YWx1ZS5qb2luKFwiIFwiKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNldENsYXNzZXNGcm9tT2JqZWN0KGVsLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gc2V0Q2xhc3NlcyhlbCwgdmFsdWUoKSk7XG4gIH1cbiAgcmV0dXJuIHNldENsYXNzZXNGcm9tU3RyaW5nKGVsLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRDbGFzc2VzRnJvbVN0cmluZyhlbCwgY2xhc3NTdHJpbmcpIHtcbiAgbGV0IHNwbGl0ID0gKGNsYXNzU3RyaW5nMikgPT4gY2xhc3NTdHJpbmcyLnNwbGl0KFwiIFwiKS5maWx0ZXIoQm9vbGVhbik7XG4gIGxldCBtaXNzaW5nQ2xhc3NlcyA9IChjbGFzc1N0cmluZzIpID0+IGNsYXNzU3RyaW5nMi5zcGxpdChcIiBcIikuZmlsdGVyKChpKSA9PiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGkpKS5maWx0ZXIoQm9vbGVhbik7XG4gIGxldCBhZGRDbGFzc2VzQW5kUmV0dXJuVW5kbyA9IChjbGFzc2VzKSA9PiB7XG4gICAgZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzKTtcbiAgICB9O1xuICB9O1xuICBjbGFzc1N0cmluZyA9IGNsYXNzU3RyaW5nID09PSB0cnVlID8gY2xhc3NTdHJpbmcgPSBcIlwiIDogY2xhc3NTdHJpbmcgfHwgXCJcIjtcbiAgcmV0dXJuIGFkZENsYXNzZXNBbmRSZXR1cm5VbmRvKG1pc3NpbmdDbGFzc2VzKGNsYXNzU3RyaW5nKSk7XG59XG5mdW5jdGlvbiBzZXRDbGFzc2VzRnJvbU9iamVjdChlbCwgY2xhc3NPYmplY3QpIHtcbiAgbGV0IHNwbGl0ID0gKGNsYXNzU3RyaW5nKSA9PiBjbGFzc1N0cmluZy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pO1xuICBsZXQgZm9yQWRkID0gT2JqZWN0LmVudHJpZXMoY2xhc3NPYmplY3QpLmZsYXRNYXAoKFtjbGFzc1N0cmluZywgYm9vbF0pID0+IGJvb2wgPyBzcGxpdChjbGFzc1N0cmluZykgOiBmYWxzZSkuZmlsdGVyKEJvb2xlYW4pO1xuICBsZXQgZm9yUmVtb3ZlID0gT2JqZWN0LmVudHJpZXMoY2xhc3NPYmplY3QpLmZsYXRNYXAoKFtjbGFzc1N0cmluZywgYm9vbF0pID0+ICFib29sID8gc3BsaXQoY2xhc3NTdHJpbmcpIDogZmFsc2UpLmZpbHRlcihCb29sZWFuKTtcbiAgbGV0IGFkZGVkID0gW107XG4gIGxldCByZW1vdmVkID0gW107XG4gIGZvclJlbW92ZS5mb3JFYWNoKChpKSA9PiB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhpKSkge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShpKTtcbiAgICAgIHJlbW92ZWQucHVzaChpKTtcbiAgICB9XG4gIH0pO1xuICBmb3JBZGQuZm9yRWFjaCgoaSkgPT4ge1xuICAgIGlmICghZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGkpKSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGkpO1xuICAgICAgYWRkZWQucHVzaChpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHJlbW92ZWQuZm9yRWFjaCgoaSkgPT4gZWwuY2xhc3NMaXN0LmFkZChpKSk7XG4gICAgYWRkZWQuZm9yRWFjaCgoaSkgPT4gZWwuY2xhc3NMaXN0LnJlbW92ZShpKSk7XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9zdHlsZXMuanNcbmZ1bmN0aW9uIHNldFN0eWxlcyhlbCwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzZXRTdHlsZXNGcm9tT2JqZWN0KGVsLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHNldFN0eWxlc0Zyb21TdHJpbmcoZWwsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNldFN0eWxlc0Zyb21PYmplY3QoZWwsIHZhbHVlKSB7XG4gIGxldCBwcmV2aW91c1N0eWxlcyA9IHt9O1xuICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW2tleSwgdmFsdWUyXSkgPT4ge1xuICAgIHByZXZpb3VzU3R5bGVzW2tleV0gPSBlbC5zdHlsZVtrZXldO1xuICAgIGlmICgha2V5LnN0YXJ0c1dpdGgoXCItLVwiKSkge1xuICAgICAga2V5ID0ga2ViYWJDYXNlKGtleSk7XG4gICAgfVxuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUyKTtcbiAgfSk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmIChlbC5zdHlsZS5sZW5ndGggPT09IDApIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgc2V0U3R5bGVzKGVsLCBwcmV2aW91c1N0eWxlcyk7XG4gIH07XG59XG5mdW5jdGlvbiBzZXRTdHlsZXNGcm9tU3RyaW5nKGVsLCB2YWx1ZSkge1xuICBsZXQgY2FjaGUgPSBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCB2YWx1ZSk7XG4gIGVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIHZhbHVlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBjYWNoZSB8fCBcIlwiKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGtlYmFiQ2FzZShzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0LnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csIFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL29uY2UuanNcbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2ssIGZhbGxiYWNrID0gKCkgPT4ge1xufSkge1xuICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LXRyYW5zaXRpb24uanNcbmRpcmVjdGl2ZShcInRyYW5zaXRpb25cIiwgKGVsLCB7IHZhbHVlLCBtb2RpZmllcnMsIGV4cHJlc3Npb24gfSwgeyBldmFsdWF0ZTogZXZhbHVhdGUyIH0pID0+IHtcbiAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSBcImZ1bmN0aW9uXCIpXG4gICAgZXhwcmVzc2lvbiA9IGV2YWx1YXRlMihleHByZXNzaW9uKTtcbiAgaWYgKGV4cHJlc3Npb24gPT09IGZhbHNlKVxuICAgIHJldHVybjtcbiAgaWYgKCFleHByZXNzaW9uIHx8IHR5cGVvZiBleHByZXNzaW9uID09PSBcImJvb2xlYW5cIikge1xuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbnNGcm9tSGVscGVyKGVsLCBtb2RpZmllcnMsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZWdpc3RlclRyYW5zaXRpb25zRnJvbUNsYXNzU3RyaW5nKGVsLCBleHByZXNzaW9uLCB2YWx1ZSk7XG4gIH1cbn0pO1xuZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uc0Zyb21DbGFzc1N0cmluZyhlbCwgY2xhc3NTdHJpbmcsIHN0YWdlKSB7XG4gIHJlZ2lzdGVyVHJhbnNpdGlvbk9iamVjdChlbCwgc2V0Q2xhc3NlcywgXCJcIik7XG4gIGxldCBkaXJlY3RpdmVTdG9yYWdlTWFwID0ge1xuICAgIFwiZW50ZXJcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24uZW50ZXIuZHVyaW5nID0gY2xhc3NlcztcbiAgICB9LFxuICAgIFwiZW50ZXItc3RhcnRcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24uZW50ZXIuc3RhcnQgPSBjbGFzc2VzO1xuICAgIH0sXG4gICAgXCJlbnRlci1lbmRcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24uZW50ZXIuZW5kID0gY2xhc3NlcztcbiAgICB9LFxuICAgIFwibGVhdmVcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZHVyaW5nID0gY2xhc3NlcztcbiAgICB9LFxuICAgIFwibGVhdmUtc3RhcnRcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuc3RhcnQgPSBjbGFzc2VzO1xuICAgIH0sXG4gICAgXCJsZWF2ZS1lbmRcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZW5kID0gY2xhc3NlcztcbiAgICB9XG4gIH07XG4gIGRpcmVjdGl2ZVN0b3JhZ2VNYXBbc3RhZ2VdKGNsYXNzU3RyaW5nKTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyVHJhbnNpdGlvbnNGcm9tSGVscGVyKGVsLCBtb2RpZmllcnMsIHN0YWdlKSB7XG4gIHJlZ2lzdGVyVHJhbnNpdGlvbk9iamVjdChlbCwgc2V0U3R5bGVzKTtcbiAgbGV0IGRvZXNudFNwZWNpZnkgPSAhbW9kaWZpZXJzLmluY2x1ZGVzKFwiaW5cIikgJiYgIW1vZGlmaWVycy5pbmNsdWRlcyhcIm91dFwiKSAmJiAhc3RhZ2U7XG4gIGxldCB0cmFuc2l0aW9uaW5nSW4gPSBkb2VzbnRTcGVjaWZ5IHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcImluXCIpIHx8IFtcImVudGVyXCJdLmluY2x1ZGVzKHN0YWdlKTtcbiAgbGV0IHRyYW5zaXRpb25pbmdPdXQgPSBkb2VzbnRTcGVjaWZ5IHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcIm91dFwiKSB8fCBbXCJsZWF2ZVwiXS5pbmNsdWRlcyhzdGFnZSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJpblwiKSAmJiAhZG9lc250U3BlY2lmeSkge1xuICAgIG1vZGlmaWVycyA9IG1vZGlmaWVycy5maWx0ZXIoKGksIGluZGV4KSA9PiBpbmRleCA8IG1vZGlmaWVycy5pbmRleE9mKFwib3V0XCIpKTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwib3V0XCIpICYmICFkb2VzbnRTcGVjaWZ5KSB7XG4gICAgbW9kaWZpZXJzID0gbW9kaWZpZXJzLmZpbHRlcigoaSwgaW5kZXgpID0+IGluZGV4ID4gbW9kaWZpZXJzLmluZGV4T2YoXCJvdXRcIikpO1xuICB9XG4gIGxldCB3YW50c0FsbCA9ICFtb2RpZmllcnMuaW5jbHVkZXMoXCJvcGFjaXR5XCIpICYmICFtb2RpZmllcnMuaW5jbHVkZXMoXCJzY2FsZVwiKTtcbiAgbGV0IHdhbnRzT3BhY2l0eSA9IHdhbnRzQWxsIHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcIm9wYWNpdHlcIik7XG4gIGxldCB3YW50c1NjYWxlID0gd2FudHNBbGwgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKFwic2NhbGVcIik7XG4gIGxldCBvcGFjaXR5VmFsdWUgPSB3YW50c09wYWNpdHkgPyAwIDogMTtcbiAgbGV0IHNjYWxlVmFsdWUgPSB3YW50c1NjYWxlID8gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwic2NhbGVcIiwgOTUpIC8gMTAwIDogMTtcbiAgbGV0IGRlbGF5ID0gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwiZGVsYXlcIiwgMCkgLyAxZTM7XG4gIGxldCBvcmlnaW4gPSBtb2RpZmllclZhbHVlKG1vZGlmaWVycywgXCJvcmlnaW5cIiwgXCJjZW50ZXJcIik7XG4gIGxldCBwcm9wZXJ0eSA9IFwib3BhY2l0eSwgdHJhbnNmb3JtXCI7XG4gIGxldCBkdXJhdGlvbkluID0gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwiZHVyYXRpb25cIiwgMTUwKSAvIDFlMztcbiAgbGV0IGR1cmF0aW9uT3V0ID0gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwiZHVyYXRpb25cIiwgNzUpIC8gMWUzO1xuICBsZXQgZWFzaW5nID0gYGN1YmljLWJlemllcigwLjQsIDAuMCwgMC4yLCAxKWA7XG4gIGlmICh0cmFuc2l0aW9uaW5nSW4pIHtcbiAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLmR1cmluZyA9IHtcbiAgICAgIHRyYW5zZm9ybU9yaWdpbjogb3JpZ2luLFxuICAgICAgdHJhbnNpdGlvbkRlbGF5OiBgJHtkZWxheX1zYCxcbiAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogcHJvcGVydHksXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGAke2R1cmF0aW9uSW59c2AsXG4gICAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGVhc2luZ1xuICAgIH07XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5zdGFydCA9IHtcbiAgICAgIG9wYWNpdHk6IG9wYWNpdHlWYWx1ZSxcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7c2NhbGVWYWx1ZX0pYFxuICAgIH07XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5lbmQgPSB7XG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoMSlgXG4gICAgfTtcbiAgfVxuICBpZiAodHJhbnNpdGlvbmluZ091dCkge1xuICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZHVyaW5nID0ge1xuICAgICAgdHJhbnNmb3JtT3JpZ2luOiBvcmlnaW4sXG4gICAgICB0cmFuc2l0aW9uRGVsYXk6IGAke2RlbGF5fXNgLFxuICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBwcm9wZXJ0eSxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogYCR7ZHVyYXRpb25PdXR9c2AsXG4gICAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGVhc2luZ1xuICAgIH07XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5sZWF2ZS5zdGFydCA9IHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICB0cmFuc2Zvcm06IGBzY2FsZSgxKWBcbiAgICB9O1xuICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZW5kID0ge1xuICAgICAgb3BhY2l0eTogb3BhY2l0eVZhbHVlLFxuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHtzY2FsZVZhbHVlfSlgXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uT2JqZWN0KGVsLCBzZXRGdW5jdGlvbiwgZGVmYXVsdFZhbHVlID0ge30pIHtcbiAgaWYgKCFlbC5feF90cmFuc2l0aW9uKVxuICAgIGVsLl94X3RyYW5zaXRpb24gPSB7XG4gICAgICBlbnRlcjogeyBkdXJpbmc6IGRlZmF1bHRWYWx1ZSwgc3RhcnQ6IGRlZmF1bHRWYWx1ZSwgZW5kOiBkZWZhdWx0VmFsdWUgfSxcbiAgICAgIGxlYXZlOiB7IGR1cmluZzogZGVmYXVsdFZhbHVlLCBzdGFydDogZGVmYXVsdFZhbHVlLCBlbmQ6IGRlZmF1bHRWYWx1ZSB9LFxuICAgICAgaW4oYmVmb3JlID0gKCkgPT4ge1xuICAgICAgfSwgYWZ0ZXIgPSAoKSA9PiB7XG4gICAgICB9KSB7XG4gICAgICAgIHRyYW5zaXRpb24oZWwsIHNldEZ1bmN0aW9uLCB7XG4gICAgICAgICAgZHVyaW5nOiB0aGlzLmVudGVyLmR1cmluZyxcbiAgICAgICAgICBzdGFydDogdGhpcy5lbnRlci5zdGFydCxcbiAgICAgICAgICBlbmQ6IHRoaXMuZW50ZXIuZW5kXG4gICAgICAgIH0sIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgfSxcbiAgICAgIG91dChiZWZvcmUgPSAoKSA9PiB7XG4gICAgICB9LCBhZnRlciA9ICgpID0+IHtcbiAgICAgIH0pIHtcbiAgICAgICAgdHJhbnNpdGlvbihlbCwgc2V0RnVuY3Rpb24sIHtcbiAgICAgICAgICBkdXJpbmc6IHRoaXMubGVhdmUuZHVyaW5nLFxuICAgICAgICAgIHN0YXJ0OiB0aGlzLmxlYXZlLnN0YXJ0LFxuICAgICAgICAgIGVuZDogdGhpcy5sZWF2ZS5lbmRcbiAgICAgICAgfSwgYmVmb3JlLCBhZnRlcik7XG4gICAgICB9XG4gICAgfTtcbn1cbndpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5feF90b2dnbGVBbmRDYXNjYWRlV2l0aFRyYW5zaXRpb25zID0gZnVuY3Rpb24oZWwsIHZhbHVlLCBzaG93LCBoaWRlKSB7XG4gIGNvbnN0IG5leHRUaWNrMiA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJ2aXNpYmxlXCIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBzZXRUaW1lb3V0O1xuICBsZXQgY2xpY2tBd2F5Q29tcGF0aWJsZVNob3cgPSAoKSA9PiBuZXh0VGljazIoc2hvdyk7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmIChlbC5feF90cmFuc2l0aW9uICYmIChlbC5feF90cmFuc2l0aW9uLmVudGVyIHx8IGVsLl94X3RyYW5zaXRpb24ubGVhdmUpKSB7XG4gICAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyICYmIChPYmplY3QuZW50cmllcyhlbC5feF90cmFuc2l0aW9uLmVudGVyLmR1cmluZykubGVuZ3RoIHx8IE9iamVjdC5lbnRyaWVzKGVsLl94X3RyYW5zaXRpb24uZW50ZXIuc3RhcnQpLmxlbmd0aCB8fCBPYmplY3QuZW50cmllcyhlbC5feF90cmFuc2l0aW9uLmVudGVyLmVuZCkubGVuZ3RoKSA/IGVsLl94X3RyYW5zaXRpb24uaW4oc2hvdykgOiBjbGlja0F3YXlDb21wYXRpYmxlU2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5feF90cmFuc2l0aW9uID8gZWwuX3hfdHJhbnNpdGlvbi5pbihzaG93KSA6IGNsaWNrQXdheUNvbXBhdGlibGVTaG93KCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBlbC5feF9oaWRlUHJvbWlzZSA9IGVsLl94X3RyYW5zaXRpb24gPyBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5vdXQoKCkgPT4ge1xuICAgIH0sICgpID0+IHJlc29sdmUoaGlkZSkpO1xuICAgIGVsLl94X3RyYW5zaXRpb25pbmcuYmVmb3JlQ2FuY2VsKCgpID0+IHJlamVjdCh7IGlzRnJvbUNhbmNlbGxlZFRyYW5zaXRpb246IHRydWUgfSkpO1xuICB9KSA6IFByb21pc2UucmVzb2x2ZShoaWRlKTtcbiAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgIGxldCBjbG9zZXN0ID0gY2xvc2VzdEhpZGUoZWwpO1xuICAgIGlmIChjbG9zZXN0KSB7XG4gICAgICBpZiAoIWNsb3Nlc3QuX3hfaGlkZUNoaWxkcmVuKVxuICAgICAgICBjbG9zZXN0Ll94X2hpZGVDaGlsZHJlbiA9IFtdO1xuICAgICAgY2xvc2VzdC5feF9oaWRlQ2hpbGRyZW4ucHVzaChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRUaWNrMigoKSA9PiB7XG4gICAgICAgIGxldCBoaWRlQWZ0ZXJDaGlsZHJlbiA9IChlbDIpID0+IHtcbiAgICAgICAgICBsZXQgY2FycnkgPSBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBlbDIuX3hfaGlkZVByb21pc2UsXG4gICAgICAgICAgICAuLi4oZWwyLl94X2hpZGVDaGlsZHJlbiB8fCBbXSkubWFwKGhpZGVBZnRlckNoaWxkcmVuKVxuICAgICAgICAgIF0pLnRoZW4oKFtpXSkgPT4gaSgpKTtcbiAgICAgICAgICBkZWxldGUgZWwyLl94X2hpZGVQcm9taXNlO1xuICAgICAgICAgIGRlbGV0ZSBlbDIuX3hfaGlkZUNoaWxkcmVuO1xuICAgICAgICAgIHJldHVybiBjYXJyeTtcbiAgICAgICAgfTtcbiAgICAgICAgaGlkZUFmdGVyQ2hpbGRyZW4oZWwpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgaWYgKCFlLmlzRnJvbUNhbmNlbGxlZFRyYW5zaXRpb24pXG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuZnVuY3Rpb24gY2xvc2VzdEhpZGUoZWwpIHtcbiAgbGV0IHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gIGlmICghcGFyZW50KVxuICAgIHJldHVybjtcbiAgcmV0dXJuIHBhcmVudC5feF9oaWRlUHJvbWlzZSA/IHBhcmVudCA6IGNsb3Nlc3RIaWRlKHBhcmVudCk7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uKGVsLCBzZXRGdW5jdGlvbiwgeyBkdXJpbmcsIHN0YXJ0OiBzdGFydDIsIGVuZCB9ID0ge30sIGJlZm9yZSA9ICgpID0+IHtcbn0sIGFmdGVyID0gKCkgPT4ge1xufSkge1xuICBpZiAoZWwuX3hfdHJhbnNpdGlvbmluZylcbiAgICBlbC5feF90cmFuc2l0aW9uaW5nLmNhbmNlbCgpO1xuICBpZiAoT2JqZWN0LmtleXMoZHVyaW5nKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoc3RhcnQyKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoZW5kKS5sZW5ndGggPT09IDApIHtcbiAgICBiZWZvcmUoKTtcbiAgICBhZnRlcigpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgdW5kb1N0YXJ0LCB1bmRvRHVyaW5nLCB1bmRvRW5kO1xuICBwZXJmb3JtVHJhbnNpdGlvbihlbCwge1xuICAgIHN0YXJ0KCkge1xuICAgICAgdW5kb1N0YXJ0ID0gc2V0RnVuY3Rpb24oZWwsIHN0YXJ0Mik7XG4gICAgfSxcbiAgICBkdXJpbmcoKSB7XG4gICAgICB1bmRvRHVyaW5nID0gc2V0RnVuY3Rpb24oZWwsIGR1cmluZyk7XG4gICAgfSxcbiAgICBiZWZvcmUsXG4gICAgZW5kKCkge1xuICAgICAgdW5kb1N0YXJ0KCk7XG4gICAgICB1bmRvRW5kID0gc2V0RnVuY3Rpb24oZWwsIGVuZCk7XG4gICAgfSxcbiAgICBhZnRlcixcbiAgICBjbGVhbnVwKCkge1xuICAgICAgdW5kb0R1cmluZygpO1xuICAgICAgdW5kb0VuZCgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBwZXJmb3JtVHJhbnNpdGlvbihlbCwgc3RhZ2VzKSB7XG4gIGxldCBpbnRlcnJ1cHRlZCwgcmVhY2hlZEJlZm9yZSwgcmVhY2hlZEVuZDtcbiAgbGV0IGZpbmlzaCA9IG9uY2UoKCkgPT4ge1xuICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICBpbnRlcnJ1cHRlZCA9IHRydWU7XG4gICAgICBpZiAoIXJlYWNoZWRCZWZvcmUpXG4gICAgICAgIHN0YWdlcy5iZWZvcmUoKTtcbiAgICAgIGlmICghcmVhY2hlZEVuZCkge1xuICAgICAgICBzdGFnZXMuZW5kKCk7XG4gICAgICAgIHJlbGVhc2VOZXh0VGlja3MoKTtcbiAgICAgIH1cbiAgICAgIHN0YWdlcy5hZnRlcigpO1xuICAgICAgaWYgKGVsLmlzQ29ubmVjdGVkKVxuICAgICAgICBzdGFnZXMuY2xlYW51cCgpO1xuICAgICAgZGVsZXRlIGVsLl94X3RyYW5zaXRpb25pbmc7XG4gICAgfSk7XG4gIH0pO1xuICBlbC5feF90cmFuc2l0aW9uaW5nID0ge1xuICAgIGJlZm9yZUNhbmNlbHM6IFtdLFxuICAgIGJlZm9yZUNhbmNlbChjYWxsYmFjaykge1xuICAgICAgdGhpcy5iZWZvcmVDYW5jZWxzLnB1c2goY2FsbGJhY2spO1xuICAgIH0sXG4gICAgY2FuY2VsOiBvbmNlKGZ1bmN0aW9uKCkge1xuICAgICAgd2hpbGUgKHRoaXMuYmVmb3JlQ2FuY2Vscy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5iZWZvcmVDYW5jZWxzLnNoaWZ0KCkoKTtcbiAgICAgIH1cbiAgICAgIDtcbiAgICAgIGZpbmlzaCgpO1xuICAgIH0pLFxuICAgIGZpbmlzaFxuICB9O1xuICBtdXRhdGVEb20oKCkgPT4ge1xuICAgIHN0YWdlcy5zdGFydCgpO1xuICAgIHN0YWdlcy5kdXJpbmcoKTtcbiAgfSk7XG4gIGhvbGROZXh0VGlja3MoKTtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICBpZiAoaW50ZXJydXB0ZWQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGR1cmF0aW9uID0gTnVtYmVyKGdldENvbXB1dGVkU3R5bGUoZWwpLnRyYW5zaXRpb25EdXJhdGlvbi5yZXBsYWNlKC8sLiovLCBcIlwiKS5yZXBsYWNlKFwic1wiLCBcIlwiKSkgKiAxZTM7XG4gICAgbGV0IGRlbGF5ID0gTnVtYmVyKGdldENvbXB1dGVkU3R5bGUoZWwpLnRyYW5zaXRpb25EZWxheS5yZXBsYWNlKC8sLiovLCBcIlwiKS5yZXBsYWNlKFwic1wiLCBcIlwiKSkgKiAxZTM7XG4gICAgaWYgKGR1cmF0aW9uID09PSAwKVxuICAgICAgZHVyYXRpb24gPSBOdW1iZXIoZ2V0Q29tcHV0ZWRTdHlsZShlbCkuYW5pbWF0aW9uRHVyYXRpb24ucmVwbGFjZShcInNcIiwgXCJcIikpICogMWUzO1xuICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICBzdGFnZXMuYmVmb3JlKCk7XG4gICAgfSk7XG4gICAgcmVhY2hlZEJlZm9yZSA9IHRydWU7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmIChpbnRlcnJ1cHRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgICAgc3RhZ2VzLmVuZCgpO1xuICAgICAgfSk7XG4gICAgICByZWxlYXNlTmV4dFRpY2tzKCk7XG4gICAgICBzZXRUaW1lb3V0KGVsLl94X3RyYW5zaXRpb25pbmcuZmluaXNoLCBkdXJhdGlvbiArIGRlbGF5KTtcbiAgICAgIHJlYWNoZWRFbmQgPSB0cnVlO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCBrZXksIGZhbGxiYWNrKSB7XG4gIGlmIChtb2RpZmllcnMuaW5kZXhPZihrZXkpID09PSAtMSlcbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIGNvbnN0IHJhd1ZhbHVlID0gbW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKGtleSkgKyAxXTtcbiAgaWYgKCFyYXdWYWx1ZSlcbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIGlmIChrZXkgPT09IFwic2NhbGVcIikge1xuICAgIGlmIChpc05hTihyYXdWYWx1ZSkpXG4gICAgICByZXR1cm4gZmFsbGJhY2s7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJkdXJhdGlvblwiIHx8IGtleSA9PT0gXCJkZWxheVwiKSB7XG4gICAgbGV0IG1hdGNoID0gcmF3VmFsdWUubWF0Y2goLyhbMC05XSspbXMvKTtcbiAgICBpZiAobWF0Y2gpXG4gICAgICByZXR1cm4gbWF0Y2hbMV07XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJvcmlnaW5cIikge1xuICAgIGlmIChbXCJ0b3BcIiwgXCJyaWdodFwiLCBcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJib3R0b21cIl0uaW5jbHVkZXMobW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKGtleSkgKyAyXSkpIHtcbiAgICAgIHJldHVybiBbcmF3VmFsdWUsIG1vZGlmaWVyc1ttb2RpZmllcnMuaW5kZXhPZihrZXkpICsgMl1dLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmF3VmFsdWU7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9jbG9uZS5qc1xudmFyIGlzQ2xvbmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gc2tpcER1cmluZ0Nsb25lKGNhbGxiYWNrLCBmYWxsYmFjayA9ICgpID0+IHtcbn0pIHtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiBpc0Nsb25pbmcgPyBmYWxsYmFjayguLi5hcmdzKSA6IGNhbGxiYWNrKC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gb25seUR1cmluZ0Nsb25lKGNhbGxiYWNrKSB7XG4gIHJldHVybiAoLi4uYXJncykgPT4gaXNDbG9uaW5nICYmIGNhbGxiYWNrKC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gY2xvbmUob2xkRWwsIG5ld0VsKSB7XG4gIGlmICghbmV3RWwuX3hfZGF0YVN0YWNrKVxuICAgIG5ld0VsLl94X2RhdGFTdGFjayA9IG9sZEVsLl94X2RhdGFTdGFjaztcbiAgaXNDbG9uaW5nID0gdHJ1ZTtcbiAgZG9udFJlZ2lzdGVyUmVhY3RpdmVTaWRlRWZmZWN0cygoKSA9PiB7XG4gICAgY2xvbmVUcmVlKG5ld0VsKTtcbiAgfSk7XG4gIGlzQ2xvbmluZyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gY2xvbmVUcmVlKGVsKSB7XG4gIGxldCBoYXNSdW5UaHJvdWdoRmlyc3RFbCA9IGZhbHNlO1xuICBsZXQgc2hhbGxvd1dhbGtlciA9IChlbDIsIGNhbGxiYWNrKSA9PiB7XG4gICAgd2FsayhlbDIsIChlbDMsIHNraXApID0+IHtcbiAgICAgIGlmIChoYXNSdW5UaHJvdWdoRmlyc3RFbCAmJiBpc1Jvb3QoZWwzKSlcbiAgICAgICAgcmV0dXJuIHNraXAoKTtcbiAgICAgIGhhc1J1blRocm91Z2hGaXJzdEVsID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKGVsMywgc2tpcCk7XG4gICAgfSk7XG4gIH07XG4gIGluaXRUcmVlKGVsLCBzaGFsbG93V2Fsa2VyKTtcbn1cbmZ1bmN0aW9uIGRvbnRSZWdpc3RlclJlYWN0aXZlU2lkZUVmZmVjdHMoY2FsbGJhY2spIHtcbiAgbGV0IGNhY2hlID0gZWZmZWN0O1xuICBvdmVycmlkZUVmZmVjdCgoY2FsbGJhY2syLCBlbCkgPT4ge1xuICAgIGxldCBzdG9yZWRFZmZlY3QgPSBjYWNoZShjYWxsYmFjazIpO1xuICAgIHJlbGVhc2Uoc3RvcmVkRWZmZWN0KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH0pO1xuICBjYWxsYmFjaygpO1xuICBvdmVycmlkZUVmZmVjdChjYWNoZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9iaW5kLmpzXG5mdW5jdGlvbiBiaW5kKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzID0gW10pIHtcbiAgaWYgKCFlbC5feF9iaW5kaW5ncylcbiAgICBlbC5feF9iaW5kaW5ncyA9IHJlYWN0aXZlKHt9KTtcbiAgZWwuX3hfYmluZGluZ3NbbmFtZV0gPSB2YWx1ZTtcbiAgbmFtZSA9IG1vZGlmaWVycy5pbmNsdWRlcyhcImNhbWVsXCIpID8gY2FtZWxDYXNlKG5hbWUpIDogbmFtZTtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICBiaW5kSW5wdXRWYWx1ZShlbCwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICBiaW5kU3R5bGVzKGVsLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgIGJpbmRDbGFzc2VzKGVsLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic2VsZWN0ZWRcIjpcbiAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgYmluZEF0dHJpYnV0ZUFuZFByb3BlcnR5KGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYmluZEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cbmZ1bmN0aW9uIGJpbmRJbnB1dFZhbHVlKGVsLCB2YWx1ZSkge1xuICBpZiAoZWwudHlwZSA9PT0gXCJyYWRpb1wiKSB7XG4gICAgaWYgKGVsLmF0dHJpYnV0ZXMudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgZWwudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5mcm9tTW9kZWwpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSBjaGVja2VkQXR0ckxvb3NlQ29tcGFyZShlbC52YWx1ZSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlbC50eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIGVsLnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJib29sZWFuXCIgJiYgIVtudWxsLCB2b2lkIDBdLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgZWwudmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9IHZhbHVlLnNvbWUoKHZhbCkgPT4gY2hlY2tlZEF0dHJMb29zZUNvbXBhcmUodmFsLCBlbC52YWx1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9ICEhdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGVsLnRhZ05hbWUgPT09IFwiU0VMRUNUXCIpIHtcbiAgICB1cGRhdGVTZWxlY3QoZWwsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZWwudmFsdWUgPT09IHZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGVsLnZhbHVlID0gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJpbmRDbGFzc2VzKGVsLCB2YWx1ZSkge1xuICBpZiAoZWwuX3hfdW5kb0FkZGVkQ2xhc3NlcylcbiAgICBlbC5feF91bmRvQWRkZWRDbGFzc2VzKCk7XG4gIGVsLl94X3VuZG9BZGRlZENsYXNzZXMgPSBzZXRDbGFzc2VzKGVsLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBiaW5kU3R5bGVzKGVsLCB2YWx1ZSkge1xuICBpZiAoZWwuX3hfdW5kb0FkZGVkU3R5bGVzKVxuICAgIGVsLl94X3VuZG9BZGRlZFN0eWxlcygpO1xuICBlbC5feF91bmRvQWRkZWRTdHlsZXMgPSBzZXRTdHlsZXMoZWwsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGJpbmRBdHRyaWJ1dGVBbmRQcm9wZXJ0eShlbCwgbmFtZSwgdmFsdWUpIHtcbiAgYmluZEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUpO1xuICBzZXRQcm9wZXJ0eUlmQ2hhbmdlZChlbCwgbmFtZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gYmluZEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKFtudWxsLCB2b2lkIDAsIGZhbHNlXS5pbmNsdWRlcyh2YWx1ZSkgJiYgYXR0cmlidXRlU2hvdWxkbnRCZVByZXNlcnZlZElmRmFsc3kobmFtZSkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzQm9vbGVhbkF0dHIobmFtZSkpXG4gICAgICB2YWx1ZSA9IG5hbWU7XG4gICAgc2V0SWZDaGFuZ2VkKGVsLCBuYW1lLCB2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldElmQ2hhbmdlZChlbCwgYXR0ck5hbWUsIHZhbHVlKSB7XG4gIGlmIChlbC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpICE9IHZhbHVlKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCB2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFByb3BlcnR5SWZDaGFuZ2VkKGVsLCBwcm9wTmFtZSwgdmFsdWUpIHtcbiAgaWYgKGVsW3Byb3BOYW1lXSAhPT0gdmFsdWUpIHtcbiAgICBlbFtwcm9wTmFtZV0gPSB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlU2VsZWN0KGVsLCB2YWx1ZSkge1xuICBjb25zdCBhcnJheVdyYXBwZWRWYWx1ZSA9IFtdLmNvbmNhdCh2YWx1ZSkubWFwKCh2YWx1ZTIpID0+IHtcbiAgICByZXR1cm4gdmFsdWUyICsgXCJcIjtcbiAgfSk7XG4gIEFycmF5LmZyb20oZWwub3B0aW9ucykuZm9yRWFjaCgob3B0aW9uKSA9PiB7XG4gICAgb3B0aW9uLnNlbGVjdGVkID0gYXJyYXlXcmFwcGVkVmFsdWUuaW5jbHVkZXMob3B0aW9uLnZhbHVlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjYW1lbENhc2Uoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oXFx3KS9nLCAobWF0Y2gsIGNoYXIpID0+IGNoYXIudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBjaGVja2VkQXR0ckxvb3NlQ29tcGFyZSh2YWx1ZUEsIHZhbHVlQikge1xuICByZXR1cm4gdmFsdWVBID09IHZhbHVlQjtcbn1cbmZ1bmN0aW9uIGlzQm9vbGVhbkF0dHIoYXR0ck5hbWUpIHtcbiAgY29uc3QgYm9vbGVhbkF0dHJpYnV0ZXMgPSBbXG4gICAgXCJkaXNhYmxlZFwiLFxuICAgIFwiY2hlY2tlZFwiLFxuICAgIFwicmVxdWlyZWRcIixcbiAgICBcInJlYWRvbmx5XCIsXG4gICAgXCJoaWRkZW5cIixcbiAgICBcIm9wZW5cIixcbiAgICBcInNlbGVjdGVkXCIsXG4gICAgXCJhdXRvZm9jdXNcIixcbiAgICBcIml0ZW1zY29wZVwiLFxuICAgIFwibXVsdGlwbGVcIixcbiAgICBcIm5vdmFsaWRhdGVcIixcbiAgICBcImFsbG93ZnVsbHNjcmVlblwiLFxuICAgIFwiYWxsb3dwYXltZW50cmVxdWVzdFwiLFxuICAgIFwiZm9ybW5vdmFsaWRhdGVcIixcbiAgICBcImF1dG9wbGF5XCIsXG4gICAgXCJjb250cm9sc1wiLFxuICAgIFwibG9vcFwiLFxuICAgIFwibXV0ZWRcIixcbiAgICBcInBsYXlzaW5saW5lXCIsXG4gICAgXCJkZWZhdWx0XCIsXG4gICAgXCJpc21hcFwiLFxuICAgIFwicmV2ZXJzZWRcIixcbiAgICBcImFzeW5jXCIsXG4gICAgXCJkZWZlclwiLFxuICAgIFwibm9tb2R1bGVcIlxuICBdO1xuICByZXR1cm4gYm9vbGVhbkF0dHJpYnV0ZXMuaW5jbHVkZXMoYXR0ck5hbWUpO1xufVxuZnVuY3Rpb24gYXR0cmlidXRlU2hvdWxkbnRCZVByZXNlcnZlZElmRmFsc3kobmFtZSkge1xuICByZXR1cm4gIVtcImFyaWEtcHJlc3NlZFwiLCBcImFyaWEtY2hlY2tlZFwiLCBcImFyaWEtZXhwYW5kZWRcIiwgXCJhcmlhLXNlbGVjdGVkXCJdLmluY2x1ZGVzKG5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0QmluZGluZyhlbCwgbmFtZSwgZmFsbGJhY2spIHtcbiAgaWYgKGVsLl94X2JpbmRpbmdzICYmIGVsLl94X2JpbmRpbmdzW25hbWVdICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIGVsLl94X2JpbmRpbmdzW25hbWVdO1xuICBsZXQgYXR0ciA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgaWYgKGF0dHIgPT09IG51bGwpXG4gICAgcmV0dXJuIHR5cGVvZiBmYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiID8gZmFsbGJhY2soKSA6IGZhbGxiYWNrO1xuICBpZiAoYXR0ciA9PT0gXCJcIilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKGlzQm9vbGVhbkF0dHIobmFtZSkpIHtcbiAgICByZXR1cm4gISFbbmFtZSwgXCJ0cnVlXCJdLmluY2x1ZGVzKGF0dHIpO1xuICB9XG4gIHJldHVybiBhdHRyO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvZGVib3VuY2UuanNcbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQpIHtcbiAgdmFyIHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvdGhyb3R0bGUuanNcbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIGxpbWl0KSB7XG4gIGxldCBpblRocm90dGxlO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgbGV0IGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgIGlmICghaW5UaHJvdHRsZSkge1xuICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGluVGhyb3R0bGUgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBpblRocm90dGxlID0gZmFsc2UsIGxpbWl0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9wbHVnaW4uanNcbmZ1bmN0aW9uIHBsdWdpbihjYWxsYmFjaykge1xuICBsZXQgY2FsbGJhY2tzID0gQXJyYXkuaXNBcnJheShjYWxsYmFjaykgPyBjYWxsYmFjayA6IFtjYWxsYmFja107XG4gIGNhbGxiYWNrcy5mb3JFYWNoKChpKSA9PiBpKGFscGluZV9kZWZhdWx0KSk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9zdG9yZS5qc1xudmFyIHN0b3JlcyA9IHt9O1xudmFyIGlzUmVhY3RpdmUgPSBmYWxzZTtcbmZ1bmN0aW9uIHN0b3JlKG5hbWUsIHZhbHVlKSB7XG4gIGlmICghaXNSZWFjdGl2ZSkge1xuICAgIHN0b3JlcyA9IHJlYWN0aXZlKHN0b3Jlcyk7XG4gICAgaXNSZWFjdGl2ZSA9IHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gc3RvcmVzW25hbWVdO1xuICB9XG4gIHN0b3Jlc1tuYW1lXSA9IHZhbHVlO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlLmhhc093blByb3BlcnR5KFwiaW5pdFwiKSAmJiB0eXBlb2YgdmFsdWUuaW5pdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgc3RvcmVzW25hbWVdLmluaXQoKTtcbiAgfVxuICBpbml0SW50ZXJjZXB0b3JzKHN0b3Jlc1tuYW1lXSk7XG59XG5mdW5jdGlvbiBnZXRTdG9yZXMoKSB7XG4gIHJldHVybiBzdG9yZXM7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9iaW5kcy5qc1xudmFyIGJpbmRzID0ge307XG5mdW5jdGlvbiBiaW5kMihuYW1lLCBiaW5kaW5ncykge1xuICBsZXQgZ2V0QmluZGluZ3MgPSB0eXBlb2YgYmluZGluZ3MgIT09IFwiZnVuY3Rpb25cIiA/ICgpID0+IGJpbmRpbmdzIDogYmluZGluZ3M7XG4gIGlmIChuYW1lIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgIGFwcGx5QmluZGluZ3NPYmplY3QobmFtZSwgZ2V0QmluZGluZ3MoKSk7XG4gIH0gZWxzZSB7XG4gICAgYmluZHNbbmFtZV0gPSBnZXRCaW5kaW5ncztcbiAgfVxufVxuZnVuY3Rpb24gaW5qZWN0QmluZGluZ1Byb3ZpZGVycyhvYmopIHtcbiAgT2JqZWN0LmVudHJpZXMoYmluZHMpLmZvckVhY2goKFtuYW1lLCBjYWxsYmFja10pID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayguLi5hcmdzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBhcHBseUJpbmRpbmdzT2JqZWN0KGVsLCBvYmosIG9yaWdpbmFsKSB7XG4gIGxldCBjbGVhbnVwUnVubmVycyA9IFtdO1xuICB3aGlsZSAoY2xlYW51cFJ1bm5lcnMubGVuZ3RoKVxuICAgIGNsZWFudXBSdW5uZXJzLnBvcCgpKCk7XG4gIGxldCBhdHRyaWJ1dGVzID0gT2JqZWN0LmVudHJpZXMob2JqKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+ICh7IG5hbWUsIHZhbHVlIH0pKTtcbiAgbGV0IHN0YXRpY0F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzT25seShhdHRyaWJ1dGVzKTtcbiAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMubWFwKChhdHRyaWJ1dGUpID0+IHtcbiAgICBpZiAoc3RhdGljQXR0cmlidXRlcy5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09IGF0dHJpYnV0ZS5uYW1lKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogYHgtYmluZDoke2F0dHJpYnV0ZS5uYW1lfWAsXG4gICAgICAgIHZhbHVlOiBgXCIke2F0dHJpYnV0ZS52YWx1ZX1cImBcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gIH0pO1xuICBkaXJlY3RpdmVzKGVsLCBhdHRyaWJ1dGVzLCBvcmlnaW5hbCkubWFwKChoYW5kbGUpID0+IHtcbiAgICBjbGVhbnVwUnVubmVycy5wdXNoKGhhbmRsZS5ydW5DbGVhbnVwcyk7XG4gICAgaGFuZGxlKCk7XG4gIH0pO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGF0YXMuanNcbnZhciBkYXRhcyA9IHt9O1xuZnVuY3Rpb24gZGF0YShuYW1lLCBjYWxsYmFjaykge1xuICBkYXRhc1tuYW1lXSA9IGNhbGxiYWNrO1xufVxuZnVuY3Rpb24gaW5qZWN0RGF0YVByb3ZpZGVycyhvYmosIGNvbnRleHQpIHtcbiAgT2JqZWN0LmVudHJpZXMoZGF0YXMpLmZvckVhY2goKFtuYW1lLCBjYWxsYmFja10pID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5iaW5kKGNvbnRleHQpKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2JqO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvYWxwaW5lLmpzXG52YXIgQWxwaW5lID0ge1xuICBnZXQgcmVhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlO1xuICB9LFxuICBnZXQgcmVsZWFzZSgpIHtcbiAgICByZXR1cm4gcmVsZWFzZTtcbiAgfSxcbiAgZ2V0IGVmZmVjdCgpIHtcbiAgICByZXR1cm4gZWZmZWN0O1xuICB9LFxuICBnZXQgcmF3KCkge1xuICAgIHJldHVybiByYXc7XG4gIH0sXG4gIHZlcnNpb246IFwiMy4xMi4xXCIsXG4gIGZsdXNoQW5kU3RvcERlZmVycmluZ011dGF0aW9ucyxcbiAgZG9udEF1dG9FdmFsdWF0ZUZ1bmN0aW9ucyxcbiAgZGlzYWJsZUVmZmVjdFNjaGVkdWxpbmcsXG4gIHN0YXJ0T2JzZXJ2aW5nTXV0YXRpb25zLFxuICBzdG9wT2JzZXJ2aW5nTXV0YXRpb25zLFxuICBzZXRSZWFjdGl2aXR5RW5naW5lLFxuICBjbG9zZXN0RGF0YVN0YWNrLFxuICBza2lwRHVyaW5nQ2xvbmUsXG4gIG9ubHlEdXJpbmdDbG9uZSxcbiAgYWRkUm9vdFNlbGVjdG9yLFxuICBhZGRJbml0U2VsZWN0b3IsXG4gIGFkZFNjb3BlVG9Ob2RlLFxuICBkZWZlck11dGF0aW9ucyxcbiAgbWFwQXR0cmlidXRlcyxcbiAgZXZhbHVhdGVMYXRlcixcbiAgaW50ZXJjZXB0SW5pdCxcbiAgc2V0RXZhbHVhdG9yLFxuICBtZXJnZVByb3hpZXMsXG4gIGZpbmRDbG9zZXN0LFxuICBjbG9zZXN0Um9vdCxcbiAgZGVzdHJveVRyZWUsXG4gIGludGVyY2VwdG9yLFxuICAvLyBJTlRFUk5BTDogbm90IHB1YmxpYyBBUEkgYW5kIGlzIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbWFqb3IgcmVsZWFzZS5cbiAgdHJhbnNpdGlvbixcbiAgLy8gSU5URVJOQUxcbiAgc2V0U3R5bGVzLFxuICAvLyBJTlRFUk5BTFxuICBtdXRhdGVEb20sXG4gIGRpcmVjdGl2ZSxcbiAgdGhyb3R0bGUsXG4gIGRlYm91bmNlLFxuICBldmFsdWF0ZSxcbiAgaW5pdFRyZWUsXG4gIG5leHRUaWNrLFxuICBwcmVmaXhlZDogcHJlZml4LFxuICBwcmVmaXg6IHNldFByZWZpeCxcbiAgcGx1Z2luLFxuICBtYWdpYyxcbiAgc3RvcmUsXG4gIHN0YXJ0LFxuICBjbG9uZSxcbiAgYm91bmQ6IGdldEJpbmRpbmcsXG4gICRkYXRhOiBzY29wZSxcbiAgd2FsayxcbiAgZGF0YSxcbiAgYmluZDogYmluZDJcbn07XG52YXIgYWxwaW5lX2RlZmF1bHQgPSBBbHBpbmU7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9pbmRleC5qc1xuaW1wb3J0IHsgcmVhY3RpdmUgYXMgcmVhY3RpdmUyLCBlZmZlY3QgYXMgZWZmZWN0Miwgc3RvcCwgdG9SYXcgfSBmcm9tIFwiQHZ1ZS9yZWFjdGl2aXR5XCI7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJG5leHRUaWNrLmpzXG5tYWdpYyhcIm5leHRUaWNrXCIsICgpID0+IG5leHRUaWNrKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kZGlzcGF0Y2guanNcbm1hZ2ljKFwiZGlzcGF0Y2hcIiwgKGVsKSA9PiBkaXNwYXRjaC5iaW5kKGRpc3BhdGNoLCBlbCkpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzLyR3YXRjaC5qc1xubWFnaWMoXCJ3YXRjaFwiLCAoZWwsIHsgZXZhbHVhdGVMYXRlcjogZXZhbHVhdGVMYXRlcjIsIGVmZmVjdDogZWZmZWN0MyB9KSA9PiAoa2V5LCBjYWxsYmFjaykgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcjIoa2V5KTtcbiAgbGV0IGZpcnN0VGltZSA9IHRydWU7XG4gIGxldCBvbGRWYWx1ZTtcbiAgbGV0IGVmZmVjdFJlZmVyZW5jZSA9IGVmZmVjdDMoKCkgPT4gZXZhbHVhdGUyKCh2YWx1ZSkgPT4ge1xuICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICBpZiAoIWZpcnN0VGltZSkge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBjYWxsYmFjayh2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICBvbGRWYWx1ZSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9sZFZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICB9KSk7XG4gIGVsLl94X2VmZmVjdHMuZGVsZXRlKGVmZmVjdFJlZmVyZW5jZSk7XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kc3RvcmUuanNcbm1hZ2ljKFwic3RvcmVcIiwgZ2V0U3RvcmVzKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kZGF0YS5qc1xubWFnaWMoXCJkYXRhXCIsIChlbCkgPT4gc2NvcGUoZWwpKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kcm9vdC5qc1xubWFnaWMoXCJyb290XCIsIChlbCkgPT4gY2xvc2VzdFJvb3QoZWwpKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kcmVmcy5qc1xubWFnaWMoXCJyZWZzXCIsIChlbCkgPT4ge1xuICBpZiAoZWwuX3hfcmVmc19wcm94eSlcbiAgICByZXR1cm4gZWwuX3hfcmVmc19wcm94eTtcbiAgZWwuX3hfcmVmc19wcm94eSA9IG1lcmdlUHJveGllcyhnZXRBcnJheU9mUmVmT2JqZWN0KGVsKSk7XG4gIHJldHVybiBlbC5feF9yZWZzX3Byb3h5O1xufSk7XG5mdW5jdGlvbiBnZXRBcnJheU9mUmVmT2JqZWN0KGVsKSB7XG4gIGxldCByZWZPYmplY3RzID0gW107XG4gIGxldCBjdXJyZW50RWwgPSBlbDtcbiAgd2hpbGUgKGN1cnJlbnRFbCkge1xuICAgIGlmIChjdXJyZW50RWwuX3hfcmVmcylcbiAgICAgIHJlZk9iamVjdHMucHVzaChjdXJyZW50RWwuX3hfcmVmcyk7XG4gICAgY3VycmVudEVsID0gY3VycmVudEVsLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIHJlZk9iamVjdHM7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9pZHMuanNcbnZhciBnbG9iYWxJZE1lbW8gPSB7fTtcbmZ1bmN0aW9uIGZpbmRBbmRJbmNyZW1lbnRJZChuYW1lKSB7XG4gIGlmICghZ2xvYmFsSWRNZW1vW25hbWVdKVxuICAgIGdsb2JhbElkTWVtb1tuYW1lXSA9IDA7XG4gIHJldHVybiArK2dsb2JhbElkTWVtb1tuYW1lXTtcbn1cbmZ1bmN0aW9uIGNsb3Nlc3RJZFJvb3QoZWwsIG5hbWUpIHtcbiAgcmV0dXJuIGZpbmRDbG9zZXN0KGVsLCAoZWxlbWVudCkgPT4ge1xuICAgIGlmIChlbGVtZW50Ll94X2lkcyAmJiBlbGVtZW50Ll94X2lkc1tuYW1lXSlcbiAgICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNldElkUm9vdChlbCwgbmFtZSkge1xuICBpZiAoIWVsLl94X2lkcylcbiAgICBlbC5feF9pZHMgPSB7fTtcbiAgaWYgKCFlbC5feF9pZHNbbmFtZV0pXG4gICAgZWwuX3hfaWRzW25hbWVdID0gZmluZEFuZEluY3JlbWVudElkKG5hbWUpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzLyRpZC5qc1xubWFnaWMoXCJpZFwiLCAoZWwpID0+IChuYW1lLCBrZXkgPSBudWxsKSA9PiB7XG4gIGxldCByb290ID0gY2xvc2VzdElkUm9vdChlbCwgbmFtZSk7XG4gIGxldCBpZCA9IHJvb3QgPyByb290Ll94X2lkc1tuYW1lXSA6IGZpbmRBbmRJbmNyZW1lbnRJZChuYW1lKTtcbiAgcmV0dXJuIGtleSA/IGAke25hbWV9LSR7aWR9LSR7a2V5fWAgOiBgJHtuYW1lfS0ke2lkfWA7XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kZWwuanNcbm1hZ2ljKFwiZWxcIiwgKGVsKSA9PiBlbCk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvaW5kZXguanNcbndhcm5NaXNzaW5nUGx1Z2luTWFnaWMoXCJGb2N1c1wiLCBcImZvY3VzXCIsIFwiZm9jdXNcIik7XG53YXJuTWlzc2luZ1BsdWdpbk1hZ2ljKFwiUGVyc2lzdFwiLCBcInBlcnNpc3RcIiwgXCJwZXJzaXN0XCIpO1xuZnVuY3Rpb24gd2Fybk1pc3NpbmdQbHVnaW5NYWdpYyhuYW1lLCBtYWdpY05hbWUsIHNsdWcpIHtcbiAgbWFnaWMobWFnaWNOYW1lLCAoZWwpID0+IHdhcm4oYFlvdSBjYW4ndCB1c2UgWyQke2RpcmVjdGl2ZU5hbWV9XSB3aXRob3V0IGZpcnN0IGluc3RhbGxpbmcgdGhlIFwiJHtuYW1lfVwiIHBsdWdpbiBoZXJlOiBodHRwczovL2FscGluZWpzLmRldi9wbHVnaW5zLyR7c2x1Z31gLCBlbCkpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZW50YW5nbGUuanNcbmZ1bmN0aW9uIGVudGFuZ2xlKHsgZ2V0OiBvdXRlckdldCwgc2V0OiBvdXRlclNldCB9LCB7IGdldDogaW5uZXJHZXQsIHNldDogaW5uZXJTZXQgfSkge1xuICBsZXQgZmlyc3RSdW4gPSB0cnVlO1xuICBsZXQgb3V0ZXJIYXNoLCBpbm5lckhhc2gsIG91dGVySGFzaExhdGVzdCwgaW5uZXJIYXNoTGF0ZXN0O1xuICBsZXQgcmVmZXJlbmNlID0gZWZmZWN0KCgpID0+IHtcbiAgICBsZXQgb3V0ZXIsIGlubmVyO1xuICAgIGlmIChmaXJzdFJ1bikge1xuICAgICAgb3V0ZXIgPSBvdXRlckdldCgpO1xuICAgICAgaW5uZXJTZXQob3V0ZXIpO1xuICAgICAgaW5uZXIgPSBpbm5lckdldCgpO1xuICAgICAgZmlyc3RSdW4gPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ZXIgPSBvdXRlckdldCgpO1xuICAgICAgaW5uZXIgPSBpbm5lckdldCgpO1xuICAgICAgb3V0ZXJIYXNoTGF0ZXN0ID0gSlNPTi5zdHJpbmdpZnkob3V0ZXIpO1xuICAgICAgaW5uZXJIYXNoTGF0ZXN0ID0gSlNPTi5zdHJpbmdpZnkoaW5uZXIpO1xuICAgICAgaWYgKG91dGVySGFzaExhdGVzdCAhPT0gb3V0ZXJIYXNoKSB7XG4gICAgICAgIGlubmVyID0gaW5uZXJHZXQoKTtcbiAgICAgICAgaW5uZXJTZXQob3V0ZXIpO1xuICAgICAgICBpbm5lciA9IG91dGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ZXJTZXQoaW5uZXIpO1xuICAgICAgICBvdXRlciA9IGlubmVyO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXRlckhhc2ggPSBKU09OLnN0cmluZ2lmeShvdXRlcik7XG4gICAgaW5uZXJIYXNoID0gSlNPTi5zdHJpbmdpZnkoaW5uZXIpO1xuICB9KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZWxlYXNlKHJlZmVyZW5jZSk7XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtbW9kZWxhYmxlLmpzXG5kaXJlY3RpdmUoXCJtb2RlbGFibGVcIiwgKGVsLCB7IGV4cHJlc3Npb24gfSwgeyBlZmZlY3Q6IGVmZmVjdDMsIGV2YWx1YXRlTGF0ZXI6IGV2YWx1YXRlTGF0ZXIyLCBjbGVhbnVwIH0pID0+IHtcbiAgbGV0IGZ1bmMgPSBldmFsdWF0ZUxhdGVyMihleHByZXNzaW9uKTtcbiAgbGV0IGlubmVyR2V0ID0gKCkgPT4ge1xuICAgIGxldCByZXN1bHQ7XG4gICAgZnVuYygoaSkgPT4gcmVzdWx0ID0gaSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbGV0IGV2YWx1YXRlSW5uZXJTZXQgPSBldmFsdWF0ZUxhdGVyMihgJHtleHByZXNzaW9ufSA9IF9fcGxhY2Vob2xkZXJgKTtcbiAgbGV0IGlubmVyU2V0ID0gKHZhbCkgPT4gZXZhbHVhdGVJbm5lclNldCgoKSA9PiB7XG4gIH0sIHsgc2NvcGU6IHsgXCJfX3BsYWNlaG9sZGVyXCI6IHZhbCB9IH0pO1xuICBsZXQgaW5pdGlhbFZhbHVlID0gaW5uZXJHZXQoKTtcbiAgaW5uZXJTZXQoaW5pdGlhbFZhbHVlKTtcbiAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgIGlmICghZWwuX3hfbW9kZWwpXG4gICAgICByZXR1cm47XG4gICAgZWwuX3hfcmVtb3ZlTW9kZWxMaXN0ZW5lcnNbXCJkZWZhdWx0XCJdKCk7XG4gICAgbGV0IG91dGVyR2V0ID0gZWwuX3hfbW9kZWwuZ2V0O1xuICAgIGxldCBvdXRlclNldCA9IGVsLl94X21vZGVsLnNldDtcbiAgICBsZXQgcmVsZWFzZUVudGFuZ2xlbWVudCA9IGVudGFuZ2xlKFxuICAgICAge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyR2V0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIG91dGVyU2V0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBpbm5lckdldCgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICBpbm5lclNldCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIGNsZWFudXAocmVsZWFzZUVudGFuZ2xlbWVudCk7XG4gIH0pO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtdGVsZXBvcnQuanNcbnZhciB0ZWxlcG9ydENvbnRhaW5lckR1cmluZ0Nsb25lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbmRpcmVjdGl2ZShcInRlbGVwb3J0XCIsIChlbCwgeyBtb2RpZmllcnMsIGV4cHJlc3Npb24gfSwgeyBjbGVhbnVwIH0pID0+IHtcbiAgaWYgKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJ0ZW1wbGF0ZVwiKVxuICAgIHdhcm4oXCJ4LXRlbGVwb3J0IGNhbiBvbmx5IGJlIHVzZWQgb24gYSA8dGVtcGxhdGU+IHRhZ1wiLCBlbCk7XG4gIGxldCB0YXJnZXQgPSBza2lwRHVyaW5nQ2xvbmUoKCkgPT4ge1xuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGV4cHJlc3Npb24pO1xuICB9LCAoKSA9PiB7XG4gICAgcmV0dXJuIHRlbGVwb3J0Q29udGFpbmVyRHVyaW5nQ2xvbmU7XG4gIH0pKCk7XG4gIGlmICghdGFyZ2V0KVxuICAgIHdhcm4oYENhbm5vdCBmaW5kIHgtdGVsZXBvcnQgZWxlbWVudCBmb3Igc2VsZWN0b3I6IFwiJHtleHByZXNzaW9ufVwiYCk7XG4gIGxldCBjbG9uZTIgPSBlbC5jb250ZW50LmNsb25lTm9kZSh0cnVlKS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgZWwuX3hfdGVsZXBvcnQgPSBjbG9uZTI7XG4gIGNsb25lMi5feF90ZWxlcG9ydEJhY2sgPSBlbDtcbiAgaWYgKGVsLl94X2ZvcndhcmRFdmVudHMpIHtcbiAgICBlbC5feF9mb3J3YXJkRXZlbnRzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgY2xvbmUyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCAoZSkgPT4ge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBlLmNvbnN0cnVjdG9yKGUudHlwZSwgZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYWRkU2NvcGVUb05vZGUoY2xvbmUyLCB7fSwgZWwpO1xuICBtdXRhdGVEb20oKCkgPT4ge1xuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJwcmVwZW5kXCIpKSB7XG4gICAgICB0YXJnZXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2xvbmUyLCB0YXJnZXQpO1xuICAgIH0gZWxzZSBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiYXBwZW5kXCIpKSB7XG4gICAgICB0YXJnZXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2xvbmUyLCB0YXJnZXQubmV4dFNpYmxpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoY2xvbmUyKTtcbiAgICB9XG4gICAgaW5pdFRyZWUoY2xvbmUyKTtcbiAgICBjbG9uZTIuX3hfaWdub3JlID0gdHJ1ZTtcbiAgfSk7XG4gIGNsZWFudXAoKCkgPT4gY2xvbmUyLnJlbW92ZSgpKTtcbn0pO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWlnbm9yZS5qc1xudmFyIGhhbmRsZXIgPSAoKSA9PiB7XG59O1xuaGFuZGxlci5pbmxpbmUgPSAoZWwsIHsgbW9kaWZpZXJzIH0sIHsgY2xlYW51cCB9KSA9PiB7XG4gIG1vZGlmaWVycy5pbmNsdWRlcyhcInNlbGZcIikgPyBlbC5feF9pZ25vcmVTZWxmID0gdHJ1ZSA6IGVsLl94X2lnbm9yZSA9IHRydWU7XG4gIGNsZWFudXAoKCkgPT4ge1xuICAgIG1vZGlmaWVycy5pbmNsdWRlcyhcInNlbGZcIikgPyBkZWxldGUgZWwuX3hfaWdub3JlU2VsZiA6IGRlbGV0ZSBlbC5feF9pZ25vcmU7XG4gIH0pO1xufTtcbmRpcmVjdGl2ZShcImlnbm9yZVwiLCBoYW5kbGVyKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1lZmZlY3QuanNcbmRpcmVjdGl2ZShcImVmZmVjdFwiLCAoZWwsIHsgZXhwcmVzc2lvbiB9LCB7IGVmZmVjdDogZWZmZWN0MyB9KSA9PiBlZmZlY3QzKGV2YWx1YXRlTGF0ZXIoZWwsIGV4cHJlc3Npb24pKSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9vbi5qc1xuZnVuY3Rpb24gb24oZWwsIGV2ZW50LCBtb2RpZmllcnMsIGNhbGxiYWNrKSB7XG4gIGxldCBsaXN0ZW5lclRhcmdldCA9IGVsO1xuICBsZXQgaGFuZGxlcjMgPSAoZSkgPT4gY2FsbGJhY2soZSk7XG4gIGxldCBvcHRpb25zID0ge307XG4gIGxldCB3cmFwSGFuZGxlciA9IChjYWxsYmFjazIsIHdyYXBwZXIpID0+IChlKSA9PiB3cmFwcGVyKGNhbGxiYWNrMiwgZSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJkb3RcIikpXG4gICAgZXZlbnQgPSBkb3RTeW50YXgoZXZlbnQpO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiY2FtZWxcIikpXG4gICAgZXZlbnQgPSBjYW1lbENhc2UyKGV2ZW50KTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInBhc3NpdmVcIikpXG4gICAgb3B0aW9ucy5wYXNzaXZlID0gdHJ1ZTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcImNhcHR1cmVcIikpXG4gICAgb3B0aW9ucy5jYXB0dXJlID0gdHJ1ZTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcIndpbmRvd1wiKSlcbiAgICBsaXN0ZW5lclRhcmdldCA9IHdpbmRvdztcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcImRvY3VtZW50XCIpKVxuICAgIGxpc3RlbmVyVGFyZ2V0ID0gZG9jdW1lbnQ7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJkZWJvdW5jZVwiKSkge1xuICAgIGxldCBuZXh0TW9kaWZpZXIgPSBtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2YoXCJkZWJvdW5jZVwiKSArIDFdIHx8IFwiaW52YWxpZC13YWl0XCI7XG4gICAgbGV0IHdhaXQgPSBpc051bWVyaWMobmV4dE1vZGlmaWVyLnNwbGl0KFwibXNcIilbMF0pID8gTnVtYmVyKG5leHRNb2RpZmllci5zcGxpdChcIm1zXCIpWzBdKSA6IDI1MDtcbiAgICBoYW5kbGVyMyA9IGRlYm91bmNlKGhhbmRsZXIzLCB3YWl0KTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwidGhyb3R0bGVcIikpIHtcbiAgICBsZXQgbmV4dE1vZGlmaWVyID0gbW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKFwidGhyb3R0bGVcIikgKyAxXSB8fCBcImludmFsaWQtd2FpdFwiO1xuICAgIGxldCB3YWl0ID0gaXNOdW1lcmljKG5leHRNb2RpZmllci5zcGxpdChcIm1zXCIpWzBdKSA/IE51bWJlcihuZXh0TW9kaWZpZXIuc3BsaXQoXCJtc1wiKVswXSkgOiAyNTA7XG4gICAgaGFuZGxlcjMgPSB0aHJvdHRsZShoYW5kbGVyMywgd2FpdCk7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInByZXZlbnRcIikpXG4gICAgaGFuZGxlcjMgPSB3cmFwSGFuZGxlcihoYW5kbGVyMywgKG5leHQsIGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG5leHQoZSk7XG4gICAgfSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJzdG9wXCIpKVxuICAgIGhhbmRsZXIzID0gd3JhcEhhbmRsZXIoaGFuZGxlcjMsIChuZXh0LCBlKSA9PiB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgbmV4dChlKTtcbiAgICB9KTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInNlbGZcIikpXG4gICAgaGFuZGxlcjMgPSB3cmFwSGFuZGxlcihoYW5kbGVyMywgKG5leHQsIGUpID0+IHtcbiAgICAgIGUudGFyZ2V0ID09PSBlbCAmJiBuZXh0KGUpO1xuICAgIH0pO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiYXdheVwiKSB8fCBtb2RpZmllcnMuaW5jbHVkZXMoXCJvdXRzaWRlXCIpKSB7XG4gICAgbGlzdGVuZXJUYXJnZXQgPSBkb2N1bWVudDtcbiAgICBoYW5kbGVyMyA9IHdyYXBIYW5kbGVyKGhhbmRsZXIzLCAobmV4dCwgZSkgPT4ge1xuICAgICAgaWYgKGVsLmNvbnRhaW5zKGUudGFyZ2V0KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGUudGFyZ2V0LmlzQ29ubmVjdGVkID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGVsLm9mZnNldFdpZHRoIDwgMSAmJiBlbC5vZmZzZXRIZWlnaHQgPCAxKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoZWwuX3hfaXNTaG93biA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIG5leHQoZSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcIm9uY2VcIikpIHtcbiAgICBoYW5kbGVyMyA9IHdyYXBIYW5kbGVyKGhhbmRsZXIzLCAobmV4dCwgZSkgPT4ge1xuICAgICAgbmV4dChlKTtcbiAgICAgIGxpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIzLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVyMyA9IHdyYXBIYW5kbGVyKGhhbmRsZXIzLCAobmV4dCwgZSkgPT4ge1xuICAgIGlmIChpc0tleUV2ZW50KGV2ZW50KSkge1xuICAgICAgaWYgKGlzTGlzdGVuaW5nRm9yQVNwZWNpZmljS2V5VGhhdEhhc250QmVlblByZXNzZWQoZSwgbW9kaWZpZXJzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG5leHQoZSk7XG4gIH0pO1xuICBsaXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyMywgb3B0aW9ucyk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcjMsIG9wdGlvbnMpO1xuICB9O1xufVxuZnVuY3Rpb24gZG90U3ludGF4KHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QucmVwbGFjZSgvLS9nLCBcIi5cIik7XG59XG5mdW5jdGlvbiBjYW1lbENhc2UyKHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKFxcdykvZywgKG1hdGNoLCBjaGFyKSA9PiBjaGFyLnRvVXBwZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gaXNOdW1lcmljKHN1YmplY3QpIHtcbiAgcmV0dXJuICFBcnJheS5pc0FycmF5KHN1YmplY3QpICYmICFpc05hTihzdWJqZWN0KTtcbn1cbmZ1bmN0aW9uIGtlYmFiQ2FzZTIoc3ViamVjdCkge1xuICBpZiAoW1wiIFwiLCBcIl9cIl0uaW5jbHVkZXMoXG4gICAgc3ViamVjdFxuICApKVxuICAgIHJldHVybiBzdWJqZWN0O1xuICByZXR1cm4gc3ViamVjdC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxLSQyXCIpLnJlcGxhY2UoL1tfXFxzXS8sIFwiLVwiKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gaXNLZXlFdmVudChldmVudCkge1xuICByZXR1cm4gW1wia2V5ZG93blwiLCBcImtleXVwXCJdLmluY2x1ZGVzKGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGlzTGlzdGVuaW5nRm9yQVNwZWNpZmljS2V5VGhhdEhhc250QmVlblByZXNzZWQoZSwgbW9kaWZpZXJzKSB7XG4gIGxldCBrZXlNb2RpZmllcnMgPSBtb2RpZmllcnMuZmlsdGVyKChpKSA9PiB7XG4gICAgcmV0dXJuICFbXCJ3aW5kb3dcIiwgXCJkb2N1bWVudFwiLCBcInByZXZlbnRcIiwgXCJzdG9wXCIsIFwib25jZVwiLCBcImNhcHR1cmVcIl0uaW5jbHVkZXMoaSk7XG4gIH0pO1xuICBpZiAoa2V5TW9kaWZpZXJzLmluY2x1ZGVzKFwiZGVib3VuY2VcIikpIHtcbiAgICBsZXQgZGVib3VuY2VJbmRleCA9IGtleU1vZGlmaWVycy5pbmRleE9mKFwiZGVib3VuY2VcIik7XG4gICAga2V5TW9kaWZpZXJzLnNwbGljZShkZWJvdW5jZUluZGV4LCBpc051bWVyaWMoKGtleU1vZGlmaWVyc1tkZWJvdW5jZUluZGV4ICsgMV0gfHwgXCJpbnZhbGlkLXdhaXRcIikuc3BsaXQoXCJtc1wiKVswXSkgPyAyIDogMSk7XG4gIH1cbiAgaWYgKGtleU1vZGlmaWVycy5pbmNsdWRlcyhcInRocm90dGxlXCIpKSB7XG4gICAgbGV0IGRlYm91bmNlSW5kZXggPSBrZXlNb2RpZmllcnMuaW5kZXhPZihcInRocm90dGxlXCIpO1xuICAgIGtleU1vZGlmaWVycy5zcGxpY2UoZGVib3VuY2VJbmRleCwgaXNOdW1lcmljKChrZXlNb2RpZmllcnNbZGVib3VuY2VJbmRleCArIDFdIHx8IFwiaW52YWxpZC13YWl0XCIpLnNwbGl0KFwibXNcIilbMF0pID8gMiA6IDEpO1xuICB9XG4gIGlmIChrZXlNb2RpZmllcnMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGtleU1vZGlmaWVycy5sZW5ndGggPT09IDEgJiYga2V5VG9Nb2RpZmllcnMoZS5rZXkpLmluY2x1ZGVzKGtleU1vZGlmaWVyc1swXSkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBzeXN0ZW1LZXlNb2RpZmllcnMgPSBbXCJjdHJsXCIsIFwic2hpZnRcIiwgXCJhbHRcIiwgXCJtZXRhXCIsIFwiY21kXCIsIFwic3VwZXJcIl07XG4gIGNvbnN0IHNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzID0gc3lzdGVtS2V5TW9kaWZpZXJzLmZpbHRlcigobW9kaWZpZXIpID0+IGtleU1vZGlmaWVycy5pbmNsdWRlcyhtb2RpZmllcikpO1xuICBrZXlNb2RpZmllcnMgPSBrZXlNb2RpZmllcnMuZmlsdGVyKChpKSA9PiAhc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMuaW5jbHVkZXMoaSkpO1xuICBpZiAoc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGFjdGl2ZWx5UHJlc3NlZEtleU1vZGlmaWVycyA9IHNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzLmZpbHRlcigobW9kaWZpZXIpID0+IHtcbiAgICAgIGlmIChtb2RpZmllciA9PT0gXCJjbWRcIiB8fCBtb2RpZmllciA9PT0gXCJzdXBlclwiKVxuICAgICAgICBtb2RpZmllciA9IFwibWV0YVwiO1xuICAgICAgcmV0dXJuIGVbYCR7bW9kaWZpZXJ9S2V5YF07XG4gICAgfSk7XG4gICAgaWYgKGFjdGl2ZWx5UHJlc3NlZEtleU1vZGlmaWVycy5sZW5ndGggPT09IHNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzLmxlbmd0aCkge1xuICAgICAgaWYgKGtleVRvTW9kaWZpZXJzKGUua2V5KS5pbmNsdWRlcyhrZXlNb2RpZmllcnNbMF0pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24ga2V5VG9Nb2RpZmllcnMoa2V5KSB7XG4gIGlmICgha2V5KVxuICAgIHJldHVybiBbXTtcbiAga2V5ID0ga2ViYWJDYXNlMihrZXkpO1xuICBsZXQgbW9kaWZpZXJUb0tleU1hcCA9IHtcbiAgICBcImN0cmxcIjogXCJjb250cm9sXCIsXG4gICAgXCJzbGFzaFwiOiBcIi9cIixcbiAgICBcInNwYWNlXCI6IFwiIFwiLFxuICAgIFwic3BhY2ViYXJcIjogXCIgXCIsXG4gICAgXCJjbWRcIjogXCJtZXRhXCIsXG4gICAgXCJlc2NcIjogXCJlc2NhcGVcIixcbiAgICBcInVwXCI6IFwiYXJyb3ctdXBcIixcbiAgICBcImRvd25cIjogXCJhcnJvdy1kb3duXCIsXG4gICAgXCJsZWZ0XCI6IFwiYXJyb3ctbGVmdFwiLFxuICAgIFwicmlnaHRcIjogXCJhcnJvdy1yaWdodFwiLFxuICAgIFwicGVyaW9kXCI6IFwiLlwiLFxuICAgIFwiZXF1YWxcIjogXCI9XCIsXG4gICAgXCJtaW51c1wiOiBcIi1cIixcbiAgICBcInVuZGVyc2NvcmVcIjogXCJfXCJcbiAgfTtcbiAgbW9kaWZpZXJUb0tleU1hcFtrZXldID0ga2V5O1xuICByZXR1cm4gT2JqZWN0LmtleXMobW9kaWZpZXJUb0tleU1hcCkubWFwKChtb2RpZmllcikgPT4ge1xuICAgIGlmIChtb2RpZmllclRvS2V5TWFwW21vZGlmaWVyXSA9PT0ga2V5KVxuICAgICAgcmV0dXJuIG1vZGlmaWVyO1xuICB9KS5maWx0ZXIoKG1vZGlmaWVyKSA9PiBtb2RpZmllcik7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtbW9kZWwuanNcbmRpcmVjdGl2ZShcIm1vZGVsXCIsIChlbCwgeyBtb2RpZmllcnMsIGV4cHJlc3Npb24gfSwgeyBlZmZlY3Q6IGVmZmVjdDMsIGNsZWFudXAgfSkgPT4ge1xuICBsZXQgc2NvcGVUYXJnZXQgPSBlbDtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInBhcmVudFwiKSkge1xuICAgIHNjb3BlVGFyZ2V0ID0gZWwucGFyZW50Tm9kZTtcbiAgfVxuICBsZXQgZXZhbHVhdGVHZXQgPSBldmFsdWF0ZUxhdGVyKHNjb3BlVGFyZ2V0LCBleHByZXNzaW9uKTtcbiAgbGV0IGV2YWx1YXRlU2V0O1xuICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICBldmFsdWF0ZVNldCA9IGV2YWx1YXRlTGF0ZXIoc2NvcGVUYXJnZXQsIGAke2V4cHJlc3Npb259ID0gX19wbGFjZWhvbGRlcmApO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGV4cHJlc3Npb24oKSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGV2YWx1YXRlU2V0ID0gZXZhbHVhdGVMYXRlcihzY29wZVRhcmdldCwgYCR7ZXhwcmVzc2lvbigpfSA9IF9fcGxhY2Vob2xkZXJgKTtcbiAgfSBlbHNlIHtcbiAgICBldmFsdWF0ZVNldCA9ICgpID0+IHtcbiAgICB9O1xuICB9XG4gIGxldCBnZXRWYWx1ZSA9ICgpID0+IHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGV2YWx1YXRlR2V0KCh2YWx1ZSkgPT4gcmVzdWx0ID0gdmFsdWUpO1xuICAgIHJldHVybiBpc0dldHRlclNldHRlcihyZXN1bHQpID8gcmVzdWx0LmdldCgpIDogcmVzdWx0O1xuICB9O1xuICBsZXQgc2V0VmFsdWUgPSAodmFsdWUpID0+IHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGV2YWx1YXRlR2V0KCh2YWx1ZTIpID0+IHJlc3VsdCA9IHZhbHVlMik7XG4gICAgaWYgKGlzR2V0dGVyU2V0dGVyKHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdC5zZXQodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmFsdWF0ZVNldCgoKSA9PiB7XG4gICAgICB9LCB7XG4gICAgICAgIHNjb3BlOiB7IFwiX19wbGFjZWhvbGRlclwiOiB2YWx1ZSB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGlmICh0eXBlb2YgZXhwcmVzc2lvbiA9PT0gXCJzdHJpbmdcIiAmJiBlbC50eXBlID09PSBcInJhZGlvXCIpIHtcbiAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgaWYgKCFlbC5oYXNBdHRyaWJ1dGUoXCJuYW1lXCIpKVxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIGV4cHJlc3Npb24pO1xuICAgIH0pO1xuICB9XG4gIHZhciBldmVudCA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzZWxlY3RcIiB8fCBbXCJjaGVja2JveFwiLCBcInJhZGlvXCJdLmluY2x1ZGVzKGVsLnR5cGUpIHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcImxhenlcIikgPyBcImNoYW5nZVwiIDogXCJpbnB1dFwiO1xuICBsZXQgcmVtb3ZlTGlzdGVuZXIgPSBpc0Nsb25pbmcgPyAoKSA9PiB7XG4gIH0gOiBvbihlbCwgZXZlbnQsIG1vZGlmaWVycywgKGUpID0+IHtcbiAgICBzZXRWYWx1ZShnZXRJbnB1dFZhbHVlKGVsLCBtb2RpZmllcnMsIGUsIGdldFZhbHVlKCkpKTtcbiAgfSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJmaWxsXCIpICYmIFtudWxsLCBcIlwiXS5pbmNsdWRlcyhnZXRWYWx1ZSgpKSkge1xuICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KGV2ZW50LCB7fSkpO1xuICB9XG4gIGlmICghZWwuX3hfcmVtb3ZlTW9kZWxMaXN0ZW5lcnMpXG4gICAgZWwuX3hfcmVtb3ZlTW9kZWxMaXN0ZW5lcnMgPSB7fTtcbiAgZWwuX3hfcmVtb3ZlTW9kZWxMaXN0ZW5lcnNbXCJkZWZhdWx0XCJdID0gcmVtb3ZlTGlzdGVuZXI7XG4gIGNsZWFudXAoKCkgPT4gZWwuX3hfcmVtb3ZlTW9kZWxMaXN0ZW5lcnNbXCJkZWZhdWx0XCJdKCkpO1xuICBpZiAoZWwuZm9ybSkge1xuICAgIGxldCByZW1vdmVSZXNldExpc3RlbmVyID0gb24oZWwuZm9ybSwgXCJyZXNldFwiLCBbXSwgKGUpID0+IHtcbiAgICAgIG5leHRUaWNrKCgpID0+IGVsLl94X21vZGVsICYmIGVsLl94X21vZGVsLnNldChlbC52YWx1ZSkpO1xuICAgIH0pO1xuICAgIGNsZWFudXAoKCkgPT4gcmVtb3ZlUmVzZXRMaXN0ZW5lcigpKTtcbiAgfVxuICBlbC5feF9tb2RlbCA9IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gZ2V0VmFsdWUoKTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgc2V0VmFsdWUodmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgZWwuX3hfZm9yY2VNb2RlbFVwZGF0ZSA9ICh2YWx1ZSkgPT4ge1xuICAgIHZhbHVlID0gdmFsdWUgPT09IHZvaWQgMCA/IGdldFZhbHVlKCkgOiB2YWx1ZTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCAmJiB0eXBlb2YgZXhwcmVzc2lvbiA9PT0gXCJzdHJpbmdcIiAmJiBleHByZXNzaW9uLm1hdGNoKC9cXC4vKSlcbiAgICAgIHZhbHVlID0gXCJcIjtcbiAgICB3aW5kb3cuZnJvbU1vZGVsID0gdHJ1ZTtcbiAgICBtdXRhdGVEb20oKCkgPT4gYmluZChlbCwgXCJ2YWx1ZVwiLCB2YWx1ZSkpO1xuICAgIGRlbGV0ZSB3aW5kb3cuZnJvbU1vZGVsO1xuICB9O1xuICBlZmZlY3QzKCgpID0+IHtcbiAgICBsZXQgdmFsdWUgPSBnZXRWYWx1ZSgpO1xuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJ1bmludHJ1c2l2ZVwiKSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmlzU2FtZU5vZGUoZWwpKVxuICAgICAgcmV0dXJuO1xuICAgIGVsLl94X2ZvcmNlTW9kZWxVcGRhdGUodmFsdWUpO1xuICB9KTtcbn0pO1xuZnVuY3Rpb24gZ2V0SW5wdXRWYWx1ZShlbCwgbW9kaWZpZXJzLCBldmVudCwgY3VycmVudFZhbHVlKSB7XG4gIHJldHVybiBtdXRhdGVEb20oKCkgPT4ge1xuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEN1c3RvbUV2ZW50ICYmIGV2ZW50LmRldGFpbCAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIGV2ZW50LmRldGFpbCA/PyBldmVudC50YXJnZXQudmFsdWU7XG4gICAgZWxzZSBpZiAoZWwudHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IG1vZGlmaWVycy5pbmNsdWRlcyhcIm51bWJlclwiKSA/IHNhZmVQYXJzZU51bWJlcihldmVudC50YXJnZXQudmFsdWUpIDogZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0LmNoZWNrZWQgPyBjdXJyZW50VmFsdWUuY29uY2F0KFtuZXdWYWx1ZV0pIDogY3VycmVudFZhbHVlLmZpbHRlcigoZWwyKSA9PiAhY2hlY2tlZEF0dHJMb29zZUNvbXBhcmUyKGVsMiwgbmV3VmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBldmVudC50YXJnZXQuY2hlY2tlZDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzZWxlY3RcIiAmJiBlbC5tdWx0aXBsZSkge1xuICAgICAgcmV0dXJuIG1vZGlmaWVycy5pbmNsdWRlcyhcIm51bWJlclwiKSA/IEFycmF5LmZyb20oZXZlbnQudGFyZ2V0LnNlbGVjdGVkT3B0aW9ucykubWFwKChvcHRpb24pID0+IHtcbiAgICAgICAgbGV0IHJhd1ZhbHVlID0gb3B0aW9uLnZhbHVlIHx8IG9wdGlvbi50ZXh0O1xuICAgICAgICByZXR1cm4gc2FmZVBhcnNlTnVtYmVyKHJhd1ZhbHVlKTtcbiAgICAgIH0pIDogQXJyYXkuZnJvbShldmVudC50YXJnZXQuc2VsZWN0ZWRPcHRpb25zKS5tYXAoKG9wdGlvbikgPT4ge1xuICAgICAgICByZXR1cm4gb3B0aW9uLnZhbHVlIHx8IG9wdGlvbi50ZXh0O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByYXdWYWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgIHJldHVybiBtb2RpZmllcnMuaW5jbHVkZXMoXCJudW1iZXJcIikgPyBzYWZlUGFyc2VOdW1iZXIocmF3VmFsdWUpIDogbW9kaWZpZXJzLmluY2x1ZGVzKFwidHJpbVwiKSA/IHJhd1ZhbHVlLnRyaW0oKSA6IHJhd1ZhbHVlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBzYWZlUGFyc2VOdW1iZXIocmF3VmFsdWUpIHtcbiAgbGV0IG51bWJlciA9IHJhd1ZhbHVlID8gcGFyc2VGbG9hdChyYXdWYWx1ZSkgOiBudWxsO1xuICByZXR1cm4gaXNOdW1lcmljMihudW1iZXIpID8gbnVtYmVyIDogcmF3VmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja2VkQXR0ckxvb3NlQ29tcGFyZTIodmFsdWVBLCB2YWx1ZUIpIHtcbiAgcmV0dXJuIHZhbHVlQSA9PSB2YWx1ZUI7XG59XG5mdW5jdGlvbiBpc051bWVyaWMyKHN1YmplY3QpIHtcbiAgcmV0dXJuICFBcnJheS5pc0FycmF5KHN1YmplY3QpICYmICFpc05hTihzdWJqZWN0KTtcbn1cbmZ1bmN0aW9uIGlzR2V0dGVyU2V0dGVyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLmdldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2YWx1ZS5zZXQgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1jbG9hay5qc1xuZGlyZWN0aXZlKFwiY2xvYWtcIiwgKGVsKSA9PiBxdWV1ZU1pY3JvdGFzaygoKSA9PiBtdXRhdGVEb20oKCkgPT4gZWwucmVtb3ZlQXR0cmlidXRlKHByZWZpeChcImNsb2FrXCIpKSkpKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1pbml0LmpzXG5hZGRJbml0U2VsZWN0b3IoKCkgPT4gYFske3ByZWZpeChcImluaXRcIil9XWApO1xuZGlyZWN0aXZlKFwiaW5pdFwiLCBza2lwRHVyaW5nQ2xvbmUoKGVsLCB7IGV4cHJlc3Npb24gfSwgeyBldmFsdWF0ZTogZXZhbHVhdGUyIH0pID0+IHtcbiAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuICEhZXhwcmVzc2lvbi50cmltKCkgJiYgZXZhbHVhdGUyKGV4cHJlc3Npb24sIHt9LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIGV2YWx1YXRlMihleHByZXNzaW9uLCB7fSwgZmFsc2UpO1xufSkpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LXRleHQuanNcbmRpcmVjdGl2ZShcInRleHRcIiwgKGVsLCB7IGV4cHJlc3Npb24gfSwgeyBlZmZlY3Q6IGVmZmVjdDMsIGV2YWx1YXRlTGF0ZXI6IGV2YWx1YXRlTGF0ZXIyIH0pID0+IHtcbiAgbGV0IGV2YWx1YXRlMiA9IGV2YWx1YXRlTGF0ZXIyKGV4cHJlc3Npb24pO1xuICBlZmZlY3QzKCgpID0+IHtcbiAgICBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgICBlbC50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtaHRtbC5qc1xuZGlyZWN0aXZlKFwiaHRtbFwiLCAoZWwsIHsgZXhwcmVzc2lvbiB9LCB7IGVmZmVjdDogZWZmZWN0MywgZXZhbHVhdGVMYXRlcjogZXZhbHVhdGVMYXRlcjIgfSkgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcjIoZXhwcmVzc2lvbik7XG4gIGVmZmVjdDMoKCkgPT4ge1xuICAgIGV2YWx1YXRlMigodmFsdWUpID0+IHtcbiAgICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICAgIGVsLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICBlbC5feF9pZ25vcmVTZWxmID0gdHJ1ZTtcbiAgICAgICAgaW5pdFRyZWUoZWwpO1xuICAgICAgICBkZWxldGUgZWwuX3hfaWdub3JlU2VsZjtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWJpbmQuanNcbm1hcEF0dHJpYnV0ZXMoc3RhcnRpbmdXaXRoKFwiOlwiLCBpbnRvKHByZWZpeChcImJpbmQ6XCIpKSkpO1xuZGlyZWN0aXZlKFwiYmluZFwiLCAoZWwsIHsgdmFsdWUsIG1vZGlmaWVycywgZXhwcmVzc2lvbiwgb3JpZ2luYWwgfSwgeyBlZmZlY3Q6IGVmZmVjdDMgfSkgPT4ge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgbGV0IGJpbmRpbmdQcm92aWRlcnMgPSB7fTtcbiAgICBpbmplY3RCaW5kaW5nUHJvdmlkZXJzKGJpbmRpbmdQcm92aWRlcnMpO1xuICAgIGxldCBnZXRCaW5kaW5ncyA9IGV2YWx1YXRlTGF0ZXIoZWwsIGV4cHJlc3Npb24pO1xuICAgIGdldEJpbmRpbmdzKChiaW5kaW5ncykgPT4ge1xuICAgICAgYXBwbHlCaW5kaW5nc09iamVjdChlbCwgYmluZGluZ3MsIG9yaWdpbmFsKTtcbiAgICB9LCB7IHNjb3BlOiBiaW5kaW5nUHJvdmlkZXJzIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmFsdWUgPT09IFwia2V5XCIpXG4gICAgcmV0dXJuIHN0b3JlS2V5Rm9yWEZvcihlbCwgZXhwcmVzc2lvbik7XG4gIGxldCBldmFsdWF0ZTIgPSBldmFsdWF0ZUxhdGVyKGVsLCBleHByZXNzaW9uKTtcbiAgZWZmZWN0MygoKSA9PiBldmFsdWF0ZTIoKHJlc3VsdCkgPT4ge1xuICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCAmJiB0eXBlb2YgZXhwcmVzc2lvbiA9PT0gXCJzdHJpbmdcIiAmJiBleHByZXNzaW9uLm1hdGNoKC9cXC4vKSkge1xuICAgICAgcmVzdWx0ID0gXCJcIjtcbiAgICB9XG4gICAgbXV0YXRlRG9tKCgpID0+IGJpbmQoZWwsIHZhbHVlLCByZXN1bHQsIG1vZGlmaWVycykpO1xuICB9KSk7XG59KTtcbmZ1bmN0aW9uIHN0b3JlS2V5Rm9yWEZvcihlbCwgZXhwcmVzc2lvbikge1xuICBlbC5feF9rZXlFeHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1kYXRhLmpzXG5hZGRSb290U2VsZWN0b3IoKCkgPT4gYFske3ByZWZpeChcImRhdGFcIil9XWApO1xuZGlyZWN0aXZlKFwiZGF0YVwiLCBza2lwRHVyaW5nQ2xvbmUoKGVsLCB7IGV4cHJlc3Npb24gfSwgeyBjbGVhbnVwIH0pID0+IHtcbiAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24gPT09IFwiXCIgPyBcInt9XCIgOiBleHByZXNzaW9uO1xuICBsZXQgbWFnaWNDb250ZXh0ID0ge307XG4gIGluamVjdE1hZ2ljcyhtYWdpY0NvbnRleHQsIGVsKTtcbiAgbGV0IGRhdGFQcm92aWRlckNvbnRleHQgPSB7fTtcbiAgaW5qZWN0RGF0YVByb3ZpZGVycyhkYXRhUHJvdmlkZXJDb250ZXh0LCBtYWdpY0NvbnRleHQpO1xuICBsZXQgZGF0YTIgPSBldmFsdWF0ZShlbCwgZXhwcmVzc2lvbiwgeyBzY29wZTogZGF0YVByb3ZpZGVyQ29udGV4dCB9KTtcbiAgaWYgKGRhdGEyID09PSB2b2lkIDAgfHwgZGF0YTIgPT09IHRydWUpXG4gICAgZGF0YTIgPSB7fTtcbiAgaW5qZWN0TWFnaWNzKGRhdGEyLCBlbCk7XG4gIGxldCByZWFjdGl2ZURhdGEgPSByZWFjdGl2ZShkYXRhMik7XG4gIGluaXRJbnRlcmNlcHRvcnMocmVhY3RpdmVEYXRhKTtcbiAgbGV0IHVuZG8gPSBhZGRTY29wZVRvTm9kZShlbCwgcmVhY3RpdmVEYXRhKTtcbiAgcmVhY3RpdmVEYXRhW1wiaW5pdFwiXSAmJiBldmFsdWF0ZShlbCwgcmVhY3RpdmVEYXRhW1wiaW5pdFwiXSk7XG4gIGNsZWFudXAoKCkgPT4ge1xuICAgIHJlYWN0aXZlRGF0YVtcImRlc3Ryb3lcIl0gJiYgZXZhbHVhdGUoZWwsIHJlYWN0aXZlRGF0YVtcImRlc3Ryb3lcIl0pO1xuICAgIHVuZG8oKTtcbiAgfSk7XG59KSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtc2hvdy5qc1xuZGlyZWN0aXZlKFwic2hvd1wiLCAoZWwsIHsgbW9kaWZpZXJzLCBleHByZXNzaW9uIH0sIHsgZWZmZWN0OiBlZmZlY3QzIH0pID0+IHtcbiAgbGV0IGV2YWx1YXRlMiA9IGV2YWx1YXRlTGF0ZXIoZWwsIGV4cHJlc3Npb24pO1xuICBpZiAoIWVsLl94X2RvSGlkZSlcbiAgICBlbC5feF9kb0hpZGUgPSAoKSA9PiB7XG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIiwgXCJub25lXCIsIG1vZGlmaWVycy5pbmNsdWRlcyhcImltcG9ydGFudFwiKSA/IFwiaW1wb3J0YW50XCIgOiB2b2lkIDApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgaWYgKCFlbC5feF9kb1Nob3cpXG4gICAgZWwuX3hfZG9TaG93ID0gKCkgPT4ge1xuICAgICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgICAgaWYgKGVsLnN0eWxlLmxlbmd0aCA9PT0gMSAmJiBlbC5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgbGV0IGhpZGUgPSAoKSA9PiB7XG4gICAgZWwuX3hfZG9IaWRlKCk7XG4gICAgZWwuX3hfaXNTaG93biA9IGZhbHNlO1xuICB9O1xuICBsZXQgc2hvdyA9ICgpID0+IHtcbiAgICBlbC5feF9kb1Nob3coKTtcbiAgICBlbC5feF9pc1Nob3duID0gdHJ1ZTtcbiAgfTtcbiAgbGV0IGNsaWNrQXdheUNvbXBhdGlibGVTaG93ID0gKCkgPT4gc2V0VGltZW91dChzaG93KTtcbiAgbGV0IHRvZ2dsZSA9IG9uY2UoXG4gICAgKHZhbHVlKSA9PiB2YWx1ZSA/IHNob3coKSA6IGhpZGUoKSxcbiAgICAodmFsdWUpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZWwuX3hfdG9nZ2xlQW5kQ2FzY2FkZVdpdGhUcmFuc2l0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGVsLl94X3RvZ2dsZUFuZENhc2NhZGVXaXRoVHJhbnNpdGlvbnMoZWwsIHZhbHVlLCBzaG93LCBoaWRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID8gY2xpY2tBd2F5Q29tcGF0aWJsZVNob3coKSA6IGhpZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIGxldCBvbGRWYWx1ZTtcbiAgbGV0IGZpcnN0VGltZSA9IHRydWU7XG4gIGVmZmVjdDMoKCkgPT4gZXZhbHVhdGUyKCh2YWx1ZSkgPT4ge1xuICAgIGlmICghZmlyc3RUaW1lICYmIHZhbHVlID09PSBvbGRWYWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiaW1tZWRpYXRlXCIpKVxuICAgICAgdmFsdWUgPyBjbGlja0F3YXlDb21wYXRpYmxlU2hvdygpIDogaGlkZSgpO1xuICAgIHRvZ2dsZSh2YWx1ZSk7XG4gICAgb2xkVmFsdWUgPSB2YWx1ZTtcbiAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgfSkpO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtZm9yLmpzXG5kaXJlY3RpdmUoXCJmb3JcIiwgKGVsLCB7IGV4cHJlc3Npb24gfSwgeyBlZmZlY3Q6IGVmZmVjdDMsIGNsZWFudXAgfSkgPT4ge1xuICBsZXQgaXRlcmF0b3JOYW1lcyA9IHBhcnNlRm9yRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgbGV0IGV2YWx1YXRlSXRlbXMgPSBldmFsdWF0ZUxhdGVyKGVsLCBpdGVyYXRvck5hbWVzLml0ZW1zKTtcbiAgbGV0IGV2YWx1YXRlS2V5ID0gZXZhbHVhdGVMYXRlcihcbiAgICBlbCxcbiAgICAvLyB0aGUgeC1iaW5kOmtleSBleHByZXNzaW9uIGlzIHN0b3JlZCBmb3Igb3VyIHVzZSBpbnN0ZWFkIG9mIGV2YWx1YXRlZC5cbiAgICBlbC5feF9rZXlFeHByZXNzaW9uIHx8IFwiaW5kZXhcIlxuICApO1xuICBlbC5feF9wcmV2S2V5cyA9IFtdO1xuICBlbC5feF9sb29rdXAgPSB7fTtcbiAgZWZmZWN0MygoKSA9PiBsb29wKGVsLCBpdGVyYXRvck5hbWVzLCBldmFsdWF0ZUl0ZW1zLCBldmFsdWF0ZUtleSkpO1xuICBjbGVhbnVwKCgpID0+IHtcbiAgICBPYmplY3QudmFsdWVzKGVsLl94X2xvb2t1cCkuZm9yRWFjaCgoZWwyKSA9PiBlbDIucmVtb3ZlKCkpO1xuICAgIGRlbGV0ZSBlbC5feF9wcmV2S2V5cztcbiAgICBkZWxldGUgZWwuX3hfbG9va3VwO1xuICB9KTtcbn0pO1xuZnVuY3Rpb24gbG9vcChlbCwgaXRlcmF0b3JOYW1lcywgZXZhbHVhdGVJdGVtcywgZXZhbHVhdGVLZXkpIHtcbiAgbGV0IGlzT2JqZWN0ID0gKGkpID0+IHR5cGVvZiBpID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGkpO1xuICBsZXQgdGVtcGxhdGVFbCA9IGVsO1xuICBldmFsdWF0ZUl0ZW1zKChpdGVtcykgPT4ge1xuICAgIGlmIChpc051bWVyaWMzKGl0ZW1zKSAmJiBpdGVtcyA+PSAwKSB7XG4gICAgICBpdGVtcyA9IEFycmF5LmZyb20oQXJyYXkoaXRlbXMpLmtleXMoKSwgKGkpID0+IGkgKyAxKTtcbiAgICB9XG4gICAgaWYgKGl0ZW1zID09PSB2b2lkIDApXG4gICAgICBpdGVtcyA9IFtdO1xuICAgIGxldCBsb29rdXAgPSBlbC5feF9sb29rdXA7XG4gICAgbGV0IHByZXZLZXlzID0gZWwuX3hfcHJldktleXM7XG4gICAgbGV0IHNjb3BlcyA9IFtdO1xuICAgIGxldCBrZXlzID0gW107XG4gICAgaWYgKGlzT2JqZWN0KGl0ZW1zKSkge1xuICAgICAgaXRlbXMgPSBPYmplY3QuZW50cmllcyhpdGVtcykubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgbGV0IHNjb3BlMiA9IGdldEl0ZXJhdGlvblNjb3BlVmFyaWFibGVzKGl0ZXJhdG9yTmFtZXMsIHZhbHVlLCBrZXksIGl0ZW1zKTtcbiAgICAgICAgZXZhbHVhdGVLZXkoKHZhbHVlMikgPT4ga2V5cy5wdXNoKHZhbHVlMiksIHsgc2NvcGU6IHsgaW5kZXg6IGtleSwgLi4uc2NvcGUyIH0gfSk7XG4gICAgICAgIHNjb3Blcy5wdXNoKHNjb3BlMik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc2NvcGUyID0gZ2V0SXRlcmF0aW9uU2NvcGVWYXJpYWJsZXMoaXRlcmF0b3JOYW1lcywgaXRlbXNbaV0sIGksIGl0ZW1zKTtcbiAgICAgICAgZXZhbHVhdGVLZXkoKHZhbHVlKSA9PiBrZXlzLnB1c2godmFsdWUpLCB7IHNjb3BlOiB7IGluZGV4OiBpLCAuLi5zY29wZTIgfSB9KTtcbiAgICAgICAgc2NvcGVzLnB1c2goc2NvcGUyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGFkZHMgPSBbXTtcbiAgICBsZXQgbW92ZXMgPSBbXTtcbiAgICBsZXQgcmVtb3ZlcyA9IFtdO1xuICAgIGxldCBzYW1lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBrZXkgPSBwcmV2S2V5c1tpXTtcbiAgICAgIGlmIChrZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpXG4gICAgICAgIHJlbW92ZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBwcmV2S2V5cyA9IHByZXZLZXlzLmZpbHRlcigoa2V5KSA9PiAhcmVtb3Zlcy5pbmNsdWRlcyhrZXkpKTtcbiAgICBsZXQgbGFzdEtleSA9IFwidGVtcGxhdGVcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBrZXkgPSBrZXlzW2ldO1xuICAgICAgbGV0IHByZXZJbmRleCA9IHByZXZLZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgIGlmIChwcmV2SW5kZXggPT09IC0xKSB7XG4gICAgICAgIHByZXZLZXlzLnNwbGljZShpLCAwLCBrZXkpO1xuICAgICAgICBhZGRzLnB1c2goW2xhc3RLZXksIGldKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldkluZGV4ICE9PSBpKSB7XG4gICAgICAgIGxldCBrZXlJblNwb3QgPSBwcmV2S2V5cy5zcGxpY2UoaSwgMSlbMF07XG4gICAgICAgIGxldCBrZXlGb3JTcG90ID0gcHJldktleXMuc3BsaWNlKHByZXZJbmRleCAtIDEsIDEpWzBdO1xuICAgICAgICBwcmV2S2V5cy5zcGxpY2UoaSwgMCwga2V5Rm9yU3BvdCk7XG4gICAgICAgIHByZXZLZXlzLnNwbGljZShwcmV2SW5kZXgsIDAsIGtleUluU3BvdCk7XG4gICAgICAgIG1vdmVzLnB1c2goW2tleUluU3BvdCwga2V5Rm9yU3BvdF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2FtZXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgICAgbGFzdEtleSA9IGtleTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQga2V5ID0gcmVtb3Zlc1tpXTtcbiAgICAgIGlmICghIWxvb2t1cFtrZXldLl94X2VmZmVjdHMpIHtcbiAgICAgICAgbG9va3VwW2tleV0uX3hfZWZmZWN0cy5mb3JFYWNoKGRlcXVldWVKb2IpO1xuICAgICAgfVxuICAgICAgbG9va3VwW2tleV0ucmVtb3ZlKCk7XG4gICAgICBsb29rdXBba2V5XSA9IG51bGw7XG4gICAgICBkZWxldGUgbG9va3VwW2tleV07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW92ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBba2V5SW5TcG90LCBrZXlGb3JTcG90XSA9IG1vdmVzW2ldO1xuICAgICAgbGV0IGVsSW5TcG90ID0gbG9va3VwW2tleUluU3BvdF07XG4gICAgICBsZXQgZWxGb3JTcG90ID0gbG9va3VwW2tleUZvclNwb3RdO1xuICAgICAgbGV0IG1hcmtlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgICBpZiAoIWVsRm9yU3BvdClcbiAgICAgICAgICB3YXJuKGB4LWZvciBcIjprZXlcIiBpcyB1bmRlZmluZWQgb3IgaW52YWxpZGAsIHRlbXBsYXRlRWwpO1xuICAgICAgICBlbEZvclNwb3QuYWZ0ZXIobWFya2VyKTtcbiAgICAgICAgZWxJblNwb3QuYWZ0ZXIoZWxGb3JTcG90KTtcbiAgICAgICAgZWxGb3JTcG90Ll94X2N1cnJlbnRJZkVsICYmIGVsRm9yU3BvdC5hZnRlcihlbEZvclNwb3QuX3hfY3VycmVudElmRWwpO1xuICAgICAgICBtYXJrZXIuYmVmb3JlKGVsSW5TcG90KTtcbiAgICAgICAgZWxJblNwb3QuX3hfY3VycmVudElmRWwgJiYgZWxJblNwb3QuYWZ0ZXIoZWxJblNwb3QuX3hfY3VycmVudElmRWwpO1xuICAgICAgICBtYXJrZXIucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICAgIGVsRm9yU3BvdC5feF9yZWZyZXNoWEZvclNjb3BlKHNjb3Blc1trZXlzLmluZGV4T2Yoa2V5Rm9yU3BvdCldKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgW2xhc3RLZXkyLCBpbmRleF0gPSBhZGRzW2ldO1xuICAgICAgbGV0IGxhc3RFbCA9IGxhc3RLZXkyID09PSBcInRlbXBsYXRlXCIgPyB0ZW1wbGF0ZUVsIDogbG9va3VwW2xhc3RLZXkyXTtcbiAgICAgIGlmIChsYXN0RWwuX3hfY3VycmVudElmRWwpXG4gICAgICAgIGxhc3RFbCA9IGxhc3RFbC5feF9jdXJyZW50SWZFbDtcbiAgICAgIGxldCBzY29wZTIgPSBzY29wZXNbaW5kZXhdO1xuICAgICAgbGV0IGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgbGV0IGNsb25lMiA9IGRvY3VtZW50LmltcG9ydE5vZGUodGVtcGxhdGVFbC5jb250ZW50LCB0cnVlKS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgIGxldCByZWFjdGl2ZVNjb3BlID0gcmVhY3RpdmUoc2NvcGUyKTtcbiAgICAgIGFkZFNjb3BlVG9Ob2RlKGNsb25lMiwgcmVhY3RpdmVTY29wZSwgdGVtcGxhdGVFbCk7XG4gICAgICBjbG9uZTIuX3hfcmVmcmVzaFhGb3JTY29wZSA9IChuZXdTY29wZSkgPT4ge1xuICAgICAgICBPYmplY3QuZW50cmllcyhuZXdTY29wZSkuZm9yRWFjaCgoW2tleTIsIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIHJlYWN0aXZlU2NvcGVba2V5Ml0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgICAgbGFzdEVsLmFmdGVyKGNsb25lMik7XG4gICAgICAgIGluaXRUcmVlKGNsb25lMik7XG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHdhcm4oXCJ4LWZvciBrZXkgY2Fubm90IGJlIGFuIG9iamVjdCwgaXQgbXVzdCBiZSBhIHN0cmluZyBvciBhbiBpbnRlZ2VyXCIsIHRlbXBsYXRlRWwpO1xuICAgICAgfVxuICAgICAgbG9va3VwW2tleV0gPSBjbG9uZTI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxvb2t1cFtzYW1lc1tpXV0uX3hfcmVmcmVzaFhGb3JTY29wZShzY29wZXNba2V5cy5pbmRleE9mKHNhbWVzW2ldKV0pO1xuICAgIH1cbiAgICB0ZW1wbGF0ZUVsLl94X3ByZXZLZXlzID0ga2V5cztcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZUZvckV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICBsZXQgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcbiAgbGV0IHN0cmlwUGFyZW5zUkUgPSAvXlxccypcXCh8XFwpXFxzKiQvZztcbiAgbGV0IGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XG4gIGxldCBpbk1hdGNoID0gZXhwcmVzc2lvbi5tYXRjaChmb3JBbGlhc1JFKTtcbiAgaWYgKCFpbk1hdGNoKVxuICAgIHJldHVybjtcbiAgbGV0IHJlcyA9IHt9O1xuICByZXMuaXRlbXMgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgbGV0IGl0ZW0gPSBpbk1hdGNoWzFdLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgXCJcIikudHJpbSgpO1xuICBsZXQgaXRlcmF0b3JNYXRjaCA9IGl0ZW0ubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgcmVzLml0ZW0gPSBpdGVtLnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgXCJcIikudHJpbSgpO1xuICAgIHJlcy5pbmRleCA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICByZXMuY29sbGVjdGlvbiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMuaXRlbSA9IGl0ZW07XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdldEl0ZXJhdGlvblNjb3BlVmFyaWFibGVzKGl0ZXJhdG9yTmFtZXMsIGl0ZW0sIGluZGV4LCBpdGVtcykge1xuICBsZXQgc2NvcGVWYXJpYWJsZXMgPSB7fTtcbiAgaWYgKC9eXFxbLipcXF0kLy50ZXN0KGl0ZXJhdG9yTmFtZXMuaXRlbSkgJiYgQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgIGxldCBuYW1lcyA9IGl0ZXJhdG9yTmFtZXMuaXRlbS5yZXBsYWNlKFwiW1wiLCBcIlwiKS5yZXBsYWNlKFwiXVwiLCBcIlwiKS5zcGxpdChcIixcIikubWFwKChpKSA9PiBpLnRyaW0oKSk7XG4gICAgbmFtZXMuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xuICAgICAgc2NvcGVWYXJpYWJsZXNbbmFtZV0gPSBpdGVtW2ldO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKC9eXFx7LipcXH0kLy50ZXN0KGl0ZXJhdG9yTmFtZXMuaXRlbSkgJiYgIUFycmF5LmlzQXJyYXkoaXRlbSkgJiYgdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIpIHtcbiAgICBsZXQgbmFtZXMgPSBpdGVyYXRvck5hbWVzLml0ZW0ucmVwbGFjZShcIntcIiwgXCJcIikucmVwbGFjZShcIn1cIiwgXCJcIikuc3BsaXQoXCIsXCIpLm1hcCgoaSkgPT4gaS50cmltKCkpO1xuICAgIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIHNjb3BlVmFyaWFibGVzW25hbWVdID0gaXRlbVtuYW1lXTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzY29wZVZhcmlhYmxlc1tpdGVyYXRvck5hbWVzLml0ZW1dID0gaXRlbTtcbiAgfVxuICBpZiAoaXRlcmF0b3JOYW1lcy5pbmRleClcbiAgICBzY29wZVZhcmlhYmxlc1tpdGVyYXRvck5hbWVzLmluZGV4XSA9IGluZGV4O1xuICBpZiAoaXRlcmF0b3JOYW1lcy5jb2xsZWN0aW9uKVxuICAgIHNjb3BlVmFyaWFibGVzW2l0ZXJhdG9yTmFtZXMuY29sbGVjdGlvbl0gPSBpdGVtcztcbiAgcmV0dXJuIHNjb3BlVmFyaWFibGVzO1xufVxuZnVuY3Rpb24gaXNOdW1lcmljMyhzdWJqZWN0KSB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheShzdWJqZWN0KSAmJiAhaXNOYU4oc3ViamVjdCk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtcmVmLmpzXG5mdW5jdGlvbiBoYW5kbGVyMigpIHtcbn1cbmhhbmRsZXIyLmlubGluZSA9IChlbCwgeyBleHByZXNzaW9uIH0sIHsgY2xlYW51cCB9KSA9PiB7XG4gIGxldCByb290ID0gY2xvc2VzdFJvb3QoZWwpO1xuICBpZiAoIXJvb3QuX3hfcmVmcylcbiAgICByb290Ll94X3JlZnMgPSB7fTtcbiAgcm9vdC5feF9yZWZzW2V4cHJlc3Npb25dID0gZWw7XG4gIGNsZWFudXAoKCkgPT4gZGVsZXRlIHJvb3QuX3hfcmVmc1tleHByZXNzaW9uXSk7XG59O1xuZGlyZWN0aXZlKFwicmVmXCIsIGhhbmRsZXIyKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1pZi5qc1xuZGlyZWN0aXZlKFwiaWZcIiwgKGVsLCB7IGV4cHJlc3Npb24gfSwgeyBlZmZlY3Q6IGVmZmVjdDMsIGNsZWFudXAgfSkgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbik7XG4gIGxldCBzaG93ID0gKCkgPT4ge1xuICAgIGlmIChlbC5feF9jdXJyZW50SWZFbClcbiAgICAgIHJldHVybiBlbC5feF9jdXJyZW50SWZFbDtcbiAgICBsZXQgY2xvbmUyID0gZWwuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgYWRkU2NvcGVUb05vZGUoY2xvbmUyLCB7fSwgZWwpO1xuICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICBlbC5hZnRlcihjbG9uZTIpO1xuICAgICAgaW5pdFRyZWUoY2xvbmUyKTtcbiAgICB9KTtcbiAgICBlbC5feF9jdXJyZW50SWZFbCA9IGNsb25lMjtcbiAgICBlbC5feF91bmRvSWYgPSAoKSA9PiB7XG4gICAgICB3YWxrKGNsb25lMiwgKG5vZGUpID0+IHtcbiAgICAgICAgaWYgKCEhbm9kZS5feF9lZmZlY3RzKSB7XG4gICAgICAgICAgbm9kZS5feF9lZmZlY3RzLmZvckVhY2goZGVxdWV1ZUpvYik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2xvbmUyLnJlbW92ZSgpO1xuICAgICAgZGVsZXRlIGVsLl94X2N1cnJlbnRJZkVsO1xuICAgIH07XG4gICAgcmV0dXJuIGNsb25lMjtcbiAgfTtcbiAgbGV0IGhpZGUgPSAoKSA9PiB7XG4gICAgaWYgKCFlbC5feF91bmRvSWYpXG4gICAgICByZXR1cm47XG4gICAgZWwuX3hfdW5kb0lmKCk7XG4gICAgZGVsZXRlIGVsLl94X3VuZG9JZjtcbiAgfTtcbiAgZWZmZWN0MygoKSA9PiBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XG4gICAgdmFsdWUgPyBzaG93KCkgOiBoaWRlKCk7XG4gIH0pKTtcbiAgY2xlYW51cCgoKSA9PiBlbC5feF91bmRvSWYgJiYgZWwuX3hfdW5kb0lmKCkpO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtaWQuanNcbmRpcmVjdGl2ZShcImlkXCIsIChlbCwgeyBleHByZXNzaW9uIH0sIHsgZXZhbHVhdGU6IGV2YWx1YXRlMiB9KSA9PiB7XG4gIGxldCBuYW1lcyA9IGV2YWx1YXRlMihleHByZXNzaW9uKTtcbiAgbmFtZXMuZm9yRWFjaCgobmFtZSkgPT4gc2V0SWRSb290KGVsLCBuYW1lKSk7XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1vbi5qc1xubWFwQXR0cmlidXRlcyhzdGFydGluZ1dpdGgoXCJAXCIsIGludG8ocHJlZml4KFwib246XCIpKSkpO1xuZGlyZWN0aXZlKFwib25cIiwgc2tpcER1cmluZ0Nsb25lKChlbCwgeyB2YWx1ZSwgbW9kaWZpZXJzLCBleHByZXNzaW9uIH0sIHsgY2xlYW51cCB9KSA9PiB7XG4gIGxldCBldmFsdWF0ZTIgPSBleHByZXNzaW9uID8gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbikgOiAoKSA9PiB7XG4gIH07XG4gIGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidGVtcGxhdGVcIikge1xuICAgIGlmICghZWwuX3hfZm9yd2FyZEV2ZW50cylcbiAgICAgIGVsLl94X2ZvcndhcmRFdmVudHMgPSBbXTtcbiAgICBpZiAoIWVsLl94X2ZvcndhcmRFdmVudHMuaW5jbHVkZXModmFsdWUpKVxuICAgICAgZWwuX3hfZm9yd2FyZEV2ZW50cy5wdXNoKHZhbHVlKTtcbiAgfVxuICBsZXQgcmVtb3ZlTGlzdGVuZXIgPSBvbihlbCwgdmFsdWUsIG1vZGlmaWVycywgKGUpID0+IHtcbiAgICBldmFsdWF0ZTIoKCkgPT4ge1xuICAgIH0sIHsgc2NvcGU6IHsgXCIkZXZlbnRcIjogZSB9LCBwYXJhbXM6IFtlXSB9KTtcbiAgfSk7XG4gIGNsZWFudXAoKCkgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XG59KSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL2luZGV4LmpzXG53YXJuTWlzc2luZ1BsdWdpbkRpcmVjdGl2ZShcIkNvbGxhcHNlXCIsIFwiY29sbGFwc2VcIiwgXCJjb2xsYXBzZVwiKTtcbndhcm5NaXNzaW5nUGx1Z2luRGlyZWN0aXZlKFwiSW50ZXJzZWN0XCIsIFwiaW50ZXJzZWN0XCIsIFwiaW50ZXJzZWN0XCIpO1xud2Fybk1pc3NpbmdQbHVnaW5EaXJlY3RpdmUoXCJGb2N1c1wiLCBcInRyYXBcIiwgXCJmb2N1c1wiKTtcbndhcm5NaXNzaW5nUGx1Z2luRGlyZWN0aXZlKFwiTWFza1wiLCBcIm1hc2tcIiwgXCJtYXNrXCIpO1xuZnVuY3Rpb24gd2Fybk1pc3NpbmdQbHVnaW5EaXJlY3RpdmUobmFtZSwgZGlyZWN0aXZlTmFtZTIsIHNsdWcpIHtcbiAgZGlyZWN0aXZlKGRpcmVjdGl2ZU5hbWUyLCAoZWwpID0+IHdhcm4oYFlvdSBjYW4ndCB1c2UgW3gtJHtkaXJlY3RpdmVOYW1lMn1dIHdpdGhvdXQgZmlyc3QgaW5zdGFsbGluZyB0aGUgXCIke25hbWV9XCIgcGx1Z2luIGhlcmU6IGh0dHBzOi8vYWxwaW5lanMuZGV2L3BsdWdpbnMvJHtzbHVnfWAsIGVsKSk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9pbmRleC5qc1xuYWxwaW5lX2RlZmF1bHQuc2V0RXZhbHVhdG9yKG5vcm1hbEV2YWx1YXRvcik7XG5hbHBpbmVfZGVmYXVsdC5zZXRSZWFjdGl2aXR5RW5naW5lKHsgcmVhY3RpdmU6IHJlYWN0aXZlMiwgZWZmZWN0OiBlZmZlY3QyLCByZWxlYXNlOiBzdG9wLCByYXc6IHRvUmF3IH0pO1xudmFyIHNyY19kZWZhdWx0ID0gYWxwaW5lX2RlZmF1bHQ7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL2J1aWxkcy9tb2R1bGUuanNcbnZhciBtb2R1bGVfZGVmYXVsdCA9IHNyY19kZWZhdWx0O1xuZXhwb3J0IHtcbiAgbW9kdWxlX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/alpinejs@3.12.1/node_modules/alpinejs/dist/module.esm.js\n");

/***/ }),

/***/ "./assets/scripts/modules/alpinejs.js":
/*!********************************************!*\
  !*** ./assets/scripts/modules/alpinejs.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var alpinejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alpinejs */ \"./node_modules/.pnpm/alpinejs@3.12.1/node_modules/alpinejs/dist/module.esm.js\");\n/* harmony import */ var _fylgja_alpinejs_dialog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fylgja/alpinejs-dialog */ \"./node_modules/.pnpm/@fylgja+alpinejs-dialog@1.0.1/node_modules/@fylgja/alpinejs-dialog/dist/index.mjs\");\n\n\nwindow.Alpine = alpinejs__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nalpinejs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plugin(_fylgja_alpinejs_dialog__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\nalpinejs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].start();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvc2NyaXB0cy9tb2R1bGVzL2FscGluZWpzLmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUE4QjtBQUNlO0FBRTdDRSxNQUFNLENBQUNGLE1BQU0sR0FBR0EsZ0RBQU07QUFFdEJBLHVEQUFhLENBQUNDLCtEQUFNLENBQUM7QUFDckJELHNEQUFZLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlbnByaXNlLWZyb250ZW5kLXRvb2wvLi9hc3NldHMvc2NyaXB0cy9tb2R1bGVzL2FscGluZWpzLmpzPzU2ZDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEFscGluZSBmcm9tICdhbHBpbmVqcyc7XG5pbXBvcnQgZGlhbG9nIGZyb20gJ0BmeWxnamEvYWxwaW5lanMtZGlhbG9nJztcblxud2luZG93LkFscGluZSA9IEFscGluZTtcblxuQWxwaW5lLnBsdWdpbihkaWFsb2cpO1xuQWxwaW5lLnN0YXJ0KCk7Il0sIm5hbWVzIjpbIkFscGluZSIsImRpYWxvZyIsIndpbmRvdyIsInBsdWdpbiIsInN0YXJ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/scripts/modules/alpinejs.js\n");

/***/ }),

/***/ "./node_modules/.pnpm/@fylgja+alpinejs-dialog@1.0.1/node_modules/@fylgja/alpinejs-dialog/dist/index.mjs":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@fylgja+alpinejs-dialog@1.0.1/node_modules/@fylgja/alpinejs-dialog/dist/index.mjs ***!
  \**************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ module_default; }\n/* harmony export */ });\n// src/dialog.js\nfunction dialog_default(Alpine) {\n  Alpine.directive(\"dialog\", fylgjaAlpineDialog);\n  function fylgjaAlpineDialog(el, { expression, modifiers }, { evaluateLater, cleanup }) {\n    const evaluate = expression.length ? evaluateLater(expression) : () => {\n    };\n    const lockPageScroll = modifiers.includes(\"noscroll\");\n    el.style.display = null;\n    el.hidden = false;\n    el.style.length === 0 && el.removeAttribute(\"style\");\n    function scrollLock(use = true) {\n      document.body.style.overflow = use ? \"hidden\" : \"\";\n    }\n    function escapeDialog(event) {\n      if (event.key !== \"Escape\")\n        return;\n      event.preventDefault();\n      evaluate();\n    }\n    function backdropDialog(event) {\n      const rect = el.getBoundingClientRect();\n      const isInDialog = rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;\n      if (isInDialog)\n        return;\n      evaluate();\n    }\n    el._x_doShow = () => {\n      if (el.hasAttribute(\"open\"))\n        return;\n      el.showModal();\n      document.addEventListener(\"keydown\", escapeDialog);\n      el.addEventListener(\"click\", backdropDialog);\n      scrollLock(lockPageScroll);\n    };\n    el._x_doHide = () => {\n      if (!el.hasAttribute(\"open\"))\n        return;\n      el.close();\n      document.removeEventListener(\"keydown\", escapeDialog);\n      el.removeEventListener(\"click\", backdropDialog);\n      scrollLock(false);\n    };\n    cleanup(() => {\n      document.removeEventListener(\"keydown\", escapeDialog);\n      el.removeEventListener(\"click\", backdropDialog);\n      scrollLock(false);\n    });\n  }\n}\n\n// src/module.js\nvar module_default = dialog_default;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGZ5bGdqYSthbHBpbmVqcy1kaWFsb2dAMS4wLjEvbm9kZV9tb2R1bGVzL0BmeWxnamEvYWxwaW5lanMtZGlhbG9nL2Rpc3QvaW5kZXgubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdUJBQXVCLElBQUksd0JBQXdCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlbnByaXNlLWZyb250ZW5kLXRvb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vQGZ5bGdqYSthbHBpbmVqcy1kaWFsb2dAMS4wLjEvbm9kZV9tb2R1bGVzL0BmeWxnamEvYWxwaW5lanMtZGlhbG9nL2Rpc3QvaW5kZXgubWpzP2FmNDQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2RpYWxvZy5qc1xuZnVuY3Rpb24gZGlhbG9nX2RlZmF1bHQoQWxwaW5lKSB7XG4gIEFscGluZS5kaXJlY3RpdmUoXCJkaWFsb2dcIiwgZnlsZ2phQWxwaW5lRGlhbG9nKTtcbiAgZnVuY3Rpb24gZnlsZ2phQWxwaW5lRGlhbG9nKGVsLCB7IGV4cHJlc3Npb24sIG1vZGlmaWVycyB9LCB7IGV2YWx1YXRlTGF0ZXIsIGNsZWFudXAgfSkge1xuICAgIGNvbnN0IGV2YWx1YXRlID0gZXhwcmVzc2lvbi5sZW5ndGggPyBldmFsdWF0ZUxhdGVyKGV4cHJlc3Npb24pIDogKCkgPT4ge1xuICAgIH07XG4gICAgY29uc3QgbG9ja1BhZ2VTY3JvbGwgPSBtb2RpZmllcnMuaW5jbHVkZXMoXCJub3Njcm9sbFwiKTtcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gbnVsbDtcbiAgICBlbC5oaWRkZW4gPSBmYWxzZTtcbiAgICBlbC5zdHlsZS5sZW5ndGggPT09IDAgJiYgZWwucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgZnVuY3Rpb24gc2Nyb2xsTG9jayh1c2UgPSB0cnVlKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gdXNlID8gXCJoaWRkZW5cIiA6IFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZURpYWxvZyhldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmtleSAhPT0gXCJFc2NhcGVcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2YWx1YXRlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJhY2tkcm9wRGlhbG9nKGV2ZW50KSB7XG4gICAgICBjb25zdCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBpc0luRGlhbG9nID0gcmVjdC50b3AgPD0gZXZlbnQuY2xpZW50WSAmJiBldmVudC5jbGllbnRZIDw9IHJlY3QudG9wICsgcmVjdC5oZWlnaHQgJiYgcmVjdC5sZWZ0IDw9IGV2ZW50LmNsaWVudFggJiYgZXZlbnQuY2xpZW50WCA8PSByZWN0LmxlZnQgKyByZWN0LndpZHRoO1xuICAgICAgaWYgKGlzSW5EaWFsb2cpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGV2YWx1YXRlKCk7XG4gICAgfVxuICAgIGVsLl94X2RvU2hvdyA9ICgpID0+IHtcbiAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoXCJvcGVuXCIpKVxuICAgICAgICByZXR1cm47XG4gICAgICBlbC5zaG93TW9kYWwoKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGVzY2FwZURpYWxvZyk7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgYmFja2Ryb3BEaWFsb2cpO1xuICAgICAgc2Nyb2xsTG9jayhsb2NrUGFnZVNjcm9sbCk7XG4gICAgfTtcbiAgICBlbC5feF9kb0hpZGUgPSAoKSA9PiB7XG4gICAgICBpZiAoIWVsLmhhc0F0dHJpYnV0ZShcIm9wZW5cIikpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGVsLmNsb3NlKCk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBlc2NhcGVEaWFsb2cpO1xuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGJhY2tkcm9wRGlhbG9nKTtcbiAgICAgIHNjcm9sbExvY2soZmFsc2UpO1xuICAgIH07XG4gICAgY2xlYW51cCgoKSA9PiB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBlc2NhcGVEaWFsb2cpO1xuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGJhY2tkcm9wRGlhbG9nKTtcbiAgICAgIHNjcm9sbExvY2soZmFsc2UpO1xuICAgIH0pO1xuICB9XG59XG5cbi8vIHNyYy9tb2R1bGUuanNcbnZhciBtb2R1bGVfZGVmYXVsdCA9IGRpYWxvZ19kZWZhdWx0O1xuZXhwb3J0IHtcbiAgbW9kdWxlX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@fylgja+alpinejs-dialog@1.0.1/node_modules/@fylgja/alpinejs-dialog/dist/index.mjs\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./assets/scripts/modules/alpinejs.js");
/******/ 	
/******/ })()
;